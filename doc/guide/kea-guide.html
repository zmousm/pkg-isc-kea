<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Kea Administrator Reference Manual</title><link rel="stylesheet" type="text/css" href="kea-guide.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><meta name="description" content="Kea is an open source implementation of the Dynamic Host Configuration Protocol (DHCP) servers, developed and maintained by Internet Systems Consortium (ISC). This is the reference guide for Kea version 1.4.0-beta. The most up-to-date version of this document (in PDF, HTML, and plain text formats), along with other documents for Kea, can be found at http://kea.isc.org/docs."></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book"><div class="titlepage"><div><div><h1 class="title"><a name="idp55740784"></a>
    <span class="inlinemediaobject"><img src="kea-logo-100x70.png" align="left"></span>
    Kea Administrator Reference Manual
    </h1></div><div><p class="releaseinfo">This is the reference guide for Kea version 1.4.0-beta.</p></div><div><p class="copyright">Copyright © 2010-2018 Internet Systems Consortium, Inc. ("ISC")</p></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>
        Kea is an open source implementation of the Dynamic Host Configuration
        Protocol (DHCP) servers, developed and maintained by Internet Systems
        Consortium (ISC).
      </p><p>
        This is the reference guide for Kea version 1.4.0-beta.
        The most up-to-date version of this document (in PDF, HTML,
        and plain text formats), along with other documents for
        Kea, can be found at <code class="uri"><a class="uri" href="http://kea.isc.org/docs" target="_top">http://kea.isc.org/docs</a></code>.
        </p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="chapter"><a href="#intro">1. Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#idp49243840">1.1. Supported Platforms</a></span></dt><dt><span class="section"><a href="#required-software">1.2. Required Software at Run-time</a></span></dt><dt><span class="section"><a href="#kea_software">1.3. Kea Software</a></span></dt></dl></dd><dt><span class="chapter"><a href="#quickstart">2. Quick Start</a></span></dt><dd><dl><dt><span class="section"><a href="#quick-start">2.1. Quick Start Guide for DHCPv4 and DHCPv6 Services</a></span></dt><dt><span class="section"><a href="#quick-start-direct-run">2.2. Running the Kea Servers Directly</a></span></dt></dl></dd><dt><span class="chapter"><a href="#installation">3. Installation</a></span></dt><dd><dl><dt><span class="section"><a href="#packages">3.1. Packages</a></span></dt><dt><span class="section"><a href="#install-hierarchy">3.2. Installation Hierarchy</a></span></dt><dt><span class="section"><a href="#build-requirements">3.3. Building Requirements</a></span></dt><dt><span class="section"><a href="#install">3.4. Installation from Source</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55835488">3.4.1. Download Tar File</a></span></dt><dt><span class="section"><a href="#idp55837344">3.4.2. Retrieve from Git</a></span></dt><dt><span class="section"><a href="#configure">3.4.3. Configure Before the Build</a></span></dt><dt><span class="section"><a href="#idp55879488">3.4.4. Build</a></span></dt><dt><span class="section"><a href="#idp55881456">3.4.5. Install</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp-config-backend">3.5. Selecting the Configuration Backend</a></span></dt><dt><span class="section"><a href="#dhcp-install-configure">3.6. DHCP Database Installation and Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55897824">3.6.1. Building with MySQL Support</a></span></dt><dt><span class="section"><a href="#idp55903104">3.6.2. Building with PostgreSQL support</a></span></dt><dt><span class="section"><a href="#idp55908544">3.6.3. Building with CQL (Cassandra) support</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#admin">4. Kea Database Administration</a></span></dt><dd><dl><dt><span class="section"><a href="#kea-database-version">4.1. Databases and Database Version Numbers</a></span></dt><dt><span class="section"><a href="#kea-admin">4.2. The kea-admin Tool</a></span></dt><dt><span class="section"><a href="#supported-databases">4.3. Supported Databases</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55962240">4.3.1. memfile</a></span></dt><dt><span class="section"><a href="#mysql-database">4.3.2. MySQL</a></span></dt><dt><span class="section"><a href="#pgsql-database">4.3.3. PostgreSQL</a></span></dt><dt><span class="section"><a href="#cql-database">4.3.4. CQL (Cassandra)</a></span></dt><dt><span class="section"><a href="#idp56064288">4.3.5. Using Read-Only Databases with Host Reservations</a></span></dt><dt><span class="section"><a href="#idp56067072">4.3.6. Limitations Related to the use of SQL Databases</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#kea-config">5. Kea Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#json">5.1. JSON Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#json-format">5.1.1. JSON Syntax</a></span></dt><dt><span class="section"><a href="#idp56092624">5.1.2. Simplified Notation</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#keactrl">6. Managing Kea with keactrl</a></span></dt><dd><dl><dt><span class="section"><a href="#keactrl-overview">6.1. Overview</a></span></dt><dt><span class="section"><a href="#keactrl-usage">6.2. Command Line Options</a></span></dt><dt><span class="section"><a href="#keactrl-config-file">6.3. The keactrl Configuration File</a></span></dt><dt><span class="section"><a href="#keactrl-commands">6.4. Commands</a></span></dt><dt><span class="section"><a href="#keactrl-overriding-servers">6.5. Overriding the Server Selection</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kea-ctrl-agent">7. Kea Control Agent</a></span></dt><dd><dl><dt><span class="section"><a href="#agent-overview">7.1. Overview</a></span></dt><dt><span class="section"><a href="#agent-configuration">7.2. Configuration</a></span></dt><dt><span class="section"><a href="#agent-secure-connection">7.3. Secure Connections</a></span></dt><dt><span class="section"><a href="#agent-limitations">7.4. Control Agent Limitations</a></span></dt><dt><span class="section"><a href="#agent-launch">7.5. Starting Control Agent</a></span></dt><dt><span class="section"><a href="#agent-clients">7.6. Connecting to the Control Agent</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dhcp4">8. The DHCPv4 Server</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp4-start-stop">8.1. Starting and Stopping the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-configuration">8.2. DHCPv4 Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp56251344">8.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp56251600">8.2.2. Lease Storage</a></span></dt><dt><span class="section"><a href="#hosts4-storage">8.2.3. Hosts Storage</a></span></dt><dt><span class="section"><a href="#dhcp4-interface-configuration">8.2.4. Interface Configuration</a></span></dt><dt><span class="section"><a href="#dhcpinform-unicast-issues">8.2.5. Issues with Unicast Responses to DHCPINFORM</a></span></dt><dt><span class="section"><a href="#ipv4-subnet-id">8.2.6. IPv4 Subnet Identifier</a></span></dt><dt><span class="section"><a href="#dhcp4-address-config">8.2.7. Configuration of IPv4 Address Pools</a></span></dt><dt><span class="section"><a href="#dhcp4-std-options">8.2.8. Standard DHCPv4 Options</a></span></dt><dt><span class="section"><a href="#dhcp4-custom-options">8.2.9. Custom DHCPv4 options</a></span></dt><dt><span class="section"><a href="#dhcp4-private-opts">8.2.10. DHCPv4 Private Options</a></span></dt><dt><span class="section"><a href="#dhcp4-vendor-opts">8.2.11. DHCPv4 Vendor Specific Options</a></span></dt><dt><span class="section"><a href="#dhcp4-option-spaces">8.2.12. Nested DHCPv4 Options (Custom Option Spaces)</a></span></dt><dt><span class="section"><a href="#dhcp4-option-data-defaults">8.2.13. Unspecified Parameters for DHCPv4 Option Configuration</a></span></dt><dt><span class="section"><a href="#dhcp4-stateless-configuration">8.2.14. Stateless Configuration of DHCPv4 Clients</a></span></dt><dt><span class="section"><a href="#dhcp4-client-classifier">8.2.15. Client Classification in DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-ddns-config">8.2.16. DDNS for DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-next-server">8.2.17. Next Server (siaddr)</a></span></dt><dt><span class="section"><a href="#dhcp4-echo-client-id">8.2.18. Echoing Client-ID (RFC 6842)</a></span></dt><dt><span class="section"><a href="#dhcp4-match-client-id">8.2.19. Using Client Identifier and Hardware Address</a></span></dt><dt><span class="section"><a href="#dhcp4-dhcp4o6-config">8.2.20. DHCPv4-over-DHCPv6: DHCPv4 Side</a></span></dt></dl></dd><dt><span class="section"><a href="#host-reservation-v4">8.3. Host Reservation in DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#reservation4-types">8.3.1. Address Reservation Types</a></span></dt><dt><span class="section"><a href="#reservation4-conflict">8.3.2. Conflicts in DHCPv4 Reservations</a></span></dt><dt><span class="section"><a href="#reservation4-hostname">8.3.3. Reserving a Hostname</a></span></dt><dt><span class="section"><a href="#reservation4-options">8.3.4. Including Specific DHCPv4 Options in Reservations</a></span></dt><dt><span class="section"><a href="#reservation4-message-fields">8.3.5. Reserving Next Server, Server Hostname and Boot File Name</a></span></dt><dt><span class="section"><a href="#reservation4-client-classes">8.3.6. Reserving Client Classes in DHCPv4</a></span></dt><dt><span class="section"><a href="#reservations4-mysql-pgsql-cql">8.3.7. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</a></span></dt><dt><span class="section"><a href="#reservations4-tuning">8.3.8. Fine Tuning DHCPv4 Host Reservation</a></span></dt></dl></dd><dt><span class="section"><a href="#shared-network4">8.4. Shared networks in DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#idp56996800">8.4.1. Local and relayed traffic in shared networks</a></span></dt><dt><span class="section"><a href="#idp57004464">8.4.2. Client classification in shared networks</a></span></dt><dt><span class="section"><a href="#idp57014272">8.4.3. Host reservations in shared networks</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp4-serverid">8.5. Server Identifier in DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-subnet-selection">8.6. How the DHCPv4 Server Selects a Subnet for the Client</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp4-relay-override">8.6.1. Using a Specific Relay Agent for a Subnet</a></span></dt><dt><span class="section"><a href="#dhcp4-srv-example-client-class-relay">8.6.2. Segregating IPv4 Clients in a Cable Network</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp4-decline">8.7. Duplicate Addresses (DHCPDECLINE Support)</a></span></dt><dt><span class="section"><a href="#dhcp4-stats">8.8. Statistics in the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-ctrl-channel">8.9. Management API for the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-std">8.10. Supported DHCP Standards</a></span></dt><dt><span class="section"><a href="#dhcp4-user-contexts">8.11. User contexts in IPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-limit">8.12. DHCPv4 Server Limitations</a></span></dt><dt><span class="section"><a href="#dhcp4-srv-examples">8.13. Kea DHCPv4 server examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dhcp6">9. The DHCPv6 Server</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp6-start-stop">9.1. Starting and Stopping the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-configuration">9.2. DHCPv6 Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp57194240">9.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp57194368">9.2.2. Lease Storage</a></span></dt><dt><span class="section"><a href="#hosts6-storage">9.2.3. Hosts Storage</a></span></dt><dt><span class="section"><a href="#dhcp6-interface-selection">9.2.4. Interface Selection</a></span></dt><dt><span class="section"><a href="#ipv6-subnet-id">9.2.5. IPv6 Subnet Identifier</a></span></dt><dt><span class="section"><a href="#dhcp6-unicast">9.2.6. Unicast Traffic Support</a></span></dt><dt><span class="section"><a href="#dhcp6-address-config">9.2.7. Subnet and Address Pool</a></span></dt><dt><span class="section"><a href="#idp57326512">9.2.8. Subnet and Prefix Delegation Pools</a></span></dt><dt><span class="section"><a href="#pd-exclude-option">9.2.9. Prefix Exclude Option</a></span></dt><dt><span class="section"><a href="#dhcp6-std-options">9.2.10. Standard DHCPv6 Options</a></span></dt><dt><span class="section"><a href="#s46-options">9.2.11. Common Softwire46 Options</a></span></dt><dt><span class="section"><a href="#dhcp6-custom-options">9.2.12. Custom DHCPv6 Options</a></span></dt><dt><span class="section"><a href="#dhcp6-vendor-opts">9.2.13. DHCPv6 Vendor-Specific Options</a></span></dt><dt><span class="section"><a href="#dhcp6-option-spaces">9.2.14. Nested DHCPv6 Options (Custom Option Spaces)</a></span></dt><dt><span class="section"><a href="#dhcp6-option-data-defaults">9.2.15. Unspecified Parameters for DHCPv6 Option Configuration</a></span></dt><dt><span class="section"><a href="#dhcp6-config-subnets">9.2.16. IPv6 Subnet Selection</a></span></dt><dt><span class="section"><a href="#dhcp6-rapid-commit">9.2.17. Rapid Commit</a></span></dt><dt><span class="section"><a href="#dhcp6-relays">9.2.18. DHCPv6 Relays</a></span></dt><dt><span class="section"><a href="#dhcp6-rsoo">9.2.19. Relay-Supplied Options</a></span></dt><dt><span class="section"><a href="#dhcp6-client-classifier">9.2.20. Client Classification in DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-ddns-config">9.2.21. DDNS for DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-dhcp4o6-config">9.2.22. DHCPv4-over-DHCPv6: DHCPv6 Side</a></span></dt></dl></dd><dt><span class="section"><a href="#host-reservation-v6">9.3. Host Reservation in DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#reservation6-types">9.3.1. Address/Prefix Reservation Types</a></span></dt><dt><span class="section"><a href="#reservation6-conflict">9.3.2. Conflicts in DHCPv6 Reservations</a></span></dt><dt><span class="section"><a href="#reservation6-hostname">9.3.3. Reserving a Hostname</a></span></dt><dt><span class="section"><a href="#reservation6-options">9.3.4. Including Specific DHCPv6 Options in Reservations</a></span></dt><dt><span class="section"><a href="#reservation6-client-classes">9.3.5. Reserving Client Classes in DHCPv6</a></span></dt><dt><span class="section"><a href="#reservations6-mysql-pgsql-cql">9.3.6. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</a></span></dt><dt><span class="section"><a href="#reservations6-tuning">9.3.7. Fine Tuning DHCPv6 Host Reservation</a></span></dt></dl></dd><dt><span class="section"><a href="#shared-network6">9.4. Shared networks in DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#idp57794880">9.4.1. Local and relayed traffic in shared networks</a></span></dt><dt><span class="section"><a href="#idp57802400">9.4.2. Client classification in shared networks</a></span></dt><dt><span class="section"><a href="#idp57812720">9.4.3. Host reservations in shared networks</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp6-serverid">9.5. Server Identifier in DHCPv6</a></span></dt><dt><span class="section"><a href="#stateless-dhcp6">9.6. Stateless DHCPv6 (Information-Request Message)</a></span></dt><dt><span class="section"><a href="#dhcp6-rfc7550">9.7. Support for RFC 7550</a></span></dt><dt><span class="section"><a href="#dhcp6-relay-override">9.8. Using Specific Relay Agent for a Subnet</a></span></dt><dt><span class="section"><a href="#dhcp6-client-class-relay">9.9. Segregating IPv6 Clients in a Cable Network</a></span></dt><dt><span class="section"><a href="#mac-in-dhcpv6">9.10. MAC/Hardware Addresses in DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-decline">9.11. Duplicate Addresses (DECLINE Support)</a></span></dt><dt><span class="section"><a href="#dhcp6-stats">9.12. Statistics in the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-ctrl-channel">9.13. Management API for the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-user-contexts">9.14. User contexts in IPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-std">9.15. Supported DHCPv6 Standards</a></span></dt><dt><span class="section"><a href="#dhcp6-limit">9.16. DHCPv6 Server Limitations</a></span></dt><dt><span class="section"><a href="#dhcp6-srv-examples">9.17. Kea DHCPv6 server examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#lease-expiration">10. Lease Expiration in DHCPv4 and DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#lease-reclamation">10.1. Lease Reclamation</a></span></dt><dt><span class="section"><a href="#lease-reclaim-config">10.2. Configuring Lease Reclamation</a></span></dt><dt><span class="section"><a href="#lease-affinity">10.3. Configuring Lease Affinity</a></span></dt><dt><span class="section"><a href="#lease-reclamation-defaults">10.4. Default Configuration Values for Leases Reclamation</a></span></dt><dt><span class="section"><a href="#leases-reclamation-using-command">10.5. Reclaiming Expired Leases with Command</a></span></dt></dl></dd><dt><span class="chapter"><a href="#dhcp-ddns-server">11. The DHCP-DDNS Server</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp-ddns-overview">11.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp-ddns-dns-server-selection">11.1.1. DNS Server selection</a></span></dt><dt><span class="section"><a href="#dhcp-ddns-conflict-resolution">11.1.2. Conflict Resolution</a></span></dt><dt><span class="section"><a href="#dhcp-ddns-dual-stack">11.1.3. Dual Stack Environments</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp-ddns-server-start-stop">11.2. Starting and Stopping the DHCP-DDNS Server</a></span></dt><dt><span class="section"><a href="#d2-configuration">11.3. Configuring the DHCP-DDNS Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d2-server-parameter-config">11.3.1. Global Server Parameters</a></span></dt><dt><span class="section"><a href="#d2-tsig-key-list-config">11.3.2. TSIG Key List</a></span></dt><dt><span class="section"><a href="#d2-forward-ddns-config">11.3.3. Forward DDNS</a></span></dt><dt><span class="section"><a href="#d2-reverse-ddns-config">11.3.4. Reverse DDNS</a></span></dt><dt><span class="section"><a href="#d2-user-contexts">11.3.5. User context in DDNS</a></span></dt><dt><span class="section"><a href="#d2-example-config">11.3.6. Example DHCP-DDNS Server Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#idp58287904">11.4. DHCP-DDNS Server Limitations</a></span></dt></dl></dd><dt><span class="chapter"><a href="#kea-lfc">12. The LFC process</a></span></dt><dd><dl><dt><span class="section"><a href="#kea-lfc-overview">12.1. Overview</a></span></dt><dt><span class="section"><a href="#kea-lfc-usage">12.2. Command Line Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#classify">13. Client Classification</a></span></dt><dd><dl><dt><span class="section"><a href="#idp58319600">13.1. Client Classification Overview</a></span></dt><dt><span class="section"><a href="#classification-using-vendor">13.2. Builtin Client Classes</a></span></dt><dt><span class="section"><a href="#classification-using-expressions">13.3. Using Expressions In Classification</a></span></dt><dd><dl><dt><span class="section"><a href="#idp58483488">13.3.1. Logical operators</a></span></dt><dt><span class="section"><a href="#idp58484640">13.3.2. Substring</a></span></dt><dt><span class="section"><a href="#idp58486976">13.3.3. Concat</a></span></dt><dt><span class="section"><a href="#idp58488448">13.3.4. Ifelse</a></span></dt></dl></dd><dt><span class="section"><a href="#classification-configuring">13.4. Configuring Classes</a></span></dt><dt><span class="section"><a href="#classification-using-host-reservations">13.5. Using Static Host Reservations In Classification</a></span></dt><dt><span class="section"><a href="#classification-subnets">13.6. Configuring Subnets With Class Information</a></span></dt><dt><span class="section"><a href="#classification-pools">13.7. Configuring Pools With Class Information</a></span></dt><dt><span class="section"><a href="#idp58518848">13.8. Using Classes</a></span></dt><dt><span class="section"><a href="#idp58520912">13.9. Classes and Hooks</a></span></dt><dt><span class="section"><a href="#idp58524544">13.10. Debugging Expressions</a></span></dt></dl></dd><dt><span class="chapter"><a href="#hooks-libraries">14. Hooks Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#hooks-libraries-introduction">14.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp58545072">14.2. Installing Hook packages</a></span></dt><dt><span class="section"><a href="#idp58545328">14.3. Configuring Hooks Libraries</a></span></dt><dt><span class="section"><a href="#idp58576272">14.4. Available Hooks Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#idp58614576">14.4.1. user_chk: Checking User Access</a></span></dt><dt><span class="section"><a href="#idp58631760">14.4.2. legal_log: Forensic Logging Hooks</a></span></dt><dt><span class="section"><a href="#flex-id">14.4.3. flex_id: Flexible Identifiers for Host Reservations</a></span></dt><dt><span class="section"><a href="#host-cmds">14.4.4. host_cmds: Host Commands</a></span></dt><dt><span class="section"><a href="#lease-cmds">14.4.5. lease_cmds: Lease Commands</a></span></dt><dt><span class="section"><a href="#subnet-cmds">14.4.6. subnet_cmds: Subnet Commands</a></span></dt><dt><span class="section"><a href="#high-availability-library">14.4.7. ha: High Availability</a></span></dt><dt><span class="section"><a href="#hooks-radius">14.4.8. radius: RADIUS server support</a></span></dt><dt><span class="section"><a href="#hooks-host-cache">14.4.9. host_cache: Caching Host Reservations</a></span></dt><dt><span class="section"><a href="#hooks-stat-cmds">14.4.10. stat_cmds: Supplemental Statistics Commands</a></span></dt></dl></dd><dt><span class="section"><a href="#user-context">14.5. User contexts</a></span></dt></dl></dd><dt><span class="chapter"><a href="#stats">15. Statistics</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59230016">15.1. Statistics Overview</a></span></dt><dt><span class="section"><a href="#stats-lifecycle">15.2. Statistics Lifecycle</a></span></dt><dt><span class="section"><a href="#command-stats">15.3. Commands for Manipulating Statistics</a></span></dt><dd><dl><dt><span class="section"><a href="#command-statistic-get">15.3.1. statistic-get command</a></span></dt><dt><span class="section"><a href="#command-statistic-reset">15.3.2. statistic-reset command</a></span></dt><dt><span class="section"><a href="#command-statistic-remove">15.3.3. statistic-remove command</a></span></dt><dt><span class="section"><a href="#command-statistic-get-all">15.3.4. statistic-get-all command</a></span></dt><dt><span class="section"><a href="#command-statistic-reset-all">15.3.5. statistic-reset-all command</a></span></dt><dt><span class="section"><a href="#command-statistic-remove-all">15.3.6. statistic-remove-all command</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ctrl-channel">16. Management API</a></span></dt><dd><dl><dt><span class="section"><a href="#ctrl-channel-syntax">16.1. Data Syntax</a></span></dt><dt><span class="section"><a href="#ctrl-channel-client">16.2. Using the Control Channel</a></span></dt><dt><span class="section"><a href="#commands-common">16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers</a></span></dt><dd><dl><dt><span class="section"><a href="#command-build-report">16.3.1. build-report</a></span></dt><dt><span class="section"><a href="#command-config-get">16.3.2. config-get</a></span></dt><dt><span class="section"><a href="#command-config-reload">16.3.3. config-reload</a></span></dt><dt><span class="section"><a href="#command-config-test">16.3.4. config-test</a></span></dt><dt><span class="section"><a href="#command-config-write">16.3.5. config-write</a></span></dt><dt><span class="section"><a href="#command-leases-reclaim">16.3.6. leases-reclaim</a></span></dt><dt><span class="section"><a href="#command-libreload">16.3.7. libreload</a></span></dt><dt><span class="section"><a href="#command-list-commands">16.3.8. list-commands</a></span></dt><dt><span class="section"><a href="#command-config-set">16.3.9. config-set</a></span></dt><dt><span class="section"><a href="#command-shutdown">16.3.10. shutdown</a></span></dt><dt><span class="section"><a href="#command-dhcp-disable">16.3.11. dhcp-disable</a></span></dt><dt><span class="section"><a href="#command-dhcp-enable">16.3.12. dhcp-enable</a></span></dt><dt><span class="section"><a href="#command-version-get">16.3.13. version-get</a></span></dt></dl></dd><dt><span class="section"><a href="#agent-commands">16.4. Commands Supported by Control Agent</a></span></dt></dl></dd><dt><span class="chapter"><a href="#libdhcp">17. The libdhcp++ Library</a></span></dt><dd><dl><dt><span class="section"><a href="#iface-detect">17.1. Interface detection and Socket handling</a></span></dt></dl></dd><dt><span class="chapter"><a href="#logging">18. Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59399776">18.1. Logging Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59402512">18.1.1. Loggers</a></span></dt><dt><span class="section"><a href="#logging-message-format">18.1.2. Logging Message Format</a></span></dt><dt><span class="section"><a href="#logging-during-startup">18.1.3. Logging During Kea Startup</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#kea-shell">19. The Kea Shell</a></span></dt><dd><dl><dt><span class="section"><a href="#shell-overview">19.1. Overview</a></span></dt><dt><span class="section"><a href="#shell-usage">19.2. Shell Usage</a></span></dt></dl></dd><dt><span class="chapter"><a href="#faq">20. Frequently Asked Questions</a></span></dt><dd><dl><dt><span class="section"><a href="#faq-generic">20.1. General Frequently Asked Questions</a></span></dt><dd><dl><dt><span class="section"><a href="#q1-generic">20.1.1. Where did the Kea name came from?</a></span></dt><dt><span class="section"><a href="#q2-generic">20.1.2. Feature X is not supported yet. When/if will it be available?</a></span></dt></dl></dd><dt><span class="section"><a href="#faq-dhcp4">20.2. Frequently Asked Questions about DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59595232">20.2.1. I set up a firewall, but the Kea server still receives the traffic. Why?</a></span></dt></dl></dd><dt><span class="section"><a href="#faq-dhcp6">20.3. Frequently Asked Questions about DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59600832">20.3.1. Kea DHCPv6 doesn't seem to get incoming traffic. I checked with tcpdump (or other traffic
      capture software) that the incoming traffic is reaching the box. What's wrong?</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#acknowledgments">21. Acknowledgments</a></span></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>4.1. <a href="#backends">List of available backends</a></dt><dt>8.1. <a href="#dhcp4-std-options-list">List of standard DHCPv4 options</a></dt><dt>8.2. <a href="#dhcp-types">List of standard DHCP option types</a></dt><dt>8.3. <a href="#fqdn-flag-table">Default FQDN Flag Behavior</a></dt><dt>8.4. <a href="#dhcp4-statistics">DHCPv4 Statistics</a></dt><dt>9.1. <a href="#dhcp6-std-options-list">List of Standard DHCPv6 Options</a></dt><dt>9.2. <a href="#dhcp6-exp-options-list">List of Experimental DHCPv6 Options</a></dt><dt>9.3. <a href="#dhcp6-fqdn-flag-table">Default FQDN Flag Behavior</a></dt><dt>9.4. <a href="#dhcp6-statistics">DHCPv6 Statistics</a></dt><dt>11.1. <a href="#idp58244192">Our example network</a></dt><dt>11.2. <a href="#idp58258912">Forward DDNS Domains Needed</a></dt><dt>11.3. <a href="#idp58273360">Reverse DDNS Domains Needed</a></dt><dt>13.1. <a href="#classification-values-list">List of Classification Values</a></dt><dt>13.2. <a href="#classification-expressions-list">List of Classification Expressions</a></dt><dt>14.1. <a href="#hook-libs">List of available hooks libraries</a></dt><dt>14.2. <a href="#ha-default-states-behavior">Default behavior of the server in various HA states</a></dt></dl></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="intro"></a>Chapter 1. Introduction</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idp49243840">1.1. Supported Platforms</a></span></dt><dt><span class="section"><a href="#required-software">1.2. Required Software at Run-time</a></span></dt><dt><span class="section"><a href="#kea_software">1.3. Kea Software</a></span></dt></dl></div><p>
      Kea is the next generation of DHCP software developed by ISC.
      It supports both DHCPv4 and DHCPv6 protocols along with their
      extensions, e.g. prefix delegation and dynamic updates to DNS.
    </p><p>
      Kea was initially developed as a part of the BIND 10 framework.
      In early 2014, ISC made the decision to discontinue active
      development of BIND 10 and continue development of Kea as
      standalone DHCP software.
    </p><p>
      This guide covers Kea version 1.4.0-beta.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp49243840"></a>1.1. Supported Platforms</h2></div></div></div><p>
        Kea is officially supported on Red Hat Enterprise Linux,
	    CentOS, Fedora and FreeBSD systems. It is also likely to work on many
	    other platforms: Kea 1.3.0 builds have been tested on (in no
        particular order) Red Hat Enterprise Linux 6.4, Debian GNU/Linux 7,
        Ubuntu 12.04, Ubuntu 14.04, Ubuntu 16.04, Fedora 22, Fedora 25, CentOS Linux 7,
        FreeBSD 11.0 OS X 10.11, OS X 10.12, Debian 7.11
      </p><p>There are currently no plans to port Kea to Windows platforms.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="required-software"></a>1.2. Required Software at Run-time</h2></div></div></div><p>
        Running Kea uses various extra software which may
        not be provided in the default installation of some operating systems,
        nor in the standard package collections. You may
        need to install this required software separately.
        (For the build requirements, also see
        <a class="xref" href="#build-requirements" title="3.3. Building Requirements">Section 3.3, “Building Requirements”</a>.)
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
        Kea supports two crypto libraries: Botan and OpenSSL. Only one of them
        is required to be installed during compilation. Kea uses the Botan
        crypto library for C++ (<code class="uri"><a class="uri" href="http://botan.randombit.net/" target="_top">http://botan.randombit.net/</a></code>),
        version 1.8 or later. As an alternative to Botan, Kea can use the
        OpenSSL crypto library (<code class="uri"><a class="uri" href="http://www.openssl.org/" target="_top">http://www.openssl.org/</a></code>),
        version 1.0.1 or later.
            </li><li class="listitem">
        Kea uses the log4cplus C++ logging library
        (<code class="uri"><a class="uri" href="http://log4cplus.sourceforge.net/" target="_top">http://log4cplus.sourceforge.net/</a></code>).
        It requires log4cplus version 1.0.3 or later.
            </li><li class="listitem">
	In order to store lease information in a MySQL database, Kea requires MySQL
    headers and libraries.  This is an optional dependency in that Kea can be
    built without MySQL support.
            </li><li class="listitem">
	In order to store lease information in a PostgreSQL database, Kea requires PostgreSQL
    headers and libraries.  This is an optional dependency in that Kea can be
    built without PostgreSQL support.
            </li><li class="listitem">
	In order to store lease information in a Cassandra  database (CQL), Kea
    requires Cassandra headers and libraries. This is an optional dependency
    in that Kea can be built without Cassandra support.
            </li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kea_software"></a>1.3. Kea Software</h2></div></div></div><p>
        Kea is modular.  Part of this modularity is
        accomplished using multiple cooperating processes which, together,
        provide the server functionality.
        The following software is included with Kea:
      </p><p>

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>keactrl</strong></span> —
              Tool to start, stop, reconfigure, and report status
              for the Kea servers.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4</strong></span> —
              The DHCPv4 server process.
              This process responds to DHCPv4 queries from clients.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6</strong></span> —
              The DHCPv6 server process.
              This process responds to DHCPv6 queries from clients.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns</strong></span> —
              The DHCP Dynamic DNS process.
              This process acts as an intermediary between the DHCP servers
              and DNS servers. It receives name update requests from the DHCP
              servers and sends DNS Update messages to the DNS servers.
            </li><li class="listitem">
              <span class="command"><strong>kea-admin</strong></span> —
              A useful tool for database backend maintenance (creating a new
              database, checking versions, upgrading etc.)
            </li><li class="listitem">
              <span class="command"><strong>kea-lfc</strong></span> —
              This process removes redundant information from the files used
              to provide persistent storage for the memfile data base backend.
              While it can be run standalone, it is normally run as and when 
              required by the Kea DHCP servers.
            </li><li class="listitem">
              <span class="command"><strong>kea-ctrl-agent</strong></span> —
              Kea Control Agent (CA) is a daemon exposes a RESTful control
              interface for managing Kea servers.
            </li><li class="listitem">
              <span class="command"><strong>perfdhcp</strong></span> —
              A DHCP benchmarking tool which simulates multiple clients to
              test both DHCPv4 and DHCPv6 server performance.
            </li></ul></div><p>
      </p></div><p>
      The tools and modules are covered in full detail in this guide.

      In addition, manual pages are also provided in the default installation.
    </p><p>
      Kea also provides C++ libraries and programmer interfaces for
      DHCP.  These include detailed developer documentation and
      code examples.

    </p></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="quickstart"></a>Chapter 2. Quick Start</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#quick-start">2.1. Quick Start Guide for DHCPv4 and DHCPv6 Services</a></span></dt><dt><span class="section"><a href="#quick-start-direct-run">2.2. Running the Kea Servers Directly</a></span></dt></dl></div><p>
        This section describes the basic steps needed to get Kea up and running.
        For further details, full customizations, and troubleshooting, see the
        respective chapters in the Kea guide.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quick-start"></a>2.1. Quick Start Guide for DHCPv4 and DHCPv6 Services</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
            Install required run-time and build dependencies. See <a class="xref" href="#build-requirements" title="3.3. Building Requirements">Section 3.3, “Building Requirements”</a> for details.
          </li><li class="listitem"><p>
            Download Kea source tarball from <a class="ulink" href="https://www.isc.org/downloads/" target="_top">ISC.org downloads page</a> or <a class="ulink" href="http://ftp.isc.org/isc/kea/" target="_top">ISC ftp server</a>.
          </p></li><li class="listitem"><p>
            Extract the tarball. For example:
            </p><pre class="screen">$ <strong class="userinput"><code>tar xvzf kea-1.4.0-beta.tar.gz</code></strong></pre><p>
          </p></li><li class="listitem"><p>Go into the source directory and run the configure script:
            </p><pre class="screen">$ <strong class="userinput"><code>cd kea-1.4.0-beta</code></strong>
$ <strong class="userinput"><code>./configure [your extra parameters]</code></strong></pre><p>
          </p></li><li class="listitem"><p>Build it:
            </p><pre class="screen">$ <strong class="userinput"><code>make</code></strong></pre><p>
          </p></li><li class="listitem"><p>Install it (by default it will be placed in
          <code class="filename">/usr/local/</code>,
          so it is likely that you will need root privileges for this step):
            </p><pre class="screen"># <strong class="userinput"><code>make install</code></strong></pre><p>
          </p></li><li class="listitem"><p>Edit the Kea configuration files which by default are installed in
          the <code class="filename">[kea-install-dir]/etc/kea/</code> directory. These are:
          <code class="filename">kea-dhcp4.conf</code>, <code class="filename">kea-dhcp6.conf</code>,
          <code class="filename">kea-dhcp-ddns.conf</code> and
          <code class="filename">kea-ctrl-agent.conf</code>, for DHCPv4 server, DHCPv6 server,
          D2 and Control Agent respectively.
          </p></li><li class="listitem"><p>In order to start the DHCPv4 server in background, run the
          following command (as root):
          </p><pre class="screen"># <strong class="userinput"><code>keactrl start -s dhcp4</code></strong></pre><p>
          Or run the following command to start DHCPv6 server instead:
          </p><pre class="screen"># <strong class="userinput"><code>keactrl start -s dhcp6</code></strong></pre><p>
          Note that it is also possible to start all servers simultaneously:
          </p><pre class="screen">$ <strong class="userinput"><code>keactrl start</code></strong></pre><p>
          </p></li><li class="listitem"><p>Verify that Kea server(s) are running:
          </p><pre class="screen"># <strong class="userinput"><code>keactrl status</code></strong></pre><p>
          A server status of "inactive" may indicate a configuration
          error. Please check the log file (by default named
          <code class="filename">[kea-install-dir]/var/kea/kea-dhcp4.log</code>,
          <code class="filename">[kea-install-dir]/var/kea/kea-dhcp6.log</code>,
          <code class="filename">[kea-install-dir]/var/kea/kea-ddns.log</code> or
          <code class="filename">[kea-install-dir]/var/kea/kea-ctrl-agent.log</code>) 
          for the details of the error.
          </p></li><li class="listitem"><p>
            If the server has been started successfully, test that it is
            responding to DHCP queries and that the client
            receives a configuration from the server; for example, use
            the <a class="ulink" href="http://www.isc.org/downloads/DHCP/" target="_top">ISC DHCP client</a>.
          </p></li><li class="listitem"><p>
            Stop running the server(s):
            </p><pre class="screen"># <strong class="userinput"><code>keactrl stop</code></strong></pre><p>
          </p></li></ol></div><p>
        For instructions specific to your system, please read the
        <a class="ulink" href="http://kea.isc.org/wiki/SystemSpecificNotes" target="_top">system specific notes</a>,
        available on the <a class="ulink" href="http://kea.isc.org/" target="_top">Kea web site</a>.
      </p><p>The details of <span class="command"><strong>keactrl</strong></span> script usage can be found
      in <a class="xref" href="#keactrl" title="Chapter 6. Managing Kea with keactrl">Chapter 6, <i>Managing Kea with keactrl</i></a>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="quick-start-direct-run"></a>2.2. Running the Kea Servers Directly</h2></div></div></div><p>The Kea servers can be started directly, without the need to use the
      <span class="command"><strong>keactrl</strong></span>. To start the DHCPv4 server run the following
      command:
      </p><pre class="screen"># <strong class="userinput"><code>kea-dhcp4 -c /path/to/your/kea4/config/file.json</code></strong></pre><p>
      Similarly, to start the DHCPv6 server run the following command:
      </p><pre class="screen"># <strong class="userinput"><code>kea-dhcp6 -c /path/to/your/kea6/config/file.json</code></strong></pre><p>
    </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="installation"></a>Chapter 3. Installation</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#packages">3.1. Packages</a></span></dt><dt><span class="section"><a href="#install-hierarchy">3.2. Installation Hierarchy</a></span></dt><dt><span class="section"><a href="#build-requirements">3.3. Building Requirements</a></span></dt><dt><span class="section"><a href="#install">3.4. Installation from Source</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55835488">3.4.1. Download Tar File</a></span></dt><dt><span class="section"><a href="#idp55837344">3.4.2. Retrieve from Git</a></span></dt><dt><span class="section"><a href="#configure">3.4.3. Configure Before the Build</a></span></dt><dt><span class="section"><a href="#idp55879488">3.4.4. Build</a></span></dt><dt><span class="section"><a href="#idp55881456">3.4.5. Install</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp-config-backend">3.5. Selecting the Configuration Backend</a></span></dt><dt><span class="section"><a href="#dhcp-install-configure">3.6. DHCP Database Installation and Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55897824">3.6.1. Building with MySQL Support</a></span></dt><dt><span class="section"><a href="#idp55903104">3.6.2. Building with PostgreSQL support</a></span></dt><dt><span class="section"><a href="#idp55908544">3.6.3. Building with CQL (Cassandra) support</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="packages"></a>3.1. Packages</h2></div></div></div><p>
        Some operating systems or software package vendors may provide
        ready-to-use, pre-built software packages for Kea.  Installing a
        pre-built package means you do not need to install the software
        required only to build Kea and do not need to <span class="emphasis"><em>make</em></span>
        the software.
      </p><p>
        FreeBSD ports, NetBSD pkgsrc, and Debian
        <span class="emphasis"><em>testing</em></span> package collections provide all the
        prerequisite packages.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="install-hierarchy"></a>3.2. Installation Hierarchy</h2></div></div></div><p>
        The following is the directory layout of the complete Kea installation.
        (All directory paths are relative to the installation directory):
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <code class="filename">bin/</code> —
            utility programs.
          </li><li class="listitem">
            <code class="filename">etc/kea/</code> —
            configuration files.
          </li><li class="listitem">
              <code class="filename">include/</code> —
              C++ development header files.
            </li><li class="listitem">
              <code class="filename">lib/</code> —
              libraries.
            </li><li class="listitem">
              <code class="filename">sbin/</code> —
              server software and commands used by the system administrator.
            </li><li class="listitem">
              <code class="filename">share/kea/</code> —
              configuration specifications and examples.
            </li><li class="listitem">
              <code class="filename">share/doc/kea/</code> —
              this guide, other supplementary documentation, and examples.
            </li><li class="listitem">
              <code class="filename">share/man/</code> —
              manual pages (online documentation).
            </li><li class="listitem">
              <code class="filename">var/kea/</code> —
              server identification, lease databases, and log files.
            </li></ul></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="build-requirements"></a>3.3. Building Requirements</h2></div></div></div><p>
          In addition to the run-time requirements (listed in <a class="xref" href="#required-software" title="1.2. Required Software at Run-time">Section 1.2, “Required Software at Run-time”</a>), building Kea from source code requires
          various development include headers and program development tools.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            Some operating systems have split their distribution packages into
            a run-time and a development package.  You will need to install
            the development package versions, which include header files and
            libraries, to build Kea from the source code.
          </p></div><p>
          Building from source code requires the following software installed
          on the system:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Boost C++ Libraries
          (<code class="uri"><a class="uri" href="http://www.boost.org/" target="_top">http://www.boost.org/</a></code>).
          The oldest Boost version used for testing is 1.57 (it may work with
          older versions). Boost system library is required.  Building boost
          header only is no longer recommended.
        </p></li><li class="listitem"><p>
          Botan (at least version 1.8) or OpenSSL (at least version 1.0.1).
        </p></li><li class="listitem"><p>
            log4cplus (at least version 1.0.3)
          development include headers.
        </p></li><li class="listitem"><p>
          A C++ compiler (with C++11 support) and standard development
          headers. Kea builds have been tested with GCC g++ 4.7.2 4.7.3
          4.8.2 4.8.4 4.8.5 4.9.3 4.9.4 5.3.1 5.4.0 6.3.0 6.3.1
          clang-800.0.38 clang-802.0.42 clang-900.0.37
        </p></li><li class="listitem"><p>
          The development tools automake, libtool, pkg-config.
        </p></li><li class="listitem"><p>
          The MySQL client and the client development libraries, when using
          the --with-mysql configuration flag to build the Kea MySQL
          database backend. In this case an instance of the MySQL server
          running locally or on a machine reachable over a network
          is required. Note that
          running the unit tests requires a local MySQL server.
        </p></li><li class="listitem"><p>
          The PostgreSQL client and the client development libraries, when
          using the --with-pgsql configuration flag to build the Kea
          PostgreSQL database backend. In this case an instance of the
          PostgreSQL server running locally or on some other machine,
          reachable over the network from the machine running Kea, is
          required. Note that running the unit tests requires a local
          PostgreSQL server.
        </p></li><li class="listitem"><p>
          googletest (version 1.8 or later), when using the --with-gtest configuration
          option to build the unit tests.
        </p></li><li class="listitem"><p>
            The documentation generation tools elinks, docbook-xsl, libxslt and Doxygen,
            if using the --enable-generate-docs configuration option
            to create the documentation.
          </p></li></ul></div><p>
          Visit the user-contributed wiki at
          <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/Install" target="_top">http://kea.isc.org/wiki/Install</a></code>
          for system-specific installation tips.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="install"></a>3.4. Installation from Source</h2></div></div></div><p>
        Kea is open source software written in C++.  It is freely available in
        source code form from ISC as a downloadable tar file.  A copy of the Kea
        source code repository is accessible from Github (<code class="uri"><a class="uri" href="https://github.com/isc-projects/kea" target="_top">https://github.com/isc-projects/kea</a></code>). Kea may also be available
        in pre-compiled ready-to-use packages from operating system vendors.
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55835488"></a>3.4.1. Download Tar File</h3></div></div></div><p>
          The Kea release tarballs may be downloaded from:
          <code class="uri"><a class="uri" href="http://ftp.isc.org/isc/kea/" target="_top">http://ftp.isc.org/isc/kea/</a></code> (using FTP or HTTP).
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55837344"></a>3.4.2. Retrieve from Git</h3></div></div></div><p>
          Downloading this "bleeding edge" code is recommended only for
          developers or advanced users.  Using development code in a production
          environment is not recommended.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            When building from source code retrieved via Git, additional
            software will be required:  automake (v1.11 or later),
            libtoolize, and autoconf (v2.69 or later).
            These may need to be installed.
          </p></div><p>
          The latest development code is available on Github (see
          <code class="uri"><a class="uri" href="https://github.com/isc-projects/kea" target="_top">https://github.com/isc-projects/kea</a></code>). The Kea source
          is public and development is done in the <span class="quote">“<span class="quote">master</span>”</span>
          branch.
        </p><p>
          The code can be checked out from
          <code class="filename">https://github.com/isc-projects/kea.git</code>:

        </p><pre class="screen">$ <strong class="userinput"><code>git clone https://github.com/isc-projects/kea.git</code></strong></pre><p>
        </p><p>
          The code checked out from the git repository does not include the
          generated configure script, Makefile.in files, nor their
          related build files.
          They can be created by running <span class="command"><strong>autoreconf</strong></span>
          with the <code class="option">--install</code> switch.
          This will run <span class="command"><strong>autoconf</strong></span>,
          <span class="command"><strong>aclocal</strong></span>,
          <span class="command"><strong>libtoolize</strong></span>,
          <span class="command"><strong>autoheader</strong></span>,
          <span class="command"><strong>automake</strong></span>,
          and related commands.
        </p><p>
          Write access to the Kea repository is only granted to ISC staff. If you
          are a developer planning to contribute to Kea, please fork our Github
          repository and use the "pull request" mechanism to request integration of
          your code. Please consult
          <code class="uri"><a class="uri" href="https://help.github.com/articles/fork-a-repo/" target="_top">https://help.github.com/articles/fork-a-repo/</a></code> for help on
          how to fork a Github repository.
          The <a class="ulink" href="http://kea.isc.org/docs/devel/" target="_top">Kea
          Developer's Guide</a> contains more information about the process, as
          well as describing the requirements for contributed code to be accepted by ISC.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="configure"></a>3.4.3. Configure Before the Build</h3></div></div></div><p>
          Kea uses the GNU Build System to discover build environment
          details.
          To generate the makefiles using the defaults, simply run:
          </p><pre class="screen">$ <strong class="userinput"><code>./configure</code></strong></pre><p>
        </p><p>
          Run <span class="command"><strong>./configure</strong></span> with the <code class="option">--help</code>
          switch to view the different options. Some commonly-used options are:

          </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">--prefix</span></dt><dd>Define the installation location (the
                default is <code class="filename">/usr/local</code>).
              </dd><dt><span class="term">--with-boost-include</span></dt><dd>Define the path to find the Boost headers.
              </dd><dt><span class="term">--with-botan-config</span></dt><dd>Specify the path to the botan-config
                script to build with Botan for cryptographic functions.
              </dd><dt><span class="term">--with-mysql</span></dt><dd>
                Build Kea with code to allow it to store leases and
                host reservations in a MySQL database.
              </dd><dt><span class="term">--with-pgsql</span></dt><dd>
                Build Kea with code to allow it to store leases and
                host reservations in a PostgreSQL database.
              </dd><dt><span class="term">--with-cql</span></dt><dd>
                Build Kea with code to allow it to store leases and
                host reservations in a Cassandra (CQL) database.
              </dd><dt><span class="term">--with-gtest, --with-gtest-source</span></dt><dd>Enable the building of the C++ Unit Tests using the
                Google Test framework. This option specifies the path to the
                gtest source. (If the framework
                is not installed on your system, it can be downloaded
                from <code class="uri"><a class="uri" href="https://github.com/google/googletest" target="_top">https://github.com/google/googletest</a></code>.)
                from <a class="ulink" href="https://github.com/google/googletest" target="_top">https://github.com/google/googletest</a>.)
              </dd><dt><span class="term">--with-benchmark, --with-benchmark-source</span></dt><dd>Enable the building of the database backend
              benchmarks using the Google Benchmark framework. This
              option specifies the path to the gtest source. (If the
              framework is not installed on your system, it can be downloaded
              from <a class="ulink" href="https://github.com/google/benchmark" target="_top">https://github.com/google/benchmark</a>.)
              </dd><dt><span class="term">--with-log4cplus</span></dt><dd>Define the path to find the Log4cplus headers
                and libraries.
              </dd><dt><span class="term">--with-openssl</span></dt><dd>Replace Botan by the OpenSSL the cryptographic library.
                By default <span class="command"><strong>configure</strong></span> searches for a valid
                Botan installation:
                if one is not found, it searches for OpenSSL.
              </dd></dl></div><p>
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
              For instructions concerning the installation and configuration
              of database backends for Kea, see <a class="xref" href="#dhcp-install-configure" title="3.6. DHCP Database Installation and Configuration">Section 3.6, “DHCP Database Installation and Configuration”</a>.
              For information concerning the configuration backends, see
              <a class="xref" href="#dhcp-config-backend" title="3.5. Selecting the Configuration Backend">Section 3.5, “Selecting the Configuration Backend”</a>.
            </p></div><p>
        </p><p>
          For example, the following command configures Kea to find the
          Boost headers in /usr/pkg/include, specifies that PostgreSQL
          support should be enabled, and sets the installation location
          to /opt/kea:

          </p><pre class="screen">$ <strong class="userinput"><code>./configure \
      --with-boost-include=/usr/pkg/include \
      --with-pgsql=/usr/local/bin/pg_config \
      --prefix=/opt/kea</code></strong></pre><p>
        </p><p>
          If you have some problems with building Kea using the header-only
          Boost code or you'd like to use the Boost system library
          (assumed for the sake of this example to be located in /usr/pkg/lib):

          </p><pre class="screen">$ <strong class="userinput"><code>./configure \
      --with-boost-libs=-lboost_system \
      --with-boost-lib-dir=/usr/pkg/lib</code></strong></pre><p>
        </p><p>
          If <span class="command"><strong>configure</strong></span> fails, it may be due to missing or old
          dependencies.
        </p><p>
          If <span class="command"><strong>configure</strong></span> succeeds, it displays a report
          with the parameters used to build the code. This report is saved into
          the file <code class="filename">config.report</code> and is also embedded into
          the executable binaries, e.g., <strong class="userinput"><code>kea-dhcp4</code></strong>.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55879488"></a>3.4.4. Build</h3></div></div></div><p>
          After the configure step is complete, build the executables
          from the C++ code and prepare the Python scripts by running the command:
          </p><pre class="screen">$ <strong class="userinput"><code>make</code></strong></pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55881456"></a>3.4.5. Install</h3></div></div></div><p>
          To install the Kea executables, support files,
          and documentation, issue the command:
          </p><pre class="screen">$ <strong class="userinput"><code>make install</code></strong></pre><p>
        </p><p>
          Do not use any form of parallel or job server options
          (such as GNU make's <span class="command"><strong>-j</strong></span> option) when
          performing this step: doing so may cause errors.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The install step may require superuser privileges.</p></div><p>
          If required, run <span class="command"><strong>ldconfig</strong></span> as root with
          <code class="filename">/usr/local/lib</code> (or with <em class="replaceable"><code>prefix</code></em>/lib if
          configured with --prefix) in
          <code class="filename">/etc/ld.so.conf</code> (or the relevant linker
          cache configuration file for your OS):
          </p><pre class="screen">$ <strong class="userinput"><code>ldconfig</code></strong></pre><p>
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            If you do not run <span class="command"><strong>ldconfig</strong></span> where it is
            required, you may see errors like the following:
            </p><pre class="screen">
              program: error while loading shared libraries: libkea-something.so.1:
              cannot open shared object file: No such file or directory
            </pre><p>
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp-config-backend"></a>3.5. Selecting the Configuration Backend</h2></div></div></div><p>Kea 0.9 introduced configuration backends that are
      switchable during the compilation phase. Only one backend, JSON,
      is currently supported.
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">JSON</span></dt><dd>JSON is the default configuration backend
            that allows Kea to read JSON configuration files from
            disk. It does not require any framework and thus is
            considered more lightweight. It allows dynamic on-line
            reconfiguration using Kea API.</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp-install-configure"></a>3.6. DHCP Database Installation and Configuration</h2></div></div></div><p>
        Kea stores its leases in a lease database.  The software has been
        written in a way that makes it possible to choose which database product
        should be used to store the lease information.  At present, Kea supports
        four database backends: MySQL, PostgreSQL, Cassandra and Memfile. To
        limit external dependencies, MySQL, PostgreSQL and Cassandra support are
        disabled by default and only Memfile is available. Support for the
        optional external database backend must be explicitly included when Kea
        is built.  This section covers the building of Kea with one of the
        optional backends and the creation of the lease database.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          When unit tests are built with Kea (the --with-gtest configuration option is specified),
          the databases must be manually pre-configured for the unit tests to run.
          The details of this configuration can be found in the
          <a class="ulink" href="http://git.kea.isc.org/~tester/kea/doxygen" target="_top">Kea Developer's
          Guide</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55897824"></a>3.6.1. Building with MySQL Support</h3></div></div></div><p>
          Install MySQL according to the instructions for your system.  The client development
          libraries must be installed.
        </p><p>
          Build and install Kea as described in <a class="xref" href="#installation" title="Chapter 3. Installation">Chapter 3, <i>Installation</i></a>, with
          the following modification. To enable the MySQL database code, at the
          "configure" step (see <a class="xref" href="#configure" title="3.4.3. Configure Before the Build">Section 3.4.3, “Configure Before the Build”</a>), the --with-mysql switch
          should be specified:
          </p><pre class="screen"><strong class="userinput"><code>./configure [other-options] --with-mysql</code></strong></pre><p>
              If MySQL was not installed in the default location, the location of the MySQL
          configuration program "mysql_config" should be included with the switch, i.e.
          </p><pre class="screen"><strong class="userinput"><code>./configure [other-options] --with-mysql=<em class="replaceable"><code>path-to-mysql_config</code></em></code></strong></pre><p>
        </p><p>
          See <a class="xref" href="#mysql-database-create" title="4.3.2.1. First Time Creation of the MySQL Database">Section 4.3.2.1, “First Time Creation of the MySQL Database”</a> for details regarding
          MySQL database configuration.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55903104"></a>3.6.2. Building with PostgreSQL support</h3></div></div></div><p>
          Install PostgreSQL according to the instructions for your system.  The client development
          libraries must be installed. Client development libraries are often packaged as "libpq".
        </p><p>
          Build and install Kea as described in <a class="xref" href="#installation" title="Chapter 3. Installation">Chapter 3, <i>Installation</i></a>, with
          the following modification. To enable the PostgreSQL database code, at the
          "configure" step (see <a class="xref" href="#configure" title="3.4.3. Configure Before the Build">Section 3.4.3, “Configure Before the Build”</a>), the --with-pgsql switch
          should be specified:
          </p><pre class="screen"><strong class="userinput"><code>./configure [other-options] --with-pgsql</code></strong></pre><p>
              If PostgreSQL was not installed in the default location, the location of the PostgreSQL
          configuration program "pg_config" should be included with the switch, i.e.
          </p><pre class="screen"><strong class="userinput"><code>./configure [other-options] --with-pgsql=<em class="replaceable"><code>path-to-pg_config</code></em></code></strong></pre><p>
        </p><p>
          See <a class="xref" href="#pgsql-database-create" title="4.3.3.1. First Time Creation of the PostgreSQL Database">Section 4.3.3.1, “First Time Creation of the PostgreSQL Database”</a> for details regarding
          PostgreSQL database configuration.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55908544"></a>3.6.3. Building with CQL (Cassandra) support</h3></div></div></div><p>
          Install Cassandra according to the instructions for your system. The
          Cassandra project website contains useful pointers: <code class="uri"><a class="uri" href="http://cassandra.apache.org" target="_top">http://cassandra.apache.org</a></code>.
        </p><p>
          Download and compile cpp-driver from DataStax. For details regarding
          dependencies for building cpp-driver, see the project homepage
          <code class="uri"><a class="uri" href="https://github.com/datastax/cpp-driver" target="_top">https://github.com/datastax/cpp-driver</a></code>. In June
          2016, the following commands were used:
          </p><pre class="screen">
$ <strong class="userinput"><code>git clone https://github.com/datastax/cpp-driver</code></strong>
$ <strong class="userinput"><code>cd cpp-driver</code></strong>
$ <strong class="userinput"><code>mkdir build</code></strong>
$ <strong class="userinput"><code>cd build</code></strong>
$ <strong class="userinput"><code>cmake ..</code></strong>
$ <strong class="userinput"><code>make</code></strong>
</pre><p>
        </p><p>
          As of June 2016, cpp-driver does not include cql_config script
          yet. Work is in progress to contribute such a script to the cpp-driver
          project but, until that is complete, intermediate steps that need to
          be conducted. A cql_config script is present in the tools/ directory
          of the Kea sources. Before using it, please create a
          cql_config_defines.sh in the same directory (there is an example in
          cql_config_define.sh.sample available, you may copy it over to
          cql_config_defines.sh and edit path specified in it) and change the
          environment variable CPP_DRIVER_PATH to point to the directory, where
          cpp-driver sources are located.
        </p><p>
          Build and install Kea as described in <a class="xref" href="#installation" title="Chapter 3. Installation">Chapter 3, <i>Installation</i></a>, with
          the following modification. To enable the Cassandra (CQL) database code, at the
          "configure" step (see <a class="xref" href="#configure" title="3.4.3. Configure Before the Build">Section 3.4.3, “Configure Before the Build”</a>), do:
          </p><pre class="screen"><strong class="userinput"><code>./configure [other-options] --with-cql=<em class="replaceable"><code>path-to-cql_config</code></em></code></strong></pre><p>
        </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="admin"></a>Chapter 4. Kea Database Administration</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#kea-database-version">4.1. Databases and Database Version Numbers</a></span></dt><dt><span class="section"><a href="#kea-admin">4.2. The kea-admin Tool</a></span></dt><dt><span class="section"><a href="#supported-databases">4.3. Supported Databases</a></span></dt><dd><dl><dt><span class="section"><a href="#idp55962240">4.3.1. memfile</a></span></dt><dt><span class="section"><a href="#mysql-database">4.3.2. MySQL</a></span></dt><dt><span class="section"><a href="#pgsql-database">4.3.3. PostgreSQL</a></span></dt><dt><span class="section"><a href="#cql-database">4.3.4. CQL (Cassandra)</a></span></dt><dt><span class="section"><a href="#idp56064288">4.3.5. Using Read-Only Databases with Host Reservations</a></span></dt><dt><span class="section"><a href="#idp56067072">4.3.6. Limitations Related to the use of SQL Databases</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kea-database-version"></a>4.1. Databases and Database Version Numbers</h2></div></div></div><p>
      Kea supports storing leases and host reservations (i.e. static
      assignments of addresses, prefixes and options) in one of
      the several supported databases. As future versions of Kea
      are released, the structure of those databases will change.
      For example, Kea currently only stores lease information
      and host reservations. Future versions of Kea will store
      additional data such as subnet definitions: the database
      structure will need to be updated to accommodate the extra
      information.
    </p><p>
      A given version of Kea expects a particular structure in
      the database and checks for this by examining the version of
      database it is using.  Separate version numbers are maintained for
      backend databases, independent of the version of Kea itself. It
      is possible that the backend database version will stay the same
      through several Kea revisions: similarly, it is possible that the
      version of backend database may go up several revisions during a
      Kea upgrade.  Versions for each database are independent, so an
      increment in the MySQL database version does not imply an increment
      in that of PostgreSQL.
    </p><p>
      Backend versions are specified in
      a <em class="replaceable"><code>major.minor</code></em> format. The minor
      number is increased when there are backward compatible changes
      introduced.  For example, the addition of a new index. It is
      desirable, but not mandatory to apply such a change; you
      can run on older database version if you want to. (Although, in
      the example given, running without the new index may be at the
      expense of a performance penalty.) On the other hand, the major
      number is increased when an incompatible change is introduced,
      for example an extra column is added to a table. If you try to
      run Kea software on a database that is too old (as signified by
      mismatched backend major version number), Kea will refuse to run:
      administrative action will be required to upgrade the database.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kea-admin"></a>4.2. The kea-admin Tool</h2></div></div></div><p>
      To manage the databases, Kea provides the
      <span class="command"><strong>kea-admin</strong></span> tool. It is able to initialize
      a new database, check its version number, perform a
      database upgrade, and dump lease data to a text file.
    </p><p>
      <span class="command"><strong>kea-admin</strong></span> takes two mandatory
      parameters: <span class="command"><strong>command</strong></span> and
      <span class="command"><strong>backend</strong></span>. Additional, non-mandatory options
      may be specified. Currently supported commands are:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>lease-init</strong></span> —
            Initializes a new lease database. This is useful during a new
            Kea installation. The database is initialized to the
            latest version supported by the version of the software being
            installed.
          </li><li class="listitem">
            <span class="command"><strong>lease-version</strong></span> —
            Reports the lease database version number. This is
            not necessarily equal to the Kea version number as
            each backend has its own versioning scheme.
          </li><li class="listitem">
            <span class="command"><strong>lease-upgrade</strong></span> —
            Conducts a lease database upgrade. This is useful when
            upgrading Kea.
          </li><li class="listitem">
            <span class="command"><strong>lease-dump</strong></span> —
            Dumps the contents of the lease database (for MySQL, PostgreSQL or
            CQL backends) to a CSV (comma separated values) text file. The first
            line of the file contains the column names.  This is meant to be
            used as a diagnostic tool, so it provides a portable, human-readable
            form of the lease data.
          </li></ul></div><p>

      <span class="command"><strong>backend</strong></span> specifies the backend type. Currently
      supported types are:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>memfile</strong></span> — Lease information is
            stored on disk in a text file.
          </li><li class="listitem">
            <span class="command"><strong>mysql</strong></span> —
            Lease information is stored in a MySQL relational database.
          </li><li class="listitem">
            <span class="command"><strong>pgsql</strong></span> —
            Lease information is stored in a PostgreSQL relational database.
          </li><li class="listitem">
            <span class="command"><strong>cql</strong></span> —
            Lease information is stored in a CQL database.
          </li></ul></div><p>

      Additional parameters may be needed, depending on your setup
      and specific operation: username, password and database name or
      the directory where specific files are located. See the appropriate
      manual page for details (<span class="command"><strong>man 8 kea-admin</strong></span>).
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="supported-databases"></a>4.3. Supported Databases</h2></div></div></div><p>The following table presents the capabilities of available
    backends. Please refer to the specific sections dedicated to each backend to
    better understand their capabilities and limitations. Choosing the right
    backend may be essential for success or failure of your deployment.</p><p>
      </p><div class="table"><a name="backends"></a><p class="title"><b>Table 4.1. List of available backends</b></p><div class="table-contents"><table summary="List of available backends" border="1"><colgroup><col class="feature"><col class="memfile"><col class="mysql"><col class="pgsql"><col class="cql"></colgroup><thead><tr><th>Feature</th><th>Memfile</th><th>MySQL</th><th>PostgreSQL</th><th>CQL (Cassandra)</th></tr></thead><tbody><tr><td>Status</td><td>Stable</td><td>Stable</td><td>Stable</td><td>Experimental</td></tr><tr><td>Data format</td><td>CSV file</td><td>SQL RMDB</td><td>SQL RMDB</td><td>NoSQL database (CQL)</td></tr><tr><td>Leases</td><td>yes</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Host Reservations</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>Options defined on per host basis</td><td>no</td><td>yes</td><td>yes</td><td>yes</td></tr></tbody></table></div></div><p><br class="table-break">
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp55962240"></a>4.3.1. memfile</h3></div></div></div><p>
        The memfile backend is able to store lease information, but is not able to
        store host reservation details: these must be stored in the configuration
        file. (There are no plans to add a host reservations storage capability to
        this backend.)
      </p><p>
        No special initialization steps are necessary
        for the memfile backend.  During the first run, both
        <span class="command"><strong>kea-dhcp4</strong></span> and <span class="command"><strong>kea-dhcp6</strong></span>
        will create an empty lease file if one is not
        present. Necessary disk write permission is required.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="memfile-upgrade"></a>4.3.1.1. Upgrading Memfile Lease Files from an Earlier Version of Kea</h4></div></div></div><p>
        There are no special steps required to upgrade memfile lease files
        from an earlier version of Kea to a new version of Kea.

        During startup the servers will check the schema version of the lease
        files against their own.  If there is a mismatch, the servers will
        automatically launch the LFC process to convert the files to the
        server's schema version.  While this mechanism is primarily meant to
        ease the process of upgrading to newer versions of Kea, it can also
        be used for downgrading should the need arise.  When upgrading, any
        values not present in the original lease files will be assigned
        appropriate default values.  When downgrading, any data present in
        the files but not in the server's schema will be dropped.

        If you wish to convert the files manually, prior to starting the
        servers you may do so by running the LFC process yourself.
        See <a class="xref" href="#kea-lfc" title="Chapter 12. The LFC process">Chapter 12, <i>The LFC process</i></a> for more information.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="mysql-database"></a>4.3.2. MySQL</h3></div></div></div><p>
        MySQL is able to store leases, host reservations and options defined on
        a per host basis. This section can be safely ignored
        if you chose to store the data in other backends.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-database-create"></a>4.3.2.1. First Time Creation of the MySQL Database</h4></div></div></div><p>
          If you are setting the MySQL database for the first time,
          you need to create the database area within MySQL and set up
          the MySQL user ID under which Kea will access the database.
          This needs to be done manually: <span class="command"><strong>kea-admin</strong></span>
          is not able to do this for you.
        </p><p>
          To create the database:

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Log into MySQL as "root":
</p><pre class="screen">
$ <strong class="userinput"><code>mysql -u root -p</code></strong>
Enter password:
mysql&gt;
</pre><p>
              </p></li><li class="listitem"><p>
                Create the MySQL database:
</p><pre class="screen">
mysql&gt; <strong class="userinput"><code>CREATE DATABASE <em class="replaceable"><code>database-name</code></em>;</code></strong>
</pre><p>
                (<em class="replaceable"><code>database-name</code></em> is the name
                you have chosen for the database.)
              </p></li><li class="listitem"><p>
                Create the user under which Kea will access the database
                (and give it a password), then grant it access to the
                database tables:
</p><pre class="screen">
mysql&gt; <strong class="userinput"><code>CREATE USER '<em class="replaceable"><code>user-name</code></em>'@'localhost' IDENTIFIED BY '<em class="replaceable"><code>password</code></em>';</code></strong>
mysql&gt; <strong class="userinput"><code>GRANT ALL ON <em class="replaceable"><code>database-name</code></em>.* TO '<em class="replaceable"><code>user-name</code></em>'@'localhost';</code></strong>
</pre><p>
                (<em class="replaceable"><code>user-name</code></em> and
                <em class="replaceable"><code>password</code></em> are the user ID
                and password you are using to allow Keas access to the
                MySQL instance. All apostrophes in the command lines
                above are required.)
              </p></li><li class="listitem"><p>
                At this point, you may elect to create the database
                tables. (Alternatively, you can exit MySQL and create
                the tables using the <span class="command"><strong>kea-admin</strong></span> tool,
                as explained below.)  To do this:
</p><pre class="screen">
mysql&gt; <strong class="userinput"><code>CONNECT <em class="replaceable"><code>database-name</code></em>;</code></strong>
mysql&gt; <strong class="userinput"><code>SOURCE <em class="replaceable"><code>path-to-kea</code></em>/share/kea/scripts/mysql/dhcpdb_create.mysql</code></strong>
</pre><p>
                (<em class="replaceable"><code>path-to-kea</code></em> is the
                location where you installed Kea.)
              </p></li><li class="listitem"><p>
                Exit MySQL:
</p><pre class="screen">
mysql&gt; <strong class="userinput"><code>quit</code></strong>
Bye
$
</pre><p>
              </p></li></ol></div><p>
        </p><p>
          If you elected not to create the tables in step 4, you can do
          so now by running the <span class="command"><strong>kea-admin</strong></span> tool:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-init mysql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
          (Do not do this if you did create the tables in step 4.)
          <span class="command"><strong>kea-admin</strong></span> implements rudimentary checks:
          it will refuse to initialize a database that contains any
          existing tables. If you want to start from scratch, you
          must remove all data manually. (This process is a manual
          operation on purpose to avoid possibly irretrievable mistakes
          by <span class="command"><strong>kea-admin</strong></span>.)
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="mysql-upgrade"></a>4.3.2.2. Upgrading a MySQL Database from an Earlier Version of Kea</h4></div></div></div><p>
          Sometimes a new Kea version may use newer database schema, so
          there will be a need to upgrade the existing database. This can
          be done using the <span class="command"><strong>kea-admin lease-upgrade</strong></span>
          command.
        </p><p>
          To check the current version of the database, use the following command:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-version mysql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
          (See <a class="xref" href="#kea-database-version" title="4.1. Databases and Database Version Numbers">Section 4.1, “Databases and Database Version Numbers”</a> for a discussion
          about versioning.)  If the version does not match the minimum
          required for the new version of Kea (as described in the
          release notes), the database needs to be upgraded.
        </p><p>
          Before upgrading, please make sure that the database is
          backed up.  The upgrade process does not discard any data but,
          depending on the nature of the changes, it may be impossible
          to subsequently downgrade to an earlier version.  To perform
          an upgrade, issue the following command:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-upgrade mysql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pgsql-database"></a>4.3.3. PostgreSQL</h3></div></div></div><p>
        PostgreSQL is able to store leases, host reservations and options
        defined on a per host basis.
        A PostgreSQL database must be set up if you want Kea to store
        lease and other information in PostgreSQL. This step can be
        safely ignored if you are using other database backends.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="pgsql-database-create"></a>4.3.3.1. First Time Creation of the PostgreSQL Database</h4></div></div></div><p>
          The first task is to create both the lease database and the
          user under which the servers will access it. A number of steps
          are required:

          </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Log into PostgreSQL as "root":
</p><pre class="screen">
$ <strong class="userinput"><code>sudo -u postgres psql postgres</code></strong>
Enter password:
postgres=#
</pre><p>
              </p></li><li class="listitem"><p>
                Create the database:
</p><pre class="screen">
postgres=#<strong class="userinput"><code> CREATE DATABASE <em class="replaceable"><code>database-name</code></em>;</code></strong>
CREATE DATABASE
postgres=#
</pre><p>
                (<em class="replaceable"><code>database-name</code></em> is the name
                you have chosen for the database.)
              </p></li><li class="listitem"><p>
                Create the user under which Kea will access the database
                (and give it a password), then grant it access to the
                database:
</p><pre class="screen">
postgres=#<strong class="userinput"><code> CREATE USER <em class="replaceable"><code>user-name</code></em> WITH PASSWORD '<em class="replaceable"><code>password</code></em>';</code></strong>
CREATE ROLE
postgres=#<strong class="userinput"><code> GRANT ALL PRIVILEGES ON DATABASE <em class="replaceable"><code>database-name</code></em> TO <em class="replaceable"><code>user-name</code></em>;</code></strong>
GRANT
postgres=#
</pre><p>
              </p></li><li class="listitem"><p>
                Exit PostgreSQL:
</p><pre class="screen">
postgres=# <strong class="userinput"><code>\q</code></strong>
Bye
$
</pre><p>
              </p></li><li class="listitem"><p>
                At this point you are ready to create the database tables.
                This can be done using the <span class="command"><strong>kea-admin</strong></span> tool
                as explained in the next section (recommended), or manually.
                To create the tables manually enter the following command.
                Note that PostgreSQL will prompt you to enter the new user's
                password you specified in Step 3. When the command completes
                you will be returned to the shell prompt. You should see output
                similar to following:
</p><pre class="screen">
$ <strong class="userinput"><code>psql -d <em class="replaceable"><code>database-name</code></em> -U <em class="replaceable"><code>user-name</code></em> -f <em class="replaceable"><code>path-to-kea</code></em>/share/kea/scripts/pgsql/dhcpdb_create.pgsql</code></strong>
Password for user <em class="replaceable"><code>user-name</code></em>:
CREATE TABLE
CREATE INDEX
CREATE INDEX
CREATE TABLE
CREATE INDEX
CREATE TABLE
START TRANSACTION
INSERT 0 1
INSERT 0 1
INSERT 0 1
COMMIT
CREATE TABLE
START TRANSACTION
INSERT 0 1
COMMIT
$
</pre><p>
                (<em class="replaceable"><code>path-to-kea</code></em> is the location
                where you installed Kea.)
              </p><p>
                If instead you encounter an error like:
</p><pre class="screen">
psql: FATAL:  no pg_hba.conf entry for host "[local]", user "<em class="replaceable"><code>user-name</code></em>", database "<em class="replaceable"><code>database-name</code></em>", SSL off
</pre><p>
                ... you will need to alter the PostgreSQL configuration.
                Kea uses password authentication when connecting to
                the database and must have the appropriate entries
                added to PostgreSQL's pg_hba.conf file.  This file is
                normally located in the primary data directory for your
                PostgreSQL server. The precise path may vary but the
                default location for PostgreSQL 9.3 on Centos 6.5 is:
                <code class="filename">/var/lib/pgsql/9.3/data/pg_hba.conf</code>.
              </p><p>
                Assuming Kea is running on the same host as PostgreSQL,
                adding lines similar to following should be sufficient to
                provide password-authenticated access to Kea's database:
</p><pre class="screen">
local   <em class="replaceable"><code>database-name</code></em>    <em class="replaceable"><code>user-name</code></em>                                 password
host    <em class="replaceable"><code>database-name</code></em>    <em class="replaceable"><code>user-name</code></em>          127.0.0.1/32           password
host    <em class="replaceable"><code>database-name</code></em>    <em class="replaceable"><code>user-name</code></em>          ::1/128                password
</pre><p>
              </p><p>
                These edits are primarily intended as a starting point
                not a definitive reference on PostgreSQL administration or
                database security.  Please consult your PostgreSQL user
                manual before making these changes as they may expose
                other databases that you run.  It may be necessary to
                restart PostgreSQL in order for these changes to take effect.
              </p></li></ol></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56025232"></a>4.3.3.2. Initialize the PostgreSQL Database Using kea-admin</h4></div></div></div><p>
          If you elected not to create the tables manually, you can do
          so now by running the <span class="command"><strong>kea-admin</strong></span> tool:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-init pgsql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
          Do not do this if you already created the tables in manually.
          <span class="command"><strong>kea-admin</strong></span> implements rudimentary checks:
          it will refuse to initialize a database that contains any
          existing tables. If you want to start from scratch, you
          must remove all data manually. (This process is a manual
          operation on purpose to avoid possibly irretrievable mistakes
          by <span class="command"><strong>kea-admin</strong></span>.)
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="pgsql-upgrade"></a>4.3.3.3. Upgrading a PostgreSQL Database from an Earlier Version of Kea</h4></div></div></div><p>
          The PostgreSQL database schema can be upgraded using the same tool and
          commands as described in <a class="xref" href="#mysql-upgrade" title="4.3.2.2. Upgrading a MySQL Database from an Earlier Version of Kea">Section 4.3.2.2, “Upgrading a MySQL Database from an Earlier Version of Kea”</a>, with the
          exception that the "pgsql" database backend type must be used in
          the commands.
        </p><p>
          Use the following command to check the current schema version:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-version pgsql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
          Use the following command to perform an upgrade:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-upgrade pgsql -u <em class="replaceable"><code>database-user</code></em> -p <em class="replaceable"><code>database-password</code></em> -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="cql-database"></a>4.3.4. CQL (Cassandra)</h3></div></div></div><p>
        Cassandra, or Cassandra Query Language (CQL), is the newest backend
        added to Kea. Since it was added recently and has not undergone as much
        testing as other backends, it is considered experimental. Please use
        with caution. The Cassandra backend is able to store leases,
        host reservations and options defined on a per host basis.
      </p><p>
        The CQL database must be properly set up if you want Kea to store
        information in CQL. This section can be safely ignored if you chose to
        store the data in other backends.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cql-database-create"></a>4.3.4.1. First Time Creation of the Cassandra Database</h4></div></div></div><p>
        If you are setting up the CQL database for the first time, you need to
        create the keyspace area within CQL. This needs to be done manually:
        <span class="command"><strong>kea-admin</strong></span> is not able to do this for you.
      </p><p>
        To create the database:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
              Export CQLSH_HOST environment variable:
</p><pre class="screen">
$ <strong class="userinput"><code>export CQLSH_HOST=localhost</code></strong>
</pre><p>
              </p></li><li class="listitem"><p>
              Log into CQL:
</p><pre class="screen">
$ <strong class="userinput"><code>cqlsh</code></strong>
cql&gt;
</pre><p>
              </p></li><li class="listitem"><p>
              Create the CQL keyspace:
</p><pre class="screen">
cql&gt; <strong class="userinput"><code>CREATE KEYSPACE keyspace-name WITH replication = {'class' : 'SimpleStrategy','replication_factor' : 1};</code></strong>
</pre><p>
              (<em class="replaceable"><code>keyspace-name</code></em> is the name you have
              chosen for the keyspace)
            </p></li><li class="listitem"><p>
              At this point, you may elect to create the database tables.
              (Alternatively, you can exit CQL and create the tables using the
              <span class="command"><strong>kea-admin</strong></span> tool, as explained below)  To do this:
</p><pre class="screen">
<strong class="userinput"><code>cqslh -k <em class="replaceable"><code>keyspace-name</code></em> -f <em class="replaceable"><code>path-to-kea</code></em>/share/kea/scripts/cql/dhcpdb_create.cql</code></strong>
</pre><p>
              (<em class="replaceable"><code>path-to-kea</code></em> is the location where you
              installed Kea)
            </p></li></ol></div><p>
      </p><p>
        If you elected not to create the tables in step 4, you can do
        so now by running the <span class="command"><strong>kea-admin</strong></span> tool:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-init cql -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
        (Do not do this if you did create the tables in step 4.)
        <span class="command"><strong>kea-admin</strong></span> implements rudimentary checks:
        it will refuse to initialize a database that contains any
        existing tables. If you want to start from scratch, you
        must remove all data manually. (This process is a manual
        operation on purpose to avoid possibly irretrievable mistakes
        by <span class="command"><strong>kea-admin</strong></span>)
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cql-upgrade"></a>4.3.4.2. Upgrading a CQL Database from an Earlier Version of Kea</h4></div></div></div><p>
        Sometimes a new Kea version may use newer database schema, so
        there will be a need to upgrade the existing database. This can
        be done using the <span class="command"><strong>kea-admin lease-upgrade</strong></span>
        command.
      </p><p>
        To check the current version of the database, use the following command:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-version cql -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
        (See <a class="xref" href="#kea-database-version" title="4.1. Databases and Database Version Numbers">Section 4.1, “Databases and Database Version Numbers”</a> for a discussion
        about versioning)  If the version does not match the minimum
        required for the new version of Kea (as described in the
        release notes), the database needs to be upgraded.
      </p><p>
        Before upgrading, please make sure that the database is
        backed up.  The upgrade process does not discard any data but,
        depending on the nature of the changes, it may be impossible
        to subsequently downgrade to an earlier version.  To perform
        an upgrade, issue the following command:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-admin lease-upgrade cql -n <em class="replaceable"><code>database-name</code></em></code></strong>
</pre><p>
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56064288"></a>4.3.5. Using Read-Only Databases with Host Reservations</h3></div></div></div><p>If a read-only database is used for storing host reservations,
      Kea must be explicitly configured to operate on the database in
      read-only mode.
      Sections <a class="xref" href="#read-only-database-configuration4" title="8.2.3.2. Using Read-Only Databases for Host Reservations">Section 8.2.3.2, “Using Read-Only Databases for Host Reservations”</a> and
      <a class="xref" href="#read-only-database-configuration6" title="9.2.3.2. Using Read-Only Databases for Host Reservations">Section 9.2.3.2, “Using Read-Only Databases for Host Reservations”</a> describe when
      such configuration may be required and how to configure Kea to
      operate using a read-only host database.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56067072"></a>4.3.6. Limitations Related to the use of SQL Databases</h3></div></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56067712"></a>4.3.6.1. Year 2038 issue</h4></div></div></div><p>
          The lease expiration time is stored in the SQL database for each lease
          as a timestamp value. Kea developers observed that MySQL database doesn't
          accept timestamps beyond 2147483647 seconds (maximum signed 32-bit number)
          from the beginning of the epoch. At the same time, some versions of PostgreSQL
          do accept greater values but the value is altered when it is read back.
          For this reason the lease database backends put the restriction for the
          maximum timestamp to be stored in the database, which is equal to the
          maximum signed 32-bit number. This effectively means that the current
          Kea version can't store the leases which expiration time is later than
          2147483647 seconds since the beginning of the epoch (around year 2038).
          This will be fixed when the database support for longer timestamps
          is available.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56070048"></a>4.3.6.2. Server Terminates when Database Connection is Lost</h4></div></div></div><p>
          If Kea is configured to use an external database it opens a connection
          to the database and requires that this connection is not interrupted.
          When the database connection breaks, e.g. as a result of SQL server
          restart, DHCP servers will terminate indicating a fatal error. In such
          a case, the system administrator is required to start the database and
          then "manually" start Kea to resume the service.
        </p><p>
          Although the engineering team is planning to implement some form of
          reconnect mechanism in the future, this will mostly be applicable in
          cases when the database service is restarted and the connection
          down time is relatively short. The DHCP server can't provide its
          service as long as the database is down, because it can't store
          leases being assigned to the clients. The server will have to
          reject any DHCP messages as long as the connection is down and
          terminate if the reconnection attempt fails multiple times.
        </p><p>
          Because the database connection is critical for the operation of the
          DHCP service, the current behavior is to terminate when that
          connection is unavailable to indicate that server is in inconsistent
          state and can't serve clients.
        </p></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="kea-config"></a>Chapter 5. Kea Configuration</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#json">5.1. JSON Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#json-format">5.1.1. JSON Syntax</a></span></dt><dt><span class="section"><a href="#idp56092624">5.1.2. Simplified Notation</a></span></dt></dl></dd></dl></div><p>Kea is using JSON structures to handle configuration. Previously
  we there was a concept of other configuration backends, but that never was
  implemented and the idea was abandoned.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="json"></a>5.1. JSON Configuration</h2></div></div></div><p>JSON is notation used throughout the Kea project. The most obvious
    usage is for configuration file, but it is also used for sending commands
    over Management API (see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>) and for
    communicating between DHCP servers and DDNS update daemon.</p><p>Typical usage assumes that the servers are started from the command line
    (either directly or using a script, e.g. <code class="filename">keactrl</code>).
    The JSON backend uses certain signals to influence Kea. The
    configuration file is specified upon startup using the -c parameter.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="json-format"></a>5.1.1. JSON Syntax</h3></div></div></div><p>Configuration files for DHCPv4, DHCPv6 and DDNS modules are defined
      in an extended JSON format. Basic JSON is defined in <a class="ulink" href="http://tools.ietf.org/html/rfc7159" target="_top">RFC 7159</a>. Note that Kea
      1.2 introduces a new parser that is better at following the JSON spec.  In
      particular, the only values allowed for boolean are true or false (all
      lowercase). The capitalized versions (True or False) are not accepted.
      </p><p>Kea components use an extended JSON with additional features
      allowed:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">shell comments: any text after the hash (#)
          character is ignored. Both Dhcp4 and Dhcp6 allow # in any column,
          while Ddns requires hash to be in the first column.</li><li class="listitem">C comments: any text after the double slashes (//)
          character is ignored. Both Dhcp4 and Dhcp6 supports this
          feature.</li><li class="listitem">Multiline comments: any text between /* and */ is
          ignored. This commenting can span multiple lines. Both Dhcp4 and
          Dhcp6 supports this feature.</li><li class="listitem">File inclusion: JSON files can include other JSON
          files. This can be done by using &lt;?include
          "file.json"?&gt;. Both Dhcp4 and Dhcp6 supports this
          feature.</li></ul></div><p>
      </p><p>The configuration file consists of a single object (often colloquially
      called a map) started with a curly bracket. It comprises the "Dhcp4", "Dhcp6",
      "DhcpDdns" and/or "Logging" objects. It is possible to define additional
      elements, but they will be ignored. For example, it is possible to define
      Dhcp4, Dhcp6 and Logging elements in a single configuration file that can
      be used to start both the DHCPv4 and DHCPv6 components. When starting,
      the DHCPv4 component will use Dhcp4 object to configure itself and the
      Logging object to configure logging parameters; it will ignore the Dhcp6
      object.</p><p>A very simple configuration for both DHCPv4 and
      DHCPv6 could look like this:
</p><pre class="screen">
# The whole configuration starts here.
{

# DHCPv4 specific configuration starts here.
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ "eth0" ],
        "dhcp-socket-type": "raw"
    },
    "valid-lifetime": 4000,
    "renew-timer": 1000,
    "rebind-timer": 2000,
    "subnet4": [{
       "pools": [ { "pool": "192.0.2.1-192.0.2.200" } ],
       "subnet": "192.0.2.0/24"
    }]
},
# DHCPv4 specific configuration ends here.

# DHCPv6 specific configuration starts here.
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ "eth1" ]
    },
    "preferred-lifetime": 3000,
    "valid-lifetime": 4000,
    "renew-timer": 1000,
    "rebind-timer": 2000,
    "subnet6": [{
       "pools": [ { "pool": "2001:db8::/80" } ],
       "subnet": "2001:db8::/64"
    }]
},
# DHCPv6 specific configuration ends here.

# Logger parameters (that could be shared among several components) start here.
# This section is used by both the DHCPv4 and DHCPv6 servers.
"Logging": {
   "loggers": [{
        "name": "*",
        "severity": "DEBUG"
    }]
}
# Logger parameters end here.

# The whole configuration structure ends here.
}
</pre><p>
        </p><p>More examples are available in the installed
        <code class="filename">share/doc/kea/examples</code> directory.</p><p>To avoid repetition of mostly similar structures, examples in the
        rest of this guide will showcase only the subset of parameters appropriate for a given
        context. For example, when discussing the IPv6 subnets configuration in
        DHCPv6, only subnet6 parameters will be mentioned. It is implied that
        the remaining elements (the global map that holds Dhcp6, Logging and possibly
        DhcpDdns) are present, but they are omitted for clarity. Usually, locations
        where extra parameters may appear are denoted by an ellipsis.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56092624"></a>5.1.2. Simplified Notation</h3></div></div></div><p>It is sometimes convenient to refer to a specific element in the
        configuration hierarchy. Each hierarchy level is separated by a slash.
        If there is an array, a specific instance within that array is referenced by
        a number in square brackets (with numbering starting at zero). For example, in the above configuration the
        valid-lifetime in the Dhcp6 component can be referred to as
        Dhcp6/valid-lifetime and the pool in the first subnet defined in the DHCPv6
        configuration as Dhcp6/subnet6[0]/pool.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="keactrl"></a>Chapter 6. Managing Kea with keactrl</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#keactrl-overview">6.1. Overview</a></span></dt><dt><span class="section"><a href="#keactrl-usage">6.2. Command Line Options</a></span></dt><dt><span class="section"><a href="#keactrl-config-file">6.3. The keactrl Configuration File</a></span></dt><dt><span class="section"><a href="#keactrl-commands">6.4. Commands</a></span></dt><dt><span class="section"><a href="#keactrl-overriding-servers">6.5. Overriding the Server Selection</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="keactrl-overview"></a>6.1. Overview</h2></div></div></div><p>keactrl is a shell script which controls the startup, shutdown
      and reconfiguration of the Kea servers (<span class="command"><strong>kea-dhcp4</strong></span>,
      <span class="command"><strong>kea-dhcp6</strong></span>, <span class="command"><strong>kea-dhcp-ddns</strong></span> and
      <span class="command"><strong>kea-ctrl-agent</strong></span>). It also provides the means for
      checking the current status of the servers and determining the
      configuration files in use.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="keactrl-usage"></a>6.2. Command Line Options</h2></div></div></div><p><span class="command"><strong>keactrl</strong></span> is run as follows:
</p><pre class="screen">
keactrl &lt;command&gt; [-c keactrl-config-file] [-s server[,server,..]]
</pre><p>
      </p><p>
        <span class="command"><strong>&lt;command&gt;</strong></span> is the one of the commands
        described in <a class="xref" href="#keactrl-commands" title="6.4. Commands">Section 6.4, “Commands”</a>.
      </p><p>
        The optional <span class="command"><strong>-c keactrl-config-file</strong></span> switch
        allows specification of an alternate <span class="command"><strong>keactrl</strong></span>
        configuration file. (<span class="command"><strong>--ctrl-config</strong></span> is a synonym for
        <span class="command"><strong>-c</strong></span>.) In the absence of <span class="command"><strong>-c</strong></span>,
        <span class="command"><strong>keactrl</strong></span> will use the default configuration
        file <code class="filename">[kea-install-dir]/etc/kea/keactrl.conf</code>.
      </p><p>
        The optional <span class="command"><strong>-s server[,server ...]</strong></span> switch selects
        the servers to which the command is issued.
        (<span class="command"><strong>--server</strong></span> is a synonym for <span class="command"><strong>-s</strong></span>.)
        If absent, the command is sent to all servers enabled in the keactrl
        configuration file.
        If multiple servers are specified, they
        should be separated by commas with no intervening spaces.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="keactrl-config-file"></a>6.3. The keactrl Configuration File</h2></div></div></div><p>
        Depending on requirements, not all of the available servers need
        be run.  The keactrl configuration file sets which servers are
        enabled and which are disabled.  The default configuration
        file is <code class="filename">[kea-install-dir]/etc/kea/keactrl.conf</code>,
        but this can be overridden on a per-command basis using the
        <span class="command"><strong>-c</strong></span> switch.
      </p><p>
        The contents of <code class="filename">keactrl.conf</code> are:
</p><pre class="screen">
# This is a configuration file for keactrl script which controls
# the startup, shutdown, reconfiguration and gathering the status
# of the Kea's processes.

# prefix holds the location where the Kea is installed.
prefix=@prefix@

# Location of Kea configuration file.
kea_dhcp4_config_file=@sysconfdir@/@PACKAGE@/kea-dhcp4.conf
kea_dhcp6_config_file=@sysconfdir@/@PACKAGE@/kea-dhcp6.conf
kea_dhcp_ddns_config_file=@sysconfdir@/@PACKAGE@/kea-dhcp-ddns.conf
kea_ctrl_agent_config_file=@sysconfdir@/@PACKAGE@/kea-ctrl-agent.conf


# Location of Kea binaries.
exec_prefix=@exec_prefix@
dhcp4_srv=@sbindir@/kea-dhcp4
dhcp6_srv=@sbindir@/kea-dhcp6
dhcp_ddns_srv=@sbindir@/kea-dhcp-ddns
ctrl_agent_srv=@sbindir@/kea-ctrl-agent

# Start DHCPv4 server?
dhcp4=yes

# Start DHCPv6 server?
dhcp6=yes

# Start DHCP DDNS server?
dhcp_ddns=no

# Start Control Agent?
ctrl_agent=yes

# Be verbose?
kea_verbose=no
</pre><p>
      </p><p>
        The <em class="parameter"><code>dhcp4</code></em>, <em class="parameter"><code>dhcp6</code></em>,
        <em class="parameter"><code>dhcp_ddns</code></em> and <em class="parameter"><code>ctrl_agent</code></em>
        parameters set to "yes" configure <span class="command"><strong>keactrl</strong></span> to manage
        (start, reconfigure) all servers, i.e. <span class="command"><strong>kea-dhcp4</strong></span>,
        <span class="command"><strong>kea-dhcp6</strong></span>, <span class="command"><strong>kea-dhcp-ddns</strong></span> and
        <span class="command"><strong>kea-ctrl-agent</strong></span>. When any of these parameters is set
        to "no" the <span class="command"><strong>keactrl</strong></span> will ignore
        the corresponding server when starting or reconfiguring Kea.
      </p><p>
        By default, Kea servers managed by <span class="command"><strong>keactrl</strong></span> are
        located in <code class="filename">[kea-install-dir]/sbin</code>. This
        should work for most installations. If the default
        location needs to be altered for any reason, the paths
        specified with the <em class="parameter"><code>dhcp4_srv</code></em>,
        <em class="parameter"><code>dhcp6_srv</code></em>, <em class="parameter"><code>dhcp_ddns_srv</code></em>
        and <em class="parameter"><code>ctrl_agent_srv</code></em> parameters should be modified.
      </p><p>
        The <em class="parameter"><code>kea_verbose</code></em> parameter specifies the verbosity
        of the servers being started. When <em class="parameter"><code>kea_verbose</code></em>
        is set to "yes" the logging level of the server is set to DEBUG.
        Modification of the logging severity in a configuration file, as
        described in <a class="xref" href="#logging" title="Chapter 18. Logging">Chapter 18, <i>Logging</i></a>, will have no effect as long
        as the <em class="parameter"><code>kea_verbose</code></em> is set to "yes". Setting
        it to "no" will cause the server to use the logging levels specified
        in the Kea configuration file for respective loggers. If no
        logging configuration is specified, the default settings will be
        used.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The verbosity for the server is set  when it is started. Once
          started, the verbosity can be only changed by stopping the server and
          starting it again with the new value of the
          <em class="parameter"><code>kea_verbose</code></em> parameter.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="keactrl-commands"></a>6.4. Commands</h2></div></div></div><p>The following commands are supported by <span class="command"><strong>keactrl</strong></span>:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="command"><strong>start</strong></span> - starts selected servers.
        </li><li class="listitem">
          <span class="command"><strong>stop</strong></span> - stops all running servers.
        </li><li class="listitem">
          <span class="command"><strong>reload</strong></span> - triggers reconfiguration of the
          selected servers by sending the SIGHUP signal to them.
        </li><li class="listitem">
          <span class="command"><strong>status</strong></span> - returns the status of the servers (active
          or inactive) and the names of the configuration files in use.
        </li></ul></div><p>
      </p><p>Typical output from <span class="command"><strong>keactrl</strong></span> when starting
      the servers looks similar to the following:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl start</code></strong>
INFO/keactrl: Starting kea-dhcp4 -c /usr/local/etc/kea/kea-dhcp4.conf -d
INFO/keactrl: Starting kea-dhcp6 -c /usr/local/etc/kea/kea-dhcp6.conf -d
INFO/keactrl: Starting kea-dhcp-ddns -c /usr/local/etc/kea/kea-dhcp-ddns.conf -d
INFO/keactrl: Starting kea-ctrl-agent -c /usr/local/etc/kea/kea-ctrl-agent.conf -d
</pre><p>
      </p><p>Kea's servers create PID files upon startup. These files are used
      by keactrl to determine whether or not a given server is running.  If
      one or more servers are running when the start command is issued, the
      output will look similar to the following:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl start</code></strong>
INFO/keactrl: kea-dhcp4 appears to be running, see: PID 10918, PID file: /usr/local/var/kea/kea.kea-dhcp4.pid.
INFO/keactrl: kea-dhcp6 appears to be running, see: PID 10924, PID file: /usr/local/var/kea/kea.kea-dhcp6.pid.
INFO/keactrl: kea-dhcp-ddns appears to be running, see: PID 10930, PID file: /usr/local/var/kea/kea.kea-dhcp-ddns.pid.
INFO/keactrl: kea-ctrl-agent appears to be running, see: PID 10931, PID file: /usr/local/var/kea/kea.kea-ctrl-agent.pid.
</pre><p>
      During normal shutdowns these PID files are deleted. They may, however,
      be left over as remnants following a system crash.  It is possible,
      though highly unlikely, that upon system restart the PIDs they contain
      actually refer to processes unrelated to Kea.  This condition will cause
      keactrl to decide that the servers are running, when in fact they are
      not.  In such a case the PID files as listed in the keactrl output
      must be manually deleted.
      </p><p>The following command stops all servers:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl stop</code></strong>
INFO/keactrl: Stopping kea-dhcp4...
INFO/keactrl: Stopping kea-dhcp6...
INFO/keactrl: Stopping kea-dhcp-ddns...
INFO/keactrl: Stopping kea-ctrl-agent...
</pre><p>
      Note that the <span class="command"><strong>stop</strong></span> will attempt to stop all servers
      regardless of whether they are "enabled" in the <code class="filename">keactrl.conf</code>.
      If any of the servers are not running, an informational message
      is displayed as in the <span class="command"><strong>stop</strong></span> command output below.
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl stop</code></strong>
INFO/keactrl: kea-dhcp4 isn't running.
INFO/keactrl: kea-dhcp6 isn't running.
INFO/keactrl: kea-dhcp-ddns isn't running.
INFO/keactrl: kea-ctrl-agent isn't running.
</pre><p>
      </p><p>
        As already mentioned, the reconfiguration of each Kea server is
        triggered by the SIGHUP signal. The <span class="command"><strong>reload</strong></span>
        command sends the SIGHUP signal to the servers that are enabled in
        the <span class="command"><strong>keactrl</strong></span> configuration file and are
        currently running. When a server receives the SIGHUP signal it
        re-reads its configuration file and, if the new configuration is
        valid, uses the new configuration. A reload is executed as follows:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl reload</code></strong>
INFO/keactrl: Reloading kea-dhcp4...
INFO/keactrl: Reloading kea-dhcp6...
INFO/keactrl: Reloading kea-dhcp-ddns...
INFO/keactrl: Reloading kea-ctrl-agent...
</pre><p>
      If any of the servers are not running, an informational message
      is displayed as in the <span class="command"><strong>reload</strong></span> command output below.
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl stop</code></strong>
INFO/keactrl: kea-dhcp4 isn't running.
INFO/keactrl: kea-dhcp6 isn't running.
INFO/keactrl: kea-dhcp-ddns isn't running.
INFO/keactrl: kea-ctrl-agent isn't running.
</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          Currently <span class="command"><strong>keactrl</strong></span> does not report configuration
          failures when the server is started or reconfigured. To check if
          the server's configuration succeeded the Kea log must be examined
          for errors. By default, this is written to the syslog file.
        </p></div><p>
        Sometimes it is useful to check which servers are running. The
        <span class="command"><strong>status</strong></span> reports this, typical output looking like:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl status</code></strong>
DHCPv4 server: active
DHCPv6 server: inactive
DHCP DDNS: active
Control Agent: active
Kea configuration file: /usr/local/etc/kea/kea.conf
Kea DHCPv4 configuration file: /usr/local/etc/kea/kea-dhcp4.conf
Kea DHCPv6 configuration file: /usr/local/etc/kea/kea-dhcp6.conf
Kea DHCP DDNS configuration file: /usr/local/etc/kea/kea-dhcp-ddns.conf
Kea Control Agent configuration file: /usr/local/etc/kea/kea-ctrl-agent.conf
keactrl configuration file: /usr/local/etc/kea/keactrl.conf
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="keactrl-overriding-servers"></a>6.5. Overriding the Server Selection</h2></div></div></div><p>
        The optional <span class="command"><strong>-s</strong></span> switch allows
        the selection of the servers to which <span class="command"><strong>keactrl</strong></span>
        command is issued.  For example, the following
        instructs <span class="command"><strong>keactrl</strong></span> to stop the
        <span class="command"><strong>kea-dhcp4</strong></span> and <span class="command"><strong>kea-dhcp6</strong></span> servers
        and leave the <span class="command"><strong>kea-dhcp-ddns</strong></span> and
        <span class="command"><strong>kea-ctrl-agent</strong></span> running:
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl stop -s dhcp4,dhcp6</code></strong>
</pre><p>
      </p><p>
        Similarly, the following
        will only start the <span class="command"><strong>kea-dhcp4</strong></span> and
        <span class="command"><strong>kea-dhcp-ddns</strong></span> servers and not:
        <span class="command"><strong>kea-dhcp6</strong></span>, <span class="command"><strong>kea-ctrl-agent</strong></span>.
</p><pre class="screen">
<strong class="userinput"><code>$ keactrl start -s dhcp4,dhcp_ddns</code></strong>
</pre><p>
      </p><p>
        Note that the behavior of the <span class="command"><strong>-s</strong></span> switch
        with the <span class="command"><strong>start</strong></span> and <span class="command"><strong>reload</strong></span> commands
        is different to its behavior with the <span class="command"><strong>stop</strong></span> command.
        On <span class="command"><strong>start</strong></span> and <span class="command"><strong>reload</strong></span>,
        <span class="command"><strong>keactrl</strong></span> will check if the servers given as
        parameters to the <span class="command"><strong>-s</strong></span> switch are
        enabled in the <span class="command"><strong>keactrl</strong></span> configuration file:
        if not, the server will be ignored.  For <span class="command"><strong>stop</strong></span> however,
        this check is not made: the command is applied to all listed servers,
        regardless of whether they have been enabled in the file.
      </p><p>
        The following keywords can be used with the <span class="command"><strong>-s</strong></span>
        command line option:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>dhcp4</strong></span> for <span class="command"><strong>kea-dhcp4.</strong></span>
          </li><li class="listitem">
            <span class="command"><strong>dhcp6</strong></span> for <span class="command"><strong>kea-dhcp6.</strong></span>
          </li><li class="listitem">
            <span class="command"><strong>dhcp_ddns</strong></span> for <span class="command"><strong>kea-dhcp-ddns.</strong></span>
          </li><li class="listitem">
            <span class="command"><strong>ctrl_agent</strong></span> for <span class="command"><strong>kea-ctrl-agent.</strong></span>
          </li><li class="listitem">
            <span class="command"><strong>all</strong></span> for all servers (default).
          </li></ul></div><p>
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="kea-ctrl-agent"></a>Chapter 7. Kea Control Agent</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#agent-overview">7.1. Overview</a></span></dt><dt><span class="section"><a href="#agent-configuration">7.2. Configuration</a></span></dt><dt><span class="section"><a href="#agent-secure-connection">7.3. Secure Connections</a></span></dt><dt><span class="section"><a href="#agent-limitations">7.4. Control Agent Limitations</a></span></dt><dt><span class="section"><a href="#agent-launch">7.5. Starting Control Agent</a></span></dt><dt><span class="section"><a href="#agent-clients">7.6. Connecting to the Control Agent</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-overview"></a>7.1. Overview</h2></div></div></div><p>Kea Control Agent (CA) is a daemon, first included in Kea 1.2, which
    exposes a RESTful control interface for managing Kea servers. The daemon
    can receive control commands over HTTP and either forward these commands
    to the respective Kea servers or handle these commands on its own. The
    determination whether the command should be handled by the CA or forwarded
    is made by checking the value of the 'service' parameter which may be
    included in the command from the controlling client. The details of the
    supported commands as well as their structures are provided in
    <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>.</p><p>Hook libraries can be attached to the CA to provide support for
    additional commands or custom behavior of existing commands. Such hook
    libraries must implement callouts for 'control_command_receive' hook point.
    Details about creating new hook libraries and supported hook points can be
    found in
    <a class="ulink" href="https://jenkins.isc.org/job/Kea_doc/doxygen/" target="_top">Kea Developer's Guide</a>.
    </p><p>
      The CA processes received commands according to the following algorithm:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Pass command into any installed hooks (regardless of service value(s)).
            If the command is handled by a hook, return the response.
          </li><li class="listitem">
            If the service specifies one more or services, the CA will forward the
            command to specified services and return the accumulated responses.
          </li><li class="listitem">
            If service is not specified or is an empty list, the CA will handle
            the command if it supports it.
          </li></ul></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-configuration"></a>7.2. Configuration</h2></div></div></div><p>The following example demonstrates the basic CA configuration.</p><p>
</p><pre class="screen">
{
    "Control-agent": {
        "http-host": "10.20.30.40",
        "http-port": 8080,

        "control-sockets": {
            "dhcp4": {
                "comment": "main server",
                "socket-type": "unix",
                "socket-name": "/path/to/the/unix/socket-v4"
            },
            "dhcp6": {
                "socket-type": "unix",
                "socket-name": "/path/to/the/unix/socket-v4",
                "user-context": { "version": 3 }
            }
        },

        "hooks-libraries": [
        {
            "library": "/opt/local/control-agent-commands.so",
            "parameters": {
                "param1": "foo"
            }
        } ]
    },

    "Logging": {
        "loggers": [ {
            "name": "kea-ctrl-agent",
            "severity": "INFO"
        } ]
    }
}</pre><p>
    </p><p>
      The <span class="command"><strong>http-host</strong></span> and <span class="command"><strong>http-port</strong></span>
      specify an IP address and port to which HTTP service will be bound.
      In case of the example configuration provided above, the RESTful
      service will be available under the URL of
      <span class="command"><strong>http://10.20.30.40:8080/</strong></span>. If these parameters
      are not specified, the default URL is http://127.0.0.1:8000/
    </p><p>
      It has been mentioned in the <a class="xref" href="#agent-overview" title="7.1. Overview">Section 7.1, “Overview”</a> that
      CA can forward received commands to the specific Kea servers for
      processing. For example, <span class="command"><strong>config-get</strong></span> is sent to
      retrieve configuration of one of the Kea services. When CA receives
      this command, including a <span class="command"><strong>service</strong></span> parameter
      indicating that the client desires to retrieve configuration of
      the DHCPv4 server, the CA will forward this command to this server
      and then pass the received response back to the client. More about
      the <span class="command"><strong>service</strong></span> parameter and general structure of
      the commands can be found in <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>.
    </p><p>
      The CA uses unix domain sockets to forward control commands and receive
      responses from other Kea services. The <span class="command"><strong>dhcp4</strong></span>,
      <span class="command"><strong>dhcp6</strong></span> and <span class="command"><strong>d2</strong></span> maps
      specify the files to which unix domain sockets are bound. In case
      of the configuration above, the CA will connect to the DHCPv4 server
      via <code class="filename">/path/to/the/unix/socket-v4</code> to forward the
      commands to it. Obviously, the DHCPv4 server must be configured to
      listen to connections via this same socket. In other words, the command
      socket configuration for the DHCPv4 server and CA (for this server)
      must match. Consult the <a class="xref" href="#dhcp4-ctrl-channel" title="8.9. Management API for the DHCPv4 Server">Section 8.9, “Management API for the DHCPv4 Server”</a> and the
      <a class="xref" href="#dhcp6-ctrl-channel" title="9.13. Management API for the DHCPv6 Server">Section 9.13, “Management API for the DHCPv6 Server”</a> to learn how the socket
      configuration is specified for the DHCPv4 and DHCPv6 services.
    </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
        We have renamed "dhcp4-server", "dhcp6-server" and "d2-server"
        to "dhcp4", "dhcp6" and "d2" respectively after release of Kea 1.2.
        If you are migrating from Kea 1.2 you need to tweak your CA config
        to use this new naming convention. We have made this incompatible
        change to facilitate future use cases where it will be possible to
        specify additional values of the "service" parameter to point to
        the particular instances of the Kea servers, e.g. "dhcp4/3"
        pointing to the 3rd instance of the DHCPv4 server in the
        multi-processed configuration. This is not yet supported but the
        current renaming lays the ground for it.
      </p></div><p>
      User contexts can store arbitrary data as long as it is valid JSON
      syntax and its top level element is a map (i.e. the data must be
      enclosed in curly brackets). Some hook libraries may expect specific
      formatting, though.  Please consult specific hook library
      documentation for details.
    </p><p>
      User contexts can be specified on either global scope, control
      socket and loggers. One other useful usage is the ability to
      store comments or descriptions: the parser translates a
      "comment" entry into a user-context with the entry, this allows
      to attach a comment inside the configuration itself.
    </p><p>
      Hooks libraries can be attached to the Control Agent just like to
      DHCPv4 and DHCPv6 servers. It currently supports one hook point
      'control_command_receive' which makes it possible to delegate
      processing of some commands to the hooks library. The
      <span class="command"><strong>hooks-libraries</strong></span> list contains the list of hooks
      libraries that should be loaded by the CA, along with their configuration
      information specified with <span class="command"><strong>parameters</strong></span>.
    </p><p>
      Please consult <a class="xref" href="#logging" title="Chapter 18. Logging">Chapter 18, <i>Logging</i></a> for the details how to
      configure logging. The CA's root logger's name is
      <span class="command"><strong>kea-ctrl-agent</strong></span> as given in the example above.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-secure-connection"></a>7.3. Secure Connections</h2></div></div></div><p>
      Control Agent doesn't natively support secure HTTP connections like
      SSL or TLS. In order to setup secure connection please use one
      of the available third party HTTP servers and configure it to run
      as a reverse proxy to the Control Agent. Kea has been tested with
      two major HTTP server implentations working as a reverse proxy:
      Apache2 and nginx. Example configurations including extensive
      comments are provided in the <code class="filename">doc/examples/https/</code>
      directory.
    </p><p>
      The reverse proxy forwards HTTP requests received over secure
      connection to the Control Agent using (not secured) HTTP. Typically,
      the reverse proxy and the Control Agent are running on the same machine,
      but it is possible to configure them to run on separate machines as
      well. In this case, security depends on the protection of the
      communications between the reverse proxy and the Control Agent.
    </p><p>Apart from providing the encryption layer for the control channel,
    a reverse proxy server is also often used for authentication of the
    controlling clients. In this case, the client must present a valid
    certificate when it connects via reverse proxy. The proxy server
    authenticates the client by checking if the presented certificate is
    signed by the certificate authority used by the server.</p><p>To illustrate this, we provide a sample configuration for the
    nginx server running as a reverse proxy to the Kea Control Agent.
    The server enables authentication of the clients using
    certificates.</p><pre class="screen">
#   The server certificate and key can be generated as follows:
#
#   openssl genrsa -des3 -out kea-proxy.key 4096
#   openssl req -new -x509 -days 365 -key kea-proxy.key -out kea-proxy.crt
#
#   The CA certificate and key can be generated as follows:
#
#   openssl genrsa -des3 -out ca.key 4096
#   openssl req -new -x509 -days 365 -key ca.key -out ca.crt
#
#
#   The client certificate needs to be generated and signed:
#
#   openssl genrsa -des3 -out kea-client.key 4096
#   openssl req -new -key kea-client.key -out kea-client.csr
#   openssl x509 -req -days 365 -in kea-client.csr -CA ca.crt \
#           -CAkey ca.key -set_serial 01 -out kea-client.crt
#
#   Note that the 'common name' value used when generating the client
#   and the server certificates must differ from the value used
#   for the CA certificate.
#
#   The client certificate must be deployed on the client system.
#   In order to test the proxy configuration with 'curl' run
#   command similar to the following:
#
#   curl -k --key kea-client.key --cert kea-client.crt -X POST \
#        -H Content-Type:application/json -d '{ "command": "list-commands" }' \
#         https://kea.example.org/kea
#
#
#
#   nginx configuration starts here.

events {
}

http {
        #   HTTPS server
    server {
        #     Use default HTTPS port.
        listen 443 ssl;
        #     Set server name.
        server_name kea.example.org;

        #   Server certificate and key.
        ssl_certificate /path/to/kea-proxy.crt;
        ssl_certificate_key /path/to/kea-proxy.key;

        #   Certificate Authority. Client certificate must be signed by the CA.
        ssl_client_certificate /path/to/ca.crt;

        # Enable verification of the client certificate.
        ssl_verify_client on;

        # For URLs such as https://kea.example.org/kea, forward the
        # requests to http://127.0.0.1:8080.
        location /kea {
            proxy_pass http://127.0.0.1:8080;
        }
    }
}
</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Note that the configuration snippet provided above is for testing
    purposes only. Consult security policies and best practices of your
    organization which apply to this setup.</p></div><p>When you use an HTTP client without TLS support as <span class="command"><strong>
    kea-shell</strong></span> you can use an HTTP/HTTPS translator such as stunnel
    in client mode. A sample configuration is provided in the
    <code class="filename">doc/examples/https/shell/</code> directory</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-limitations"></a>7.4. Control Agent Limitations</h2></div></div></div><p>
      Control Agent is a new component, first released in Kea 1.2. In
      this release it comes with one notable limitation:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            keactrl hasn't been updated to manage the Control Agent (start, stop
            reload). As a result, the CA must be started directly as described in
            <a class="xref" href="#agent-launch" title="7.5. Starting Control Agent">Section 7.5, “Starting Control Agent”</a>
          </li></ul></div><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-launch"></a>7.5. Starting Control Agent</h2></div></div></div><p>
      The CA is started by running its binary and specifying the configuration file
      it should use. For example:
</p><pre class="screen">
$ ./kea-ctrl-agent -c /usr/local/etc/kea/kea-ctrl-agent.conf
</pre><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-clients"></a>7.6. Connecting to the Control Agent</h2></div></div></div><p>For an example of tool that can take advantage of the
    RESTful API, see <a class="xref" href="#kea-shell" title="Chapter 19. The Kea Shell">Chapter 19, <i>The Kea Shell</i></a>.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="dhcp4"></a>Chapter 8. The DHCPv4 Server</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#dhcp4-start-stop">8.1. Starting and Stopping the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-configuration">8.2. DHCPv4 Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp56251344">8.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp56251600">8.2.2. Lease Storage</a></span></dt><dt><span class="section"><a href="#hosts4-storage">8.2.3. Hosts Storage</a></span></dt><dt><span class="section"><a href="#dhcp4-interface-configuration">8.2.4. Interface Configuration</a></span></dt><dt><span class="section"><a href="#dhcpinform-unicast-issues">8.2.5. Issues with Unicast Responses to DHCPINFORM</a></span></dt><dt><span class="section"><a href="#ipv4-subnet-id">8.2.6. IPv4 Subnet Identifier</a></span></dt><dt><span class="section"><a href="#dhcp4-address-config">8.2.7. Configuration of IPv4 Address Pools</a></span></dt><dt><span class="section"><a href="#dhcp4-std-options">8.2.8. Standard DHCPv4 Options</a></span></dt><dt><span class="section"><a href="#dhcp4-custom-options">8.2.9. Custom DHCPv4 options</a></span></dt><dt><span class="section"><a href="#dhcp4-private-opts">8.2.10. DHCPv4 Private Options</a></span></dt><dt><span class="section"><a href="#dhcp4-vendor-opts">8.2.11. DHCPv4 Vendor Specific Options</a></span></dt><dt><span class="section"><a href="#dhcp4-option-spaces">8.2.12. Nested DHCPv4 Options (Custom Option Spaces)</a></span></dt><dt><span class="section"><a href="#dhcp4-option-data-defaults">8.2.13. Unspecified Parameters for DHCPv4 Option Configuration</a></span></dt><dt><span class="section"><a href="#dhcp4-stateless-configuration">8.2.14. Stateless Configuration of DHCPv4 Clients</a></span></dt><dt><span class="section"><a href="#dhcp4-client-classifier">8.2.15. Client Classification in DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-ddns-config">8.2.16. DDNS for DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-next-server">8.2.17. Next Server (siaddr)</a></span></dt><dt><span class="section"><a href="#dhcp4-echo-client-id">8.2.18. Echoing Client-ID (RFC 6842)</a></span></dt><dt><span class="section"><a href="#dhcp4-match-client-id">8.2.19. Using Client Identifier and Hardware Address</a></span></dt><dt><span class="section"><a href="#dhcp4-dhcp4o6-config">8.2.20. DHCPv4-over-DHCPv6: DHCPv4 Side</a></span></dt></dl></dd><dt><span class="section"><a href="#host-reservation-v4">8.3. Host Reservation in DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#reservation4-types">8.3.1. Address Reservation Types</a></span></dt><dt><span class="section"><a href="#reservation4-conflict">8.3.2. Conflicts in DHCPv4 Reservations</a></span></dt><dt><span class="section"><a href="#reservation4-hostname">8.3.3. Reserving a Hostname</a></span></dt><dt><span class="section"><a href="#reservation4-options">8.3.4. Including Specific DHCPv4 Options in Reservations</a></span></dt><dt><span class="section"><a href="#reservation4-message-fields">8.3.5. Reserving Next Server, Server Hostname and Boot File Name</a></span></dt><dt><span class="section"><a href="#reservation4-client-classes">8.3.6. Reserving Client Classes in DHCPv4</a></span></dt><dt><span class="section"><a href="#reservations4-mysql-pgsql-cql">8.3.7. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</a></span></dt><dt><span class="section"><a href="#reservations4-tuning">8.3.8. Fine Tuning DHCPv4 Host Reservation</a></span></dt></dl></dd><dt><span class="section"><a href="#shared-network4">8.4. Shared networks in DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#idp56996800">8.4.1. Local and relayed traffic in shared networks</a></span></dt><dt><span class="section"><a href="#idp57004464">8.4.2. Client classification in shared networks</a></span></dt><dt><span class="section"><a href="#idp57014272">8.4.3. Host reservations in shared networks</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp4-serverid">8.5. Server Identifier in DHCPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-subnet-selection">8.6. How the DHCPv4 Server Selects a Subnet for the Client</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp4-relay-override">8.6.1. Using a Specific Relay Agent for a Subnet</a></span></dt><dt><span class="section"><a href="#dhcp4-srv-example-client-class-relay">8.6.2. Segregating IPv4 Clients in a Cable Network</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp4-decline">8.7. Duplicate Addresses (DHCPDECLINE Support)</a></span></dt><dt><span class="section"><a href="#dhcp4-stats">8.8. Statistics in the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-ctrl-channel">8.9. Management API for the DHCPv4 Server</a></span></dt><dt><span class="section"><a href="#dhcp4-std">8.10. Supported DHCP Standards</a></span></dt><dt><span class="section"><a href="#dhcp4-user-contexts">8.11. User contexts in IPv4</a></span></dt><dt><span class="section"><a href="#dhcp4-limit">8.12. DHCPv4 Server Limitations</a></span></dt><dt><span class="section"><a href="#dhcp4-srv-examples">8.13. Kea DHCPv4 server examples</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-start-stop"></a>8.1. Starting and Stopping the DHCPv4 Server</h2></div></div></div><p>
        It is recommended that the Kea DHCPv4 server be started and stopped
        using <span class="command"><strong>keactrl</strong></span> (described in <a class="xref" href="#keactrl" title="Chapter 6. Managing Kea with keactrl">Chapter 6, <i>Managing Kea with keactrl</i></a>).
        However, it is also possible to run the server directly: it accepts
        the following command-line switches:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>-c <em class="replaceable"><code>file</code></em></strong></span> -
            specifies the configuration file. This is the only mandatory
            switch.</li><li class="listitem">
            <span class="command"><strong>-d</strong></span> - specifies whether the server
            logging should be switched to debug/verbose mode. In verbose mode,
            the logging severity and debuglevel specified in the configuration
            file are ignored and "debug" severity and the maximum debuglevel
            (99) are assumed. The flag is convenient, for temporarily
            switching the server into maximum verbosity, e.g. when
            debugging.</li><li class="listitem">
            <span class="command"><strong>-p <em class="replaceable"><code>port</code></em></strong></span> -
            specifies UDP port on which the server will listen. This is only
            useful during testing, as a DHCPv4 server listening on
            ports other than the standard ones will not be able to
            handle regular DHCPv4 queries.</li><li class="listitem">
            <span class="command"><strong>-t <em class="replaceable"><code>file</code></em></strong></span> -
            specifies the configuration file to be tested. Kea-dhcp4
            will attempt to load it, and will conduct sanity
            checks. Note that certain checks are possible only while
            running the actual server. The actual status is reported
            with exit code (0 = configuration looks ok, 1 = error
            encountered). Kea will print out log messages to standard
            output and error to standard error when testing
            configuration.</li><li class="listitem">
              <span class="command"><strong>-v</strong></span> - prints out the Kea version and exits.
            </li><li class="listitem">
              <span class="command"><strong>-V</strong></span> - prints out the Kea extended version with
              additional parameters and exits. The listing includes the versions
              of the libraries dynamically linked to Kea.
            </li><li class="listitem">
              <span class="command"><strong>-W</strong></span> - prints out the Kea configuration report
              and exits. The report is a copy of the
              <code class="filename">config.report</code> file produced by
              <strong class="userinput"><code>./configure</code></strong>: it is embedded in the
              executable binary.
            </li></ul></div><p>
        The <code class="filename">config.report</code> may also be accessed more
        directly.  The following command may be used to extract this
        information.  The binary <strong class="userinput"><code>path</code></strong> may be found
        in the install directory or in the <code class="filename">.libs</code>
        subdirectory in the source tree. For example
        <code class="filename">kea/src/bin/dhcp4/.libs/kea-dhcp4</code>.

</p><pre class="screen">
strings <strong class="userinput"><code>path</code></strong>/kea-dhcp4 | sed -n 's/;;;; //p'
</pre><p>
      </p><p>
        On start-up, the server will detect available network interfaces
        and will attempt to open UDP sockets on all interfaces
        mentioned in the configuration file.
        Since the DHCPv4 server opens privileged ports, it requires root
        access. Make sure you run this daemon as root.
      </p><p>
        During startup the server will attempt to create a PID file of the
        form: localstatedir]/[conf name].kea-dhcp6.pid where:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>localstatedir</strong></span>: The value as passed into the
            build configure script. It defaults to "/usr/local/var".  (Note
            that this value may be overridden at run time by setting the environment
            variable KEA_PIDFILE_DIR.  This is intended primarily for testing purposes.)
            </li><li class="listitem"><span class="command"><strong>conf name</strong></span>: The configuration file name
            used to start the server, minus all preceding path and file extension.
            For example, given a pathname of "/usr/local/etc/kea/myconf.txt", the
            portion used would be "myconf".
            </li></ul></div><p>
        If the file already exists and contains the PID of a live process,
        the server will issue a DHCP4_ALREADY_RUNNING log message and exit. It
        is possible, though unlikely, that the file is a remnant of a system crash
        and the process to which the PID belongs is unrelated to Kea.  In such a
        case it would be necessary to manually delete the PID file.
      </p><p>
        The server can be stopped using the <span class="command"><strong>kill</strong></span> command.
        When running in a console, the server can also be shut down by
        pressing ctrl-c. It detects the key combination and shuts
        down gracefully.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-configuration"></a>8.2. DHCPv4 Server Configuration</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56251344"></a>8.2.1. Introduction</h3></div></div></div><p>
        This section explains how to configure the DHCPv4 server using the
        Kea configuration backend. (Kea configuration using any other
        backends is outside of scope of this document.) Before DHCPv4
        is started, its configuration file has to be created. The
        basic configuration is as follows:
</p><pre class="screen">
{
# DHCPv4 configuration starts in this line
"Dhcp4": {

# First we set up global values
    "valid-lifetime": 4000,
    "renew-timer": 1000,
    "rebind-timer": 2000,

# Next we setup the interfaces to be used by the server.
    "interfaces-config": {
        "interfaces": [ "eth0" ]
    },

# And we specify the type of lease database
    "lease-database": {
        "type": "memfile",
        "persist": true,
        "name": "/var/kea/dhcp4.leases"
    },

# Finally, we list the subnets from which we will be leasing addresses.
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [
                {
                     "pool": "192.0.2.1 - 192.0.2.200"
                }
            ]
        }
    ]
# DHCPv4 configuration ends with the next line
}

} </pre><p>
</p><p>The following paragraphs provide a brief overview of the parameters in
the above example together with
their format. Subsequent sections of this chapter go into much greater detail
for these and other parameters.</p><p>The lines starting with a hash (#) are comments and are ignored by
the server; they do not impact its
operation in any way.</p><p>The configuration starts in the first line with the initial
opening curly bracket (or brace). Each configuration consists of
one or more objects. In this specific example, we have only one
object, called Dhcp4. This is a simplified configuration, as usually
there will be additional objects, like <span class="command"><strong>Logging</strong></span> or
<span class="command"><strong>DhcpDdns</strong></span>, but we omit them now for clarity. The Dhcp4
configuration starts with the <span class="command"><strong>"Dhcp4": {</strong></span> line
and ends with the corresponding closing brace (in the above example,
the brace after the last comment).  Everything defined between those
lines is considered to be the Dhcp4 configuration.</p><p>In the general case, the order in which those parameters appear does not
matter. There are two caveats here though. The first one is to remember that
the configuration file must be well formed JSON. That means that the parameters
for any given scope must be separated by a comma and there must not be a comma
after the last parameter. When reordering a configuration file, keep in mind that
moving a parameter to or from the last position in a given scope may also require
moving the comma. The second caveat is that it is uncommon — although
legal JSON — to
repeat the same parameter multiple times. If that happens, the last occurrence of a
given parameter in a given scope is used while all previous instances are
ignored. This is unlikely to cause any confusion as there are no real life
reasons to keep multiple copies of the same parameter in your configuration
file.</p><p>Moving onto the DHCPv4 configuration elements, the first few elements
define some global parameters. <span class="command"><strong>valid-lifetime</strong></span>
defines for how long the addresses (leases) given out by the
server are valid. If nothing changes, a client that got an address is allowed to
use it for 4000 seconds. (Note that integer numbers are specified as is,
without any quotes around them.) <span class="command"><strong>renew-timer</strong></span> and
<span class="command"><strong>rebind-timer</strong></span> are values (also in seconds) that
define T1 and T2 timers that govern when the client will begin the renewal and
rebind procedures. Note that <span class="command"><strong>renew-timer</strong></span> and
<span class="command"><strong>rebind-timer</strong></span> are optional. If they are not specified the
client will select values for T1 and T2 timers according to the
<a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>.</p><p>The <span class="command"><strong>interfaces-config</strong></span> map specifies the server
configuration concerning the network interfaces, on which the server should
listen to the DHCP messages. The <span class="command"><strong>interfaces</strong></span> parameter
specifies a list of network interfaces on which the server should listen.
Lists are opened and closed with square brackets, with elements separated
by commas. Had we wanted to listen on two interfaces, the
<span class="command"><strong>interfaces-config</strong></span> would look like this:
</p><pre class="screen">
"interfaces-config": {
    "interfaces": [ "eth0", "eth1" ]
},
</pre><p>
</p><p>The next couple of lines define the lease database, the place where the server
stores its lease information. This particular example tells the server to use
<span class="command"><strong>memfile</strong></span>, which is the simplest (and fastest) database
backend. It uses an in-memory database and stores leases on disk in a CSV
file. This is a very simple configuration. Usually the lease database configuration
is more extensive and contains additional parameters.  Note that
<span class="command"><strong>lease-database</strong></span>
is an object and opens up a new scope, using an opening brace.
Its parameters (just one in this example - <span class="command"><strong>type</strong></span>)
follow. Had there been more than one, they would be separated by commas. This
scope is closed with a closing brace. As more parameters for the Dhcp4 definition
follow, a trailing comma is present.</p><p>Finally, we need to define a list of IPv4 subnets. This is the
most important DHCPv4 configuration structure as the server uses that
information to process clients' requests. It defines all subnets from
which the server is expected to receive DHCP requests. The subnets are
specified with the <span class="command"><strong>subnet4</strong></span> parameter.  It is a list,
so it starts and ends with square brackets.  Each subnet definition in
the list has several attributes associated with it, so it is a structure
and is opened and closed with braces. At a minimum, a subnet definition
has to have at least two parameters: <span class="command"><strong>subnet</strong></span> (that
defines the whole subnet) and <span class="command"><strong>pools</strong></span> (which is a list of
dynamically allocated pools that are governed by the DHCP server).</p><p>The example contains a single subnet. Had more than one been defined,
additional elements
in the <span class="command"><strong>subnet4</strong></span> parameter would be specified and
separated by commas. For example, to define three subnets, the following
syntax would be used:
</p><pre class="screen">
"subnet4": [
    {
        "pools": [ { "pool":  "192.0.2.1 - 192.0.2.200" } ],
        "subnet": "192.0.2.0/24"
    },
    {
        "pools": [ { "pool": "192.0.3.100 - 192.0.3.200" } ],
        "subnet": "192.0.3.0/24"
    },
    {
        "pools": [ { "pool": "192.0.4.1 - 192.0.4.254" } ],
        "subnet": "192.0.4.0/24"
    }
]
</pre><p>
Note that indentation is optional and is used for aesthetic purposes only.
In some cases in may be preferable to use more compact notation.
</p><p>After all the parameters have been specified, we have two contexts open:
global and Dhcp4, hence we need two closing curly brackets to close them.
In a real life configuration file there most likely would be additional
components defined such as Logging or DhcpDdns, so the closing brace would
be followed by a comma and another object definition.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56251600"></a>8.2.2. Lease Storage</h3></div></div></div><p>All leases issued by the server are stored in the lease database.
  Currently there are four database backends available:  memfile (which is the
  default backend), MySQL, PostgreSQL and Cassandra.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56274608"></a>8.2.2.1. Memfile - Basic Storage for Leases</h4></div></div></div><p>The server is able to store lease data in different repositories. Larger
  deployments may elect to store leases in a database. <a class="xref" href="#database-configuration4" title="8.2.2.2. Lease Database Configuration">Section 8.2.2.2, “Lease Database Configuration”</a> describes this option. In typical
  smaller deployments though, the server will store lease information in a CSV file rather
  than a database. As well as requiring less administration, an
  advantage of using a file for storage is that it
  eliminates a dependency on third-party database software.</p><p>The configuration of the file backend (Memfile) is controlled through
  the Dhcp4/lease-database parameters. The <span class="command"><strong>type</strong></span> parameter
  is mandatory and it specifies which storage for leases the server should use.
  The value of <strong class="userinput"><code>"memfile"</code></strong> indicates that the file should
  be used as the storage. The following list gives additional, optional,
  parameters that can be used to configure the Memfile backend.

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>persist</strong></span>: controls whether the new leases and
      updates to existing leases are written to the file. It is strongly
      recommended that the value of this parameter is set to
      <strong class="userinput"><code>true</code></strong> at all times, during the server's normal
      operation. Not writing leases to disk will mean that if a server is restarted
      (e.g. after a power failure), it will not know what addresses have been
      assigned.  As a result, it may hand out addresses to new clients that are
      already in use. The value of <strong class="userinput"><code>false</code></strong> is mostly useful
      for performance testing purposes. The default value of the
      <span class="command"><strong>persist</strong></span> parameter is <strong class="userinput"><code>true</code></strong>,
      which enables writing lease updates
      to the lease file.
      </li><li class="listitem"><span class="command"><strong>name</strong></span>: specifies an absolute location of the lease
      file in which new leases and lease updates will be recorded. The default value
      for this parameter is <strong class="userinput"><code>"[kea-install-dir]/var/kea/kea-leases4.csv"
      </code></strong>.</li><li class="listitem"><span class="command"><strong>lfc-interval</strong></span>: specifies the interval in seconds, at
      which the server will perform a lease file cleanup (LFC).  This
      removes redundant (historical) information from the lease file
      and effectively reduces the lease file size. The cleanup process is described
      in more detailed fashion further in this section. The default value of the
      <span class="command"><strong>lfc-interval</strong></span> is <strong class="userinput"><code>3600</code></strong>. A value of 0
      disables the LFC.</li></ul></div><p>
  </p><p>An example configuration of the Memfile backend is presented below:

</p><pre class="screen">
"Dhcp4": {
    "lease-database": {
        <strong class="userinput"><code>"type": "memfile"</code></strong>,
        <strong class="userinput"><code>"persist": true</code></strong>,
        <strong class="userinput"><code>"name": "/tmp/kea-leases4.csv",</code></strong>
        <strong class="userinput"><code>"lfc-interval": 1800</code></strong>
    }
}
</pre><p>

    This configuration selects the <code class="filename">/tmp/kea-leases4.csv</code> as
    the storage for lease information and enables persistence (writing lease updates
    to this file). It also configures the backend perform the periodic cleanup
    of the lease files, executed every 30 minutes.
  </p><p>It is important to know how the lease file contents are organized
  to understand why the periodic lease file cleanup is needed. Every time
  the server updates a lease or creates a new lease for the client, the new
  lease information must be recorded in the lease file. For performance reasons,
  the server does not update the existing client's lease in the file, as it would
  potentially require rewriting the entire file. Instead, it simply appends the new lease
  information to the end of the file: the previous lease entries for the
  client are not removed. When the server loads leases from the lease file, e.g.
  at the server startup, it assumes that the latest lease entry for the client
  is the valid one. The previous entries are discarded. This means that the
  server can re-construct the accurate information about the leases even though
  there may be many lease entries for each client. However, storing many entries
  for each client results in bloated lease file and impairs the performance of
  the server's startup and reconfiguration as it needs to process a larger number
  of lease entries.
  </p><p>Lease file cleanup (LFC) removes all previous entries for each client and
  leaves only the latest ones. The interval at which the cleanup is performed
  is configurable, and it should be selected according to the frequency of lease
  renewals initiated by the clients. The more frequent the renewals, the smaller
  the value of <span class="command"><strong>lfc-interval</strong></span> should be. Note however, that the
  LFC takes time and thus it is possible (although unlikely) that new cleanup
  is started while the previous cleanup instance is still running, if the
  <span class="command"><strong>lfc-interval</strong></span> is too short. The server would recover from
  this by skipping the new cleanup when it detects that the previous cleanup
  is still in progress. But it implies that the actual cleanups will be
  triggered more rarely than configured. Moreover, triggering a new cleanup
  adds an overhead to the server which will not be able to respond to new
  requests for a short period of time when the new cleanup process is spawned.
  Therefore, it is recommended that the <span class="command"><strong>lfc-interval</strong></span> value
  is selected in a way that would allow for the LFC to complete the cleanup before a
  new cleanup is triggered.
  </p><p>Lease file cleanup is performed by a separate process (in background) to avoid
  a performance impact on the server process. In order to avoid the conflicts
  between two processes both using the same lease files, the LFC process
  operates on the copy of the original lease file, rather than on the lease
  file used by the server to record lease updates. There are also other files
  being created as a side effect of the lease file cleanup. The detailed
  description of the LFC is located on the Kea wiki:
  <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/LFCDesign" target="_top">http://kea.isc.org/wiki/LFCDesign</a></code>.
  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="database-configuration4"></a>8.2.2.2. Lease Database Configuration</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Lease database access information must be configured for the DHCPv4 server,
    even if it has already been configured for the DHCPv6 server. The servers
    store their information independently, so each server can use a separate
    database or both servers can use the same database.</p></div><p>Lease database configuration is controlled through the Dhcp4/lease-database
  parameters. The type of the database must be set to "memfile", "mysql", "postgresql" or
  "cql", e.g.
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... }
</pre><p>
  Next, the name of the database to hold the leases must be set: this is the
  name used when the database was created
  (see <a class="xref" href="#mysql-database-create" title="4.3.2.1. First Time Creation of the MySQL Database">Section 4.3.2.1, “First Time Creation of the MySQL Database”</a>,
  <a class="xref" href="#pgsql-database-create" title="4.3.3.1. First Time Creation of the PostgreSQL Database">Section 4.3.3.1, “First Time Creation of the PostgreSQL Database”</a> or
  <a class="xref" href="#cql-database-create" title="4.3.4.1. First Time Creation of the Cassandra Database">Section 4.3.4.1, “First Time Creation of the Cassandra Database”</a>).
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"name": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  For Cassandra:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"keyspace": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  If the database is located on a different system to the DHCPv4 server, the
  database host name must also be specified. (It should be noted that this
  configuration may have a severe impact on server performance.):
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"host": "<em class="replaceable"><code>remote-host-name</code></em>"</code></strong>, ... }, ... }
</pre><p>

  The usual state of affairs will be to have the database on the same machine as
  the DHCPv4 server.  In this case, set the value to the empty string:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"host" : ""</code></strong>, ... }, ... }
</pre><p>

  Should the database use a port different than default, it may be
  specified as well:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"port" : 12345</code></strong>, ... }, ... }
</pre><p>
  Should the database be located on a different system, you may need to specify a longer interval
  for the connection timeout:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"connect-timeout" : <em class="replaceable"><code>timeout-in-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
The default value of five seconds should be more than adequate for local connections.
If a timeout is given though, it should be an integer greater than zero.
  </p><p>
The maxiumum number of times the server will automatically attempt to reconnect to
the lease database after connectivity has been lost may be specified:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"max-reconnect-tries" : <em class="replaceable"><code>number-of-tries</code></em></code></strong>, ... }, ... }
</pre><p>
If the server is unable to reconnect to the database after making the maximum number
of attempts the server will exit. A value of zero (the default) disables automatic
recovery and the server will exit immediately upon detecting a loss of connectivity
(MySQL and Postgres only).
  </p><p>
The number of seconds the server will wait in between attempts to reconnect to the
lease database after connectivity has been lost may also be specified:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"reconnect-wait-time" : <em class="replaceable"><code>number-of-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
A value of zero (the default) disables automatic recovery and the server will exit
immediately upon detecting a loss of connectivity (MySQL and Postgres only).
    </p><p>Finally, the credentials of the account under which the server will
  access the database should be set:
</p><pre class="screen">
"Dhcp4": { "lease-database": { <strong class="userinput"><code>"user": "<em class="replaceable"><code>user-name</code></em>"</code></strong>,
                               <strong class="userinput"><code>"password": "<em class="replaceable"><code>password</code></em>"</code></strong>,
                              ... },
           ... }
</pre><p>
  If there is no password to the account, set the password to the empty string
  "". (This is also the default.)</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cassandra-database-configuration4"></a>8.2.2.3. Cassandra specific parameters</h4></div></div></div><p>
    Cassandra backend is configured slightly differently. Cassandra has a
    concept of contact points that could be used to contact the cluster,
    instead of a single IP or hostname. It takes a list of comma separated IP
    addresses. This may be specified as:
    </p><pre class="screen">
"Dhcp4": {
    "lease-database": {
        "type": "cql",
        <strong class="userinput"><code>"contact-points": "<em class="replaceable"><code>ip-address1, ip-address2 [,...]</code></em>"</code></strong>,
        ...
    },
    ...
}</pre><p>
  </p><p>
    Cassandra also supports a number of optional parameters:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
        <span class="command"><strong>reconnect-wait-time</strong></span> - governs how long Kea waits
        before attempting to reconnect. Expressed in milliseconds. The default
        is 2000 [ms].
      </li><li class="listitem">
        <span class="command"><strong>connect-timeout</strong></span> - sets the timeout for connecting to
        a node. Expressed in milliseconds. The default is 5000 [ms].
      </li><li class="listitem">
        <span class="command"><strong>request-timeout</strong></span> - this parameter sets the timeout for
        waiting for a response from a node. Expressed in milliseconds. The
        default is 12000 [ms].
      </li><li class="listitem">
        <span class="command"><strong>tcp-keepalive</strong></span> - This parameter governs the TCP
        keep-alive mechanism. Expressed in seconds of delay. If the parameter
        is not present, the mechanism is disabled.
      </li><li class="listitem">
        <span class="command"><strong>tcp-nodelay</strong></span> - This parameter enables/disabled Nagle's
        algorithm on connections. The default is true.
      </li></ul></div><p>
  </p><p>
    For example, a complex Cassandra configuration with most parameters specified
    could look as follows:
</p><pre class="screen">
"Dhcp4": {
  "lease-database": {
      "type": "cql",
      "keyspace": "keatest",
      "contact-points": "192.0.2.1, 192.0.2.2, 192.0.2.3",
      "port": 9042,
      "reconnect-wait-time": 2000,
      "connect-timeout": 5000,
      "request-timeout": 12000,
      "tcp-keepalive": 1,
      "tcp-nodelay": true
    },
    ...
}</pre><p>

Similar parameters can be specified for hosts database.
  </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hosts4-storage"></a>8.2.3. Hosts Storage</h3></div></div></div><p>Kea is also able to store information about host reservations in the
    database. The hosts database configuration uses the same syntax as the lease
    database. In fact, a Kea server opens independent connections for each
    purpose, be it lease or hosts information. This arrangement gives the most
    flexibility. Kea can be used to keep leases and host reservations
    separately, but can also point to the same database. Currently the
    supported hosts database types are MySQL, PostgreSQL and Cassandra.</p><p>Please note that usage of hosts storage is optional. A user can define
    all host reservations in the configuration file. That is the recommended way
    if the number of reservations is small. However, when the number of
    reservations grows it's more convenient to use host storage. Please note
    that both storage methods (configuration file and one of the supported databases)
    can be used together. If hosts are defined in both places, the definitions
    from the configuration file are checked first and external storage is checked
    later, if necessary.</p><p>Version 1.4 extends the host storage to multiple storages. Operations
    are performed on host storages in the configuration order with a special
    case for addition: read-only storages must be configured after a
    required read-write storage, or host reservation addition will
    always fail.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hosts-databases-configuration4"></a>8.2.3.1. DHCPv4 Hosts Database Configuration</h4></div></div></div><p>Hosts database configuration is controlled through the Dhcp4/hosts-database
  parameters. If enabled, the type of the database must be set to "mysql" or
  "postgresql". Other hosts backends may be added in later versions of Kea.
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... }
</pre><p>
  Next, the name of the database to hold the reservations must be set: this is the
  name used when the lease database was created (see <a class="xref" href="#supported-databases" title="4.3. Supported Databases">Section 4.3, “Supported Databases”</a>
  for instructions how to setup the desired database type).
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"name": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  If the database is located on a different system than the DHCPv4 server, the
  database host name must also be specified. (Again it should be noted that this
  configuration may have a severe impact on server performance.):
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"host": <em class="replaceable"><code>remote-host-name</code></em></code></strong>, ... }, ... }
</pre><p>
  The usual state of affairs will be to have the database on the same machine as
  the DHCPv4 server.  In this case, set the value to the empty string:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"host" : ""</code></strong>, ... }, ... }
</pre><p>
  Should the database use a port different than default, it may be
  specified as well:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"port" : 12345</code></strong>, ... }, ... }
</pre><p>
  </p><p>
The maxiumum number of times the server will automatically attempt to reconnect to
the host database after connectivity has been lost may be specified:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"max-reconnect-tries" : <em class="replaceable"><code>number-of-tries</code></em></code></strong>, ... }, ... }
</pre><p>
If the server is unable to reconnect to the database after making the maximum number
of attempts the server will exit. A value of zero (the default) disables automatic
recovery and the server will exit immediately upon detecting a loss of connectivity
(MySQL and Postgres only).
  </p><p>
  </p><p>
The number of seconds the server will wait in between attempts to reconnect to the
host database after connectivity has been lost may also be specified:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"reconnect-wait-time" : <em class="replaceable"><code>number-of-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
A value of zero (the default) disables automatic recovery and the server will exit
immediately upon detecting a loss of connectivity (MySQL and Postgres only).
    </p><p>

  </p><p>Finally, the credentials of the account under which the server will
  access the database should be set:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"user": "<em class="replaceable"><code>user-name</code></em>"</code></strong>,
                               <strong class="userinput"><code>"password": "<em class="replaceable"><code>password</code></em>"</code></strong>,
                              ... },
           ... }
</pre><p>
  If there is no password to the account, set the password to the empty string
  "". (This is also the default.)</p><p>The multiple storage extension uses a similar syntax: a configuration
  is placed into a "hosts-databases" list instead of into a "hosts-database"
  entry as in:
</p><pre class="screen">
"Dhcp4": { "hosts-databases": [ { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... ], ... }
</pre><p>
  </p><p>For additional Cassandra specific parameters, see <a class="xref" href="#cassandra-database-configuration4" title="8.2.2.3. Cassandra specific parameters">Section 8.2.2.3, “Cassandra specific parameters”</a>.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="read-only-database-configuration4"></a>8.2.3.2. Using Read-Only Databases for Host Reservations</h4></div></div></div><p>
In some deployments the database user whose name is specified in the database backend
configuration may not have write privileges to the database. This is often
required by the policy within a given network to secure the data from being
unintentionally modified. In many cases administrators have inventory databases
deployed, which contain substantially more information about the hosts than
static reservations assigned to them. The inventory database can be used to create
a view of a Kea hosts database and such view is often read only.
</p><p>
Kea host database backends operate with an implicit configuration to both
read from and write to the database. If the database user does not have
write access to the host database, the backend will fail to start and the
server will refuse to start (or reconfigure). However, if access to a read
only host database is required for retrieving reservations for clients
and/or assign specific addresses and options, it is possible to explicitly
configure Kea to start in "read-only" mode. This is controlled by the
<span class="command"><strong>readonly</strong></span> boolean parameter as follows:
</p><pre class="screen">
"Dhcp4": { "hosts-database": { <strong class="userinput"><code>"readonly": true</code></strong>, ... }, ... }
</pre><p>
Setting this parameter to <strong class="userinput"><code>false</code></strong> would configure the
database backend to operate in "read-write" mode, which is also a default
configuration if the parameter is not specified.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="command"><strong>readonly</strong></span> parameter is currently only supported
for MySQL and PostgreSQL databases.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-interface-configuration"></a>8.2.4. Interface Configuration</h3></div></div></div><p>The DHCPv4 server has to be configured to listen on specific network
  interfaces.  The simplest network interface configuration tells the server to
  listen on all available interfaces:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"*"</code></strong> ]
    }
    ...
},
  </pre><p>
  The asterisk plays the role of a wildcard and means "listen on all interfaces".
  However, it is usually a good idea to explicitly specify interface names:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3"</code></strong> ]
    },
    ...
}
  </pre><p>
  </p><p>It is possible to use wildcard interface name (asterisk) concurrently
  with explicit interface names:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3", "*"</code></strong> ]
    },
    ...
}
  </pre><p>
It is anticipated that this form of usage will only be used when it is desired to
temporarily override a list of interface names and listen on all interfaces.
  </p><p>Some deployments of DHCP servers require that the servers listen
  on the interfaces with multiple IPv4 addresses configured. In these situations,
  the address to use can be selected by appending an IPv4 address to the interface
  name in the following manner:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1/10.0.0.1", "eth3/192.0.2.3"</code></strong> ]
    },
    ...
}
  </pre><p>
  </p><p>Should the server be required to listen on multiple IPv4 addresses assigned
  to the same interface, multiple addresses can be specified for an interface
  as in the example below:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1/10.0.0.1", "eth1/10.0.0.2"</code></strong> ]
    },
    ...
}
  </pre><p>
  </p><p>Alternatively, if the server should listen on all addresses for the particular
  interface, an interface name without any address should be specified.</p><p>Kea supports responding to directly connected clients which don't have
  an address configured. This requires that the server
  injects the hardware address of the destination into the data link layer
  of the packet being sent to the client. The DHCPv4 server utilizes the
  raw sockets to achieve this, and builds the entire IP/UDP stack for the
  outgoing packets. The down side of raw socket use, however, is that incoming
  and outgoing packets bypass the firewalls (e.g. iptables). It is also
  troublesome to handle traffic on multiple IPv4 addresses assigned to the
  same interface, as raw sockets are bound to the interface and advanced
  packet filtering techniques (e.g. using the BPF) have to be used to
  receive unicast traffic on the desired addresses assigned to the interface,
  rather than capturing whole traffic reaching the interface to which the raw
  socket is bound. Therefore, in the deployments where the server doesn't
  have to provision the directly connected clients and only receives the
  unicast packets from the relay agents, the
  DHCP server should be configured to utilize IP/UDP datagram sockets instead of raw sockets.
  The following configuration demonstrates how this can be achieved:

  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3"</code></strong> ],
        "dhcp-socket-type": "udp"
    },
    ...
}
  </pre><p>
  The <span class="command"><strong>dhcp-socket-type</strong></span> specifies that the IP/UDP sockets will
  be opened on all interfaces on which the server listens, i.e. "eth1" and
  "eth3" in our case. If the <span class="command"><strong>dhcp-socket-type</strong></span> is set to
  <strong class="userinput"><code>raw</code></strong>, it configures the server to use raw sockets
  instead. If the <span class="command"><strong>dhcp-socket-type</strong></span> value is not specified, the
  default value <strong class="userinput"><code>raw</code></strong> is used.
  </p><p>Using UDP sockets automatically disables the reception of broadcast
  packets from directly connected clients. This effectively means that the
  UDP sockets can be used for relayed traffic only. When using the raw sockets,
  both the traffic from the directly connected clients and the relayed traffic
  will be handled. Caution should be taken when configuring the server to open
  multiple raw sockets on the interface with several IPv4 addresses assigned.
  If the directly connected client sends the message to the broadcast address
  all sockets on this link will receive this message and multiple responses
  will be sent to the client. Hence, the configuration with multiple IPv4
  addresses assigned to the interface should not be used when the directly
  connected clients are operating on that link. To use a single address on
  such interface, the "interface-name/address" notation should be used.
  </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Specifying the value <strong class="userinput"><code>raw</code></strong> as the socket type,
    doesn't guarantee that the raw sockets will be used! The use of raw sockets
    to handle the traffic from the directly connected clients is currently
    supported on Linux and BSD systems only. If the raw sockets are not
    supported on the particular OS, the server will issue a warning and
    fall back to use IP/UDP sockets.</p></div><p>In typical environment the DHCP server is expected to send back a
  response on the same network interface on which the query is received. This is
  the default behavior. However, in some deployments it is desired that the
  outbound (response) packets will be sent as regular traffic and the outbound
  interface will be determined by the routing tables. This kind of asymetric
  traffic is uncommon, but valid. Kea now supports a parameter called
  <span class="command"><strong>outbound-interface</strong></span> that controls this behavior. It supports
  two values. The first one, <strong class="userinput"><code>same-as-inbound</code></strong>, tells Kea
  to send back the response on the same inteface the query packet is received. This
  is the default behavior. The second one, <strong class="userinput"><code>use-routing</code></strong>
  tells Kea to send regular UDP packets and let the kernel's routing table to
  determine most appropriate interface. This only works when
  <span class="command"><strong>dhcp-socket-type</strong></span> is  set to <strong class="userinput"><code>udp</code></strong>.
  An example configuration looks as follows:
  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ "eth1", "eth3" ],
        "dhcp-socket-type": "udp",
        <strong class="userinput"><code>"outbound-interface": "use-routing"</code></strong>
    },
    ...
}</pre><p>
  </p><p>Interfaces are re-detected at each reconfiguration. This behavior
  can be disabled by setting <span class="command"><strong>re-detect</strong></span> value to
  <strong class="userinput"><code>false</code></strong>, for instance:

  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3"</code></strong> ],
        "re-detect": <strong class="userinput"><code>false</code></strong>
    },
    ...
}
  </pre><p>
  Note interfaces are not re-detected during <span class="command"><strong>config-test</strong></span>.
  </p><p>Usually loopback interfaces (e.g. the "lo" or "lo0" interface)
  may not be configured but if a loopback interface is explicitely configured
  and IP/UDP sockets are specified the loopback interface is accepted.
  </p><p>It can be used for instance to run Kea in a FreeBSD jail having
  only a loopback interface, servicing relayed DHCP request:

  </p><pre class="screen">
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"lo0"</code></strong> ],
        "dhcp-socket-type": "udp"
    },
    ...
}</pre><p>
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcpinform-unicast-issues"></a>8.2.5. Issues with Unicast Responses to DHCPINFORM</h3></div></div></div><p>The use of UDP sockets has certain benefits in deployments
  where the server receives only relayed traffic; these benefits are
  mentioned in <a class="xref" href="#dhcp4-interface-configuration" title="8.2.4. Interface Configuration">Section 8.2.4, “Interface Configuration”</a>. From
  the administrator's perspective it is often desirable to
  configure the system's firewall to filter out the unwanted traffic, and
  the use of UDP sockets facilitates this. However, the administrator must
  also be aware of the implications related to filtering certain types
  of traffic as it may impair the DHCP server's operation.
  </p><p>In this section we are focusing on the case when the server
  receives the DHCPINFORM message from the client via a relay. According
  to <a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>,
  the server should unicast the DHCPACK response to the address carried in
  the "ciaddr" field. When the UDP socket is in use, the DHCP server
  relies on the low level functions of an operating system to build the
  data link, IP and UDP layers of the outgoing message. Typically, the
  OS will first use ARP to obtain the client's link layer address to be
  inserted into the frame's header, if the address is not cached from
  a previous transaction that the client had with the server.
  When the ARP exchange is successful, the DHCP message can be unicast
  to the client, using the  obtained address.
  </p><p>Some system administrators block ARP messages in their network,
  which causes issues for the server when it responds to the
  DHCPINFORM messages, because the server is unable to send the
  DHCPACK if the preceding ARP communication fails. Since the OS is
  entirely responsible for the ARP communication and then sending
  the DHCP packet over the wire, the DHCP server has no means to
  determine that the ARP exchange failed and the DHCP response message
  was dropped. Thus, the server does not log any error messages when
  the outgoing DHCP response is dropped. At the same time, all hooks
  pertaining to the packet sending operation will be called, even
  though the message never reaches its destination.
  </p><p>Note that the issue described in this section is not observed
  when the raw sockets are in use, because, in this case, the DHCP server
  builds all the layers of the outgoing message on its own and does not
  use ARP. Instead, it inserts the value carried in the 'chaddr' field
  of the DHCPINFORM message into the link layer.
  </p><p>Server administrators willing to support DHCPINFORM
  messages via relays should not block ARP traffic in their
  networks or should use raw sockets instead of UDP sockets.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ipv4-subnet-id"></a>8.2.6. IPv4 Subnet Identifier</h3></div></div></div><p>
    The subnet identifier is a unique number associated with a particular subnet.
    In principle, it is used to associate clients' leases with their respective subnets.
    When a subnet identifier is not specified for a subnet being configured, it will
    be automatically assigned by the configuration mechanism. The identifiers
    are assigned from 1 and are monotonically increased for each subsequent
    subnet: 1, 2, 3 ....
  </p><p>
    If there are multiple subnets configured with auto-generated identifiers and
    one of them is removed, the subnet identifiers may be renumbered. For example:
    if there are four subnets and the third is removed the last subnet will be assigned
    the identifier that the third subnet had before removal. As a result, the leases
    stored in the lease database for subnet 3 are now associated with
    subnet 4, something that may have unexpected consequences. It is planned
    to implement a mechanism to preserve auto-generated subnet ids in a
    future version of Kea.  However, the only remedy for this issue
    at present is to
    manually specify a unique identifier for each subnet.
  </p><p>
        The following configuration will assign the specified subnet
        identifier to the newly configured subnet:

        </p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            <strong class="userinput"><code>"id": 1024</code></strong>,
            ...
        }
    ]
}
</pre><p>
    This identifier will not change for this subnet unless the "id" parameter is
    removed or set to 0. The value of 0 forces auto-generation of the subnet
    identifier.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-address-config"></a>8.2.7. Configuration of IPv4 Address Pools</h3></div></div></div><p>
    The main role of a DHCPv4 server is address assignment. For this, the server has to
    be configured with at least one subnet and one pool of dynamic addresses for it to manage.
    For example, assume that the server is connected to a network
    segment that uses the 192.0.2.0/24 prefix. The Administrator of that network
    has decided that addresses from range 192.0.2.10 to 192.0.2.20 are going to
    be managed by the Dhcp4 server. Such a configuration can be achieved in the
    following way:
    </p><pre class="screen">
"Dhcp4": {
    <strong class="userinput"><code>"subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [
                { "pool": "192.0.2.10 - 192.0.2.20" }
            ],
            ...
        }
    ]</code></strong>
}</pre><p>

    Note that <span class="command"><strong>subnet</strong></span> is defined as a simple string, but
    the <span class="command"><strong>pools</strong></span> parameter is actually a list of pools: for
    this reason, the pool definition is enclosed in square brackets, even
    though only one range of addresses is specified.</p><p>Each <span class="command"><strong>pool</strong></span> is a structure that contains the
    parameters that describe a single pool. Currently there is only one
    parameter, <span class="command"><strong>pool</strong></span>, which gives the range of addresses
    in the pool. Additional parameters will be added in future releases of
    Kea.</p><p>It is possible to define more than one pool in a subnet: continuing
    the previous example, further assume that 192.0.2.64/26 should be also be
    managed by the server. It could be written as 192.0.2.64 to
    192.0.2.127. Alternatively, it can be expressed more simply as
    192.0.2.64/26. Both formats are supported by Dhcp4 and can be mixed in the
    pool list.  For example, one could define the following pools:
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            <strong class="userinput"><code>"pools": [
                { "pool": "192.0.2.10-192.0.2.20" },
                { "pool": "192.0.2.64/26" }
            ]</code></strong>,
            ...
        }
    ],
    ...
}
</pre><p>
    White space in pool definitions is ignored, so spaces before and after the hyphen are optional.
    They can be used to improve readability.
  </p><p>
    The number of pools is not limited, but for performance reasons it is recommended to
    use as few as possible.
  </p><p>
    The server may be configured to serve more than one subnet:
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.1 - 192.0.2.200" } ],
            ...
        },
        {
            "subnet": "192.0.3.0/24",
            "pools": [ { "pool": "192.0.3.100 - 192.0.3.200" } ],
            ...
        },
        {
            "subnet": "192.0.4.0/24",
            "pools": [ { "pool": "192.0.4.1 - 192.0.4.254" } ],
            ...
        }
    ]
}
</pre><p>
  </p><p>
    When configuring a DHCPv4 server using prefix/length notation, please pay
    attention to the boundary values. When specifying that the server can use
    a given pool, it will also be able to allocate the first (typically network
    address) and the last (typically broadcast address) address from that pool.
    In the aforementioned example of pool 192.0.3.0/24, both 192.0.3.0 and
    192.0.3.255 addresses may be assigned as well. This may be invalid in some
    network configurations. If you want to avoid this, please use the "min-max" notation.
  </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-std-options"></a>8.2.8. Standard DHCPv4 Options</h3></div></div></div><p>
        One of the major features of the DHCPv4 server is to provide configuration
        options to clients. Most of the options are sent by the server only if the
        client explicitly requests them using the Parameter Request List option.
        Those that do not require inclusion in the Parameter Request List
        option are commonly used options, e.g. "Domain Server", and options which
        require special behavior, e.g. "Client FQDN" is returned to the client
        if the client has included this option in its message to the server.
      </p><p>
        <a class="xref" href="#dhcp4-std-options-list" title="Table 8.1. List of standard DHCPv4 options">Table 8.1, “List of standard DHCPv4 options”</a> comprises the list of the
        standard DHCPv4 options whose values can be configured using the
        configuration structures described in this section. This table excludes
        the options which require special processing and thus cannot be configured
        with some fixed values. The last column of the table indicates which
        options can be sent by the server even when they are not requested in
        the Parameter Request list option, and those which are sent only when
        explicitly requested.
      </p><p>
        The following example shows how to configure the addresses of DNS
        servers, which is one of the most frequently used options. Options
        specified in this way are considered global and apply to all
        configured subnets.

        </p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "domain-name-servers",
           "code": 6,
           "space": "dhcp4",
           "csv-format": true,
           "data": "192.0.2.1, 192.0.2.2"</code></strong>
        },
        ...
    ]
}
        </pre><p>
        Note that only one of name or code is required, you don't need to
        specify both. Space has a default value of "dhcp4", so you can skip this
        as well if you define a regular (not encapsulated) DHCPv4 option.
        Finally, csv-format defaults to true, so it too can be skipped, unless
        you want to specify the option value as hexstring. Therefore the
        above example can be simplified to:
        </p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "domain-name-servers",
           "data": "192.0.2.1, 192.0.2.2"</code></strong>
        },
        ...
    ]
}
        </pre><p>
        Defined options are added to response when the client requests them
        at a few exceptions which are always added. To enforce the addition
        of a particular option set the always-send flag to true as in:
        </p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "domain-name-servers",
           "data": "192.0.2.1, 192.0.2.2",
           "always-send": true</code></strong>
        },
        ...
    ]
}
        </pre><p>
        The effect is the same as if the client added the option code in the
        Parameter Request List option (or its equivalent for vendor
        options) so in:
        </p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "domain-name-servers",
           "data": "192.0.2.1, 192.0.2.2",
           "always-send": true</code></strong>
        },
        ...
    ],
    "subnet4": [
        {
           "subnet": "192.0.3.0/24",
           "option-data": [
               {
                   <strong class="userinput"><code>"name": "domain-name-servers",
                   "data": "192.0.3.1, 192.0.3.2"</code></strong>
               },
               ...
           ],
           ...
        },
        ...
    ],
    ...
}
        </pre><p>
        The Domain Name Servers option is always added to responses
        (the always-send is "sticky") but the value is the subnet one
        when the client is localized in the subnet.
      </p><p>
      The <span class="command"><strong>name</strong></span> parameter specifies the option name. For a
      list of currently supported names, see <a class="xref" href="#dhcp4-std-options-list" title="Table 8.1. List of standard DHCPv4 options">Table 8.1, “List of standard DHCPv4 options”</a> below.  The <span class="command"><strong>code</strong></span>
      parameter specifies the option code, which must match one of the values
      from that list. The next line specifies the option space, which must
      always be set to "dhcp4" as these are standard DHCPv4 options. For other
      option spaces, including custom option spaces, see <a class="xref" href="#dhcp4-option-spaces" title="8.2.12. Nested DHCPv4 Options (Custom Option Spaces)">Section 8.2.12, “Nested DHCPv4 Options (Custom Option Spaces)”</a>. The next line specifies the format in
      which the data will be entered: use of CSV (comma separated values) is
      recommended. The sixth line gives the actual value to be sent to
      clients. Data is specified as normal text, with values separated by commas
      if more than one value is allowed.
    </p><p>
      Options can also be configured as hexadecimal values. If
      <span class="command"><strong>csv-format</strong></span> is
      set to false, option data must be specified as a hexadecimal string. The
      following commands configure the domain-name-servers option for all
      subnets with the following addresses: 192.0.3.1 and 192.0.3.2.
      Note that <span class="command"><strong>csv-format</strong></span> is set to false.
      </p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "domain-name-servers",
            "code": 6,
            "space": "dhcp4",
            "csv-format": false,
            "data": "C0 00 03 01 C0 00 03 02"</code></strong>
        },
        ...
    ],
    ...
}</pre><p>
    </p><p>
       Care should be taken
       to use proper encoding when using hexadecimal format as Kea's ability
       to validate data correctness in hexadecimal is limited.
      </p><p>
        Most of the parameters in the "option-data" structure are optional and
        can be omitted in some circumstances as discussed in the
        <a class="xref" href="#dhcp4-option-data-defaults" title="8.2.13. Unspecified Parameters for DHCPv4 Option Configuration">Section 8.2.13, “Unspecified Parameters for DHCPv4 Option Configuration”</a>.
      </p><p>
        It is possible to specify or override options on a per-subnet basis.  If
        clients connected to most of your subnets are expected to get the
        same values of a given option, you should use global options: you
        can then override specific values for a small number of subnets.
        On the other hand, if you use different values in each subnet,
        it does not make sense to specify global option values
        (Dhcp4/option-data), rather you should set only subnet-specific values
        (Dhcp4/subnet[X]/option-data[Y]).
      </p><p>
        The following commands override the global
        DNS servers option for a particular subnet, setting a single DNS
        server with address 192.0.2.3.
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            <strong class="userinput"><code>"option-data": [
                {
                    "name": "domain-name-servers",
                    "code": 6,
                    "space": "dhcp4",
                    "csv-format": true,
                    "data": "192.0.2.3"
                },
                ...
            ]</code></strong>,
            ...
        },
        ...
    ],
    ...
}
</pre><p>
      </p><p>
        In some cases it is useful to associate some options with an
        address pool from which a client is assigned a lease. Pool
        specific option values override subnet specific and global
        option values. The server's administrator must not try to
        prioritize assignment of pool specific options by trying to
        order pools declarations in the server configuration. Future
        Kea releases may change the order in which options are
        assigned from the pools without any notice.
      </p><p>
       The following configuration snippet demonstrates how to specify the
       DNS servers option, which will be assigned to a client only if the
       client obtains an address from the given pool:
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "pools": [
                {
                    "pool": "192.0.2.1 - 192.0.2.200",
                    <strong class="userinput"><code>"option-data": [
                        {
                            "name": "domain-name-servers",
                            "data": "192.0.2.3"
                         },
                         ...
                    ]</code></strong>,
                    ...
                },
                ...
            ],
            ...
        },
        ...
    ],
    ...
}
</pre><p>
      </p><p>
        The currently supported standard DHCPv4 options are
        listed in <a class="xref" href="#dhcp4-std-options-list" title="Table 8.1. List of standard DHCPv4 options">Table 8.1, “List of standard DHCPv4 options”</a>.
        The "Name" and "Code"
        are the values that should be used as a name in the option-data
        structures. "Type" designates the format of the data: the meanings of
        the various types is given in <a class="xref" href="#dhcp-types" title="Table 8.2. List of standard DHCP option types">Table 8.2, “List of standard DHCP option types”</a>.
      </p><p>When a data field is a string, and that string contains the comma
      (,; U+002C) character, the comma must be escaped with a double reverse solidus
      character (\; U+005C). This double escape is required, because both the
      routine splitting CSV data into fields and JSON use the same escape
      character: a single escape (\,) would make the JSON invalid.
      For example, the string "foo,bar" would be represented as:
      </p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "pools": [
                {
                    <strong class="userinput"><code>"option-data": [
                        {
                            "name": "boot-file-name",
                            "data": "foo\\,bar"
                        }
                    ]</code></strong>
                },
                ...
            ],
            ...
        },
        ...
    ],
    ...
}
</pre><p>
      </p><p>
        Some options are designated as arrays, which means that more than one
        value is allowed in such an option. For example the option time-servers
        allows the specification of more than one IPv4 address, so allowing
        clients to obtain the addresses of multiple NTP servers.
      </p><p>
        The <a class="xref" href="#dhcp4-custom-options" title="8.2.9. Custom DHCPv4 options">Section 8.2.9, “Custom DHCPv4 options”</a> describes the configuration
        syntax to create custom option definitions (formats). It is generally not
        allowed to create custom definitions for standard options, even if the
        definition being created matches the actual option format defined in the
        RFCs. There is an exception from this rule for standard options for which
        Kea currently does not provide a definition. In order to use such options,
        a server administrator must create a definition as described in
        <a class="xref" href="#dhcp4-custom-options" title="8.2.9. Custom DHCPv4 options">Section 8.2.9, “Custom DHCPv4 options”</a> in the 'dhcp4' option space. This
        definition should match the option format described in the relevant
        RFC but the configuration mechanism will allow any option format as it
        presently has no means to validate it.
      </p><p>
        </p><div class="table"><a name="dhcp4-std-options-list"></a><p class="title"><b>Table 8.1. List of standard DHCPv4 options</b></p><div class="table-contents"><table summary="List of standard DHCPv4 options" border="1"><colgroup><col class="name"><col align="center" class="code"><col align="center" class="type"><col align="center" class="array"><col align="center" class="always-returned"></colgroup><thead><tr><th>Name</th><th align="center">Code</th><th align="center">Type</th><th align="center">Array?</th><th align="center">Returned if not requested?</th></tr></thead><tbody><tr><td>time-offset</td><td align="center">2</td><td align="center">int32</td><td align="center">false</td><td align="center">false</td></tr><tr><td>routers</td><td align="center">3</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">true</td></tr><tr><td>time-servers</td><td align="center">4</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>name-servers</td><td align="center">5</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>domain-name-servers</td><td align="center">6</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">true</td></tr><tr><td>log-servers</td><td align="center">7</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>cookie-servers</td><td align="center">8</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>lpr-servers</td><td align="center">9</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>impress-servers</td><td align="center">10</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>resource-location-servers</td><td align="center">11</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>boot-size</td><td align="center">13</td><td align="center">uint16</td><td align="center">false</td><td align="center">false</td></tr><tr><td>merit-dump</td><td align="center">14</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>domain-name</td><td align="center">15</td><td align="center">fqdn</td><td align="center">false</td><td align="center">true</td></tr><tr><td>swap-server</td><td align="center">16</td><td align="center">ipv4-address</td><td align="center">false</td><td align="center">false</td></tr><tr><td>root-path</td><td align="center">17</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>extensions-path</td><td align="center">18</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>ip-forwarding</td><td align="center">19</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>non-local-source-routing</td><td align="center">20</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>policy-filter</td><td align="center">21</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>max-dgram-reassembly</td><td align="center">22</td><td align="center">uint16</td><td align="center">false</td><td align="center">false</td></tr><tr><td>default-ip-ttl</td><td align="center">23</td><td align="center">uint8</td><td align="center">false</td><td align="center">false</td></tr><tr><td>path-mtu-aging-timeout</td><td align="center">24</td><td align="center">uint32</td><td align="center">false</td><td align="center">false</td></tr><tr><td>path-mtu-plateau-table</td><td align="center">25</td><td align="center">uint16</td><td align="center">true</td><td align="center">false</td></tr><tr><td>interface-mtu</td><td align="center">26</td><td align="center">uint16</td><td align="center">false</td><td align="center">false</td></tr><tr><td>all-subnets-local</td><td align="center">27</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>broadcast-address</td><td align="center">28</td><td align="center">ipv4-address</td><td align="center">false</td><td align="center">false</td></tr><tr><td>perform-mask-discovery</td><td align="center">29</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>mask-supplier</td><td align="center">30</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>router-discovery</td><td align="center">31</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>router-solicitation-address</td><td align="center">32</td><td align="center">ipv4-address</td><td align="center">false</td><td align="center">false</td></tr><tr><td>static-routes</td><td align="center">33</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>trailer-encapsulation</td><td align="center">34</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>arp-cache-timeout</td><td align="center">35</td><td align="center">uint32</td><td align="center">false</td><td align="center">false</td></tr><tr><td>ieee802-3-encapsulation</td><td align="center">36</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>default-tcp-ttl</td><td align="center">37</td><td align="center">uint8</td><td align="center">false</td><td align="center">false</td></tr><tr><td>tcp-keepalive-interval</td><td align="center">38</td><td align="center">uint32</td><td align="center">false</td><td align="center">false</td></tr><tr><td>tcp-keepalive-garbage</td><td align="center">39</td><td align="center">boolean</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nis-domain</td><td align="center">40</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nis-servers</td><td align="center">41</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>ntp-servers</td><td align="center">42</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>vendor-encapsulated-options</td><td align="center">43</td><td align="center">empty</td><td align="center">false</td><td align="center">false</td></tr><tr><td>netbios-name-servers</td><td align="center">44</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>netbios-dd-server</td><td align="center">45</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>netbios-node-type</td><td align="center">46</td><td align="center">uint8</td><td align="center">false</td><td align="center">false</td></tr><tr><td>netbios-scope</td><td align="center">47</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>font-servers</td><td align="center">48</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>x-display-manager</td><td align="center">49</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>dhcp-option-overload</td><td align="center">52</td><td align="center">uint8</td><td align="center">false</td><td align="center">false</td></tr><tr><td>dhcp-server-identifier</td><td align="center">54</td><td align="center">ipv4-address</td><td align="center">false</td><td align="center">true</td></tr><tr><td>dhcp-message</td><td align="center">56</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>dhcp-max-message-size</td><td align="center">57</td><td align="center">uint16</td><td align="center">false</td><td align="center">false</td></tr><tr><td>vendor-class-identifier</td><td align="center">60</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nwip-domain-name</td><td align="center">62</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nwip-suboptions</td><td align="center">63</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nisplus-domain-name</td><td align="center">64</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nisplus-servers</td><td align="center">65</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>tftp-server-name</td><td align="center">66</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>boot-file-name</td><td align="center">67</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>mobile-ip-home-agent</td><td align="center">68</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>smtp-server</td><td align="center">69</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>pop-server</td><td align="center">70</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>nntp-server</td><td align="center">71</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>www-server</td><td align="center">72</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>finger-server</td><td align="center">73</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>irc-server</td><td align="center">74</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>streettalk-server</td><td align="center">75</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>streettalk-directory-assistance-server</td><td align="center">76</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>user-class</td><td align="center">77</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>slp-directory-agent</td><td align="center">78</td><td align="center">record (boolean, ipv4-address)</td><td align="center">true</td><td align="center">false</td></tr><tr><td>slp-service-scope</td><td align="center">79</td><td align="center">record (boolean, string)</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nds-server</td><td align="center">85</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>nds-tree-name</td><td align="center">86</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>nds-context</td><td align="center">87</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>bcms-controller-names</td><td align="center">88</td><td align="center">fqdn</td><td align="center">true</td><td align="center">false</td></tr><tr><td>bcms-controller-address</td><td align="center">89</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>client-system</td><td align="center">93</td><td align="center">uint16</td><td align="center">true</td><td align="center">false</td></tr><tr><td>client-ndi</td><td align="center">94</td><td align="center">record (uint8, uint8, uint8)</td><td align="center">false</td><td align="center">false</td></tr><tr><td>uuid-guid</td><td align="center">97</td><td align="center">record (uint8, hex)</td><td align="center">false</td><td align="center">false</td></tr><tr><td>uap-servers</td><td align="center">98</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>geoconf-civic</td><td align="center">99</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>pcode</td><td align="center">100</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>tcode</td><td align="center">101</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>netinfo-server-address</td><td align="center">112</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>netinfo-server-tag</td><td align="center">113</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>default-url</td><td align="center">114</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>auto-config</td><td align="center">116</td><td align="center">uint8</td><td align="center">false</td><td align="center">false</td></tr><tr><td>name-service-search</td><td align="center">117</td><td align="center">uint16</td><td align="center">true</td><td align="center">false</td></tr><tr><td>subnet-selection</td><td align="center">118</td><td align="center">ipv4-address</td><td align="center">false</td><td align="center">false</td></tr><tr><td>domain-search</td><td align="center">119</td><td align="center">fqdn</td><td align="center">true</td><td align="center">false</td></tr><tr><td>vivco-suboptions</td><td align="center">124</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>vivso-suboptions</td><td align="center">125</td><td align="center">hex</td><td align="center">false</td><td align="center">false</td></tr><tr><td>pana-agent</td><td align="center">136</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>v4-lost</td><td align="center">137</td><td align="center">fqdn</td><td align="center">false</td><td align="center">false</td></tr><tr><td>capwap-ac-v4</td><td align="center">138</td><td align="center">ipv4-address</td><td align="center">true</td><td align="center">false</td></tr><tr><td>sip-ua-cs-domains</td><td align="center">142</td><td align="center">fqdn</td><td align="center">true</td><td align="center">false</td></tr><tr><td>rdnss-selection</td><td align="center">146</td><td align="center">record (uint8, ipv4-address, ipv4-address, fqdn)</td><td align="center">true</td><td align="center">false</td></tr><tr><td>v4-portparams</td><td align="center">159</td><td align="center">record (uint8, psid)</td><td align="center">false</td><td align="center">false</td></tr><tr><td>v4-captive-portal</td><td align="center">160</td><td align="center">string</td><td align="center">false</td><td align="center">false</td></tr><tr><td>option-6rd</td><td align="center">212</td><td align="center">record (uint8, uint8, ipv6-address, ipv4-address)</td><td align="center">true</td><td align="center">false</td></tr><tr><td>v4-access-domain</td><td align="center">213</td><td align="center">fqdn</td><td align="center">false</td><td align="center">false</td></tr></tbody></table></div></div><p><br class="table-break">

      </p><p>
        </p><div class="table"><a name="dhcp-types"></a><p class="title"><b>Table 8.2. List of standard DHCP option types</b></p><div class="table-contents"><table summary="List of standard DHCP option types" border="1"><colgroup><col class="name"><col class="meaning"></colgroup><thead><tr><th>Name</th><th>Meaning</th></tr></thead><tbody><tr><td>hex</td><td>An arbitrary string of bytes, specified as a set of hexadecimal digits.</td></tr><tr><td>boolean</td><td>Boolean value with allowed values true or false</td></tr><tr><td>empty</td><td>No value, data is carried in suboptions</td></tr><tr><td>fqdn</td><td>Fully qualified domain name (e.g. www.example.com)</td></tr><tr><td>ipv4-address</td><td>IPv4 address in the usual dotted-decimal notation (e.g. 192.0.2.1)</td></tr><tr><td>ipv6-address</td><td>IPv6 address in the usual colon notation (e.g. 2001:db8::1)</td></tr><tr><td>ipv6-prefix</td><td>IPv6 prefix and prefix length specified using CIDR notation, e.g. 2001:db8:1::/64. This data type is used to represent an 8-bit field conveying a prefix length and the variable length prefix value</td></tr><tr><td>psid</td><td>PSID and PSID length separated by a slash, e.g. 3/4 specifies PSID=3 and PSID length=4. In the wire format it is represented by an 8-bit field carrying PSID length (in this case equal to 4) and the 16-bits long PSID value field (in this case equal to "0011000000000000b" using binary notation). Allowed values for a PSID length are 0 to 16. See <a class="ulink" href="http://tools.ietf.org/html/rfc7597" target="_top">RFC 7597</a> for the details about the PSID wire representation</td></tr><tr><td>record</td><td>Structured data that may be comprised of any types (except "record" and "empty"). The array flag applies to the last field only.</td></tr><tr><td>string</td><td>Any text</td></tr><tr><td>tuple</td><td>A length encoded as a 8 (16 for DHCPv6) bit unsigned integer followed by a string of this length</td></tr><tr><td>uint8</td><td>8 bit unsigned integer with allowed values 0 to 255</td></tr><tr><td>uint16</td><td>16 bit unsigned integer with allowed values 0 to 65535</td></tr><tr><td>uint32</td><td>32 bit unsigned integer with allowed values 0 to 4294967295</td></tr><tr><td>int8</td><td>8 bit signed integer with allowed values -128 to 127</td></tr><tr><td>int16</td><td>16 bit signed integer with allowed values -32768 to 32767</td></tr><tr><td>int32</td><td>32 bit signed integer with allowed values -2147483648 to 2147483647</td></tr></tbody></table></div></div><p><br class="table-break">
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-custom-options"></a>8.2.9. Custom DHCPv4 options</h3></div></div></div><p>Kea supports custom (non-standard) DHCPv4 options. Assume
      that we want to define a new DHCPv4 option called "foo" which
      will have a code 222 and will convey a single unsigned 32 bit
      integer value. We can define such an option by using the
      following entry in the configuration file:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 222,
            "type": "uint32",
            "array": false,
            "record-types": "",
            "space": "dhcp4",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The <span class="command"><strong>false</strong></span> value of the <span class="command"><strong>array</strong></span>
      parameter determines that the option does NOT comprise an array of
      "uint32" values but is, instead, a single value.  Two other parameters have been
      left blank: <span class="command"><strong>record-types</strong></span> and
      <span class="command"><strong>encapsulate</strong></span>.  The former specifies the comma separated
      list of option data fields if the option comprises a record of data
      fields. This should be non-empty if the <span class="command"><strong>type</strong></span> is set to
      "record". Otherwise it must be left blank. The latter parameter specifies
      the name of the option space being encapsulated by the particular
      option. If the particular option does not encapsulate any option space it
      should be left blank.  Note that the above set of comments define the
      format of the new option and do not set its values.
      </p><p>The <span class="command"><strong>name</strong></span>, <span class="command"><strong>code</strong></span> and
      <span class="command"><strong>type</strong></span> parameters are required, all others are
      optional. The <span class="command"><strong>array</strong></span> default value is
      <span class="command"><strong>false</strong></span>. The <span class="command"><strong>record-types</strong></span>
      and <span class="command"><strong>encapsulate</strong></span> default values are blank
      (i.e. ""). The default <span class="command"><strong>space</strong></span> is "dhcp4".
      </p><p>Once the new option format is defined, its value is set
      in the same way as for a standard option. For example the following
      commands set a global value that applies to all subnets.
</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 222,
            "space": "dhcp4",
            "csv-format": true,
            "data": "12345"</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      </p><p>New options can take more complex forms than simple use of
      primitives (uint8, string, ipv4-address etc): it is possible to
      define an option comprising a number of existing primitives.
      Assume we want to define a new option that will consist of
      an IPv4 address, followed by an unsigned 16 bit integer, followed by
      a boolean value, followed by a text string. Such an option could
      be defined in the following way:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "bar",
            "code": 223,
            "space": "dhcp4",
            "type": "record",
            "array": false,
            "record-types": "ipv4-address, uint16, boolean, string",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The <span class="command"><strong>type</strong></span> is set to "record" to indicate that the option contains
      multiple values of different types.  These types are given as a comma-separated
      list in the <span class="command"><strong>record-types</strong></span> field and should be ones from those listed in <a class="xref" href="#dhcp-types" title="Table 8.2. List of standard DHCP option types">Table 8.2, “List of standard DHCP option types”</a>.
      </p><p>
      The values of the option are set as follows:
</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "bar",
            "space": "dhcp4",
            "code": 223,
            "csv-format": true,
            "data": "192.0.2.100, 123, true, Hello World"</code></strong>
        }
    ],
    ...
}</pre><p>
      <span class="command"><strong>csv-format</strong></span> is set to <span class="command"><strong>true</strong></span> to indicate
      that the <span class="command"><strong>data</strong></span> field comprises a command-separated list
      of values.  The values in the <span class="command"><strong>data</strong></span> must correspond to
      the types set in the <span class="command"><strong>record-types</strong></span> field of the option
      definition.
     </p><p>
       When <span class="command"><strong>array</strong></span> is set to <span class="command"><strong>true</strong></span>
       and <span class="command"><strong>type</strong></span> is set to "record", the last field
       is an array, i.e., it can contain more than one value as in:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "bar",
            "code": 223,
            "space": "dhcp4",
            "type": "record",
            "array": true,
            "record-types": "ipv4-address, uint16",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The new option content is one IPv4 address followed by one or more 16
      bit unsigned integers.
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the general case, boolean values are specified as <span class="command"><strong>true</strong></span> or
       <span class="command"><strong>false</strong></span>, without quotes. Some specific boolean parameters may
       accept also <span class="command"><strong>"true"</strong></span>, <span class="command"><strong>"false"</strong></span>,
       <span class="command"><strong>0</strong></span>, <span class="command"><strong>1</strong></span>, <span class="command"><strong>"0"</strong></span> and
       <span class="command"><strong>"1"</strong></span>. Future versions of Kea will accept all those values
       for all boolean parameters.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Numbers can be specified in decimal or hexadecimal format.
        The hexadecimal format can be either plain (e.g. abcd) or
        prefixed with 0x (e.g. 0xabcd).
       </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-private-opts"></a>8.2.10. DHCPv4 Private Options</h3></div></div></div><p>
      Options with code between 224 and 254 are reserved for private use.
      They can be defined at the global scope or at client class local
      scope: this allows to use option definitions depending on context
      and to set option data accordingly. For instance to configure
      an old PXEClient vendor:
</p><pre class="screen">
"Dhcp4": {
    "client-classes": [
        {
            <strong class="userinput"><code>"name": "pxeclient",
            "test": "option[vendor-class-identifier].text == 'PXEClient'",
            "option-def": [
                {
                    "name": "configfile",
                    "code": 209,
                    "type": "string"
                }
            ],</code></strong>
            ...
        }, ...
    ],
    ...
}
</pre><p>
      </p><p>
      As the Vendor Specific Information option (code 43) has vendor
      specific format, i.e. can carry either raw binary value or
      sub-options, this mechanism is available for this option too.
      </p><p>
      In the following example taken from a real configuration two vendor
      classes use the option 43 for different and incompatible purposes:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "cookie",
            "code": 1,
            "type": "string",
            "space": "APC"
        },
        {
            "name": "mtftp-ip",
            "code": 1,
            "type": "ipv4-address",
            "space": "PXE"
        },</code></strong>
        ...
    ],
    "client-classes": [
        {
            <strong class="userinput"><code>"name": "APC",
            "test": "(option[vendor-class-identifier].text == 'APC'",
            "option-def": [
                {
                    "name": "vendor-encapsulated-options",
                    "type": "empty",
                    "encapsulate": "APC"
                }
            ],
            "option-data": [
                {
                    "name": "cookie",
                    "space": "APC",
                    "data": "1APC"
                },
                {
                    "name": "vendor-encapsulated-options"
                },</code></strong>
                ...
            ],
            ...
        },
        {
            <strong class="userinput"><code>"name": "PXE",
            "test": "(option[vendor-class-identifier].text == 'PXE'",
            "option-def": [
                {
                    "name": "vendor-encapsulated-options",
                    "type": "empty",
                    "encapsulate": "PXE"
                }
            ],
            "option-data": [
                {
                    "name": "mtftp-ip",
                    "space": "PXE",
                    "data": "0.0.0.0"
                },
                {
                    "name": "vendor-encapsulated-options"
                },</code></strong>
                ...
            ],
            ...
        },
        ...
    ],
    ...
}
</pre><p>
      </p><p>
      The definition used to decode a VSI option is:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      The local definition of a client class the incoming packet belongs to
      </p></li><li class="listitem"><p>
      If none, the global definition
      </p></li><li class="listitem"><p>
      If none, the last resort definition described in the next section
      <a class="xref" href="#dhcp4-vendor-opts" title="8.2.11. DHCPv4 Vendor Specific Options">Section 8.2.11, “DHCPv4 Vendor Specific Options”</a> (backward compatible with
      previous Kea versions).
      </p></li></ol></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      This last resort definition for the Vendor Specific Information
      option (code 43) is not compatible with a raw binary value.
      So when there are some known cases where a raw binary value
      will be used, a client class must be defined with a classification
      expression matching these cases and an option definition for
      the VSI option with a binary type and no encapsulation.
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      Option definitions in client classes is allowed only for these
      limited option set (codes 43 and from 224 to 254), and only
      for DHCPv4.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-vendor-opts"></a>8.2.11. DHCPv4 Vendor Specific Options</h3></div></div></div><p>
      Currently there are two option spaces defined for the DHCPv4 daemon:
      "dhcp4" (for the top level DHCPv4 options) and
      "vendor-encapsulated-options-space", which is empty by default but
      in which options can be defined. Such options will be carried in the
      Vendor Specific Information option (code 43). The following examples
      show how to define an option "foo" in that space that has a code 1,
      and comprises an
      IPv4 address, an unsigned 16 bit integer and a string. The "foo"
      option is conveyed in a Vendor Specific Information option.
      </p><p>
      The first step is to define the format of the option:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 1,
            "space": "vendor-encapsulated-options-space",
            "type": "record",
            "array": false,
            "record-types": "ipv4-address, uint16, string",
            "encapsulate": ""</code></strong>
        }
    ],
    ...
}</pre><p>
     (Note that the option space is set to "vendor-encapsulated-options-space".)
     Once the option format is defined, the next step is to define actual values
     for that option:
</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "foo",
            "space": "vendor-encapsulated-options-space",
            "code": 1,
            "csv-format": true,
            "data": "192.0.2.3, 123, Hello World"</code></strong>
        }
    ],
    ...
}</pre><p>
    We also include the Vendor Specific Information option, the option
    that conveys our sub-option "foo". This is required, else the option
    will not be included in messages sent to the client.
</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "vendor-encapsulated-options"</code></strong>
        }
    ],
    ...
}</pre><p>
    Alternatively, the option can be specified using its code.

</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"code": 43</code></strong>
        }
    ],
    ...
}</pre><p>
      </p><p>
      Another possibility, added in Kea 1.3, is to redefine the option,
      see <a class="xref" href="#dhcp4-private-opts" title="8.2.10. DHCPv4 Private Options">Section 8.2.10, “DHCPv4 Private Options”</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-option-spaces"></a>8.2.12. Nested DHCPv4 Options (Custom Option Spaces)</h3></div></div></div><p>It is sometimes useful to define a completely new option
      space. This is the case when user creates new option in the
      standard option space ("dhcp4") and wants this option
      to convey sub-options. Since they are in a separate space,
      sub-option codes will have a separate numbering scheme and may
      overlap with the codes of standard options.
      </p><p>Note that creation of a new option space when defining
      sub-options for a standard option is not required, because it is
      created by default if the standard option is meant to convey any
      sub-options (see <a class="xref" href="#dhcp4-vendor-opts" title="8.2.11. DHCPv4 Vendor Specific Options">Section 8.2.11, “DHCPv4 Vendor Specific Options”</a>).
      </p><p>
      Assume that we want to have a DHCPv4 option called "container" with
      code 222 that conveys two sub-options with codes 1 and 2.
      First we need to define the new sub-options:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "subopt1",
            "code": 1,
            "space": "isc",
            "type": "ipv4-address",
            "record-types": "",
            "array": false,
            "encapsulate": ""
        },
        {
            "name": "subopt2",
            "code": 2,
            "space": "isc",
            "type": "string",
            "record-types": "",
            "array": false,
            "encapsulate": ""</code></strong>
        }
    ],
    ...
}</pre><p>
    Note that we have defined the options to belong to a new option space
    (in this case, "isc").
    </p><p>
    The next step is to define a regular DHCPv4 option with our desired
    code and specify that it should include options from the new option space:
</p><pre class="screen">
"Dhcp4": {
    "option-def": [
        ...,
        {
            <strong class="userinput"><code>"name": "container",
            "code": 222,
            "space": "dhcp4",
            "type": "empty",
            "array": false,
            "record-types": "",
            "encapsulate": "isc"</code></strong>
        }
    ],
    ...
}</pre><p>
    The name of the option space in which the sub-options are defined
    is set in the <span class="command"><strong>encapsulate</strong></span> field. The <span class="command"><strong>type</strong></span> field is set to "empty"
    to indicate that this option does not carry any data other than
    sub-options.
    </p><p>
    Finally, we can set values for the new options:
</p><pre class="screen">
"Dhcp4": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "subopt1",
            "code": 1,
            "space": "isc",
            "data": "192.0.2.3"</code></strong>
        },
        }
            <strong class="userinput"><code>"name": "subopt2",
            "code": 2,
            "space": "isc",
            "data": "Hello world"</code></strong>
        },
        {
            <strong class="userinput"><code>"name": "container",
            "code": 222,
            "space": "dhcp4"</code></strong>
        }
    ],
    ...
}
</pre><p>
    </p><p>Note that it is possible to create an option which carries some data
    in addition to the sub-options defined in the encapsulated option space.  For example,
    if the "container" option from the previous example was required to carry an uint16
    value as well as the sub-options, the <span class="command"><strong>type</strong></span> value would have to be set to "uint16" in
    the option definition. (Such an option would then have the following
    data structure: DHCP header, uint16 value, sub-options.) The value specified
    with the <span class="command"><strong>data</strong></span> parameter — which should be a valid integer enclosed in quotes,
    e.g. "123" — would then be assigned to the uint16 field in the "container" option.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-option-data-defaults"></a>8.2.13. Unspecified Parameters for DHCPv4 Option Configuration</h3></div></div></div><p>In many cases it is not required to specify all parameters for
      an option configuration and the default values may be used. However, it is
      important to understand the implications of not specifying some of them
      as it may result in configuration errors. The list below explains
      the behavior of the server when a particular parameter is not explicitly
      specified:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>name</strong></span> - the server requires an option name or
          option code to identify an option. If this parameter is unspecified, the
          option code must be specified.
          </li><li class="listitem"><span class="command"><strong>code</strong></span> - the server requires an option name or
          option code to identify an option. This parameter may be left unspecified if
          the <span class="command"><strong>name</strong></span> parameter is specified. However, this also
          requires that the particular option has its definition (it is either a
          standard option or an administrator created a definition for the option
          using an 'option-def' structure), as the option definition associates an
          option with a particular name. It is possible to configure an option
          for which there is no definition (unspecified option format).
          Configuration of such options requires the use of option code.
          </li><li class="listitem"><span class="command"><strong>space</strong></span> - if the option space is unspecified it
          will default to 'dhcp4' which is an option space holding DHCPv4 standard
          options.
          </li><li class="listitem"><span class="command"><strong>data</strong></span> - if the option data is unspecified it
          defaults to an empty value. The empty value is mostly used for the
          options which have no payload (boolean options), but it is legal to specify
          empty values for some options which carry variable length data and which
          the specification allows for the length of 0. For such options, the data parameter
          may be omitted in the configuration.</li><li class="listitem"><span class="command"><strong>csv-format</strong></span> - if this value is not
          specified the server will assume that the option data is specified as
          a list of comma separated values to be assigned to individual fields
          of the DHCP option. This behavior has changed in Kea 1.2. Older
          versions used additional logic to determine whether the csv-format
          should be true or false. That is no longer the case.
          </li></ul></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-stateless-configuration"></a>8.2.14. Stateless Configuration of DHCPv4 Clients</h3></div></div></div><p>The DHCPv4 server supports the stateless client configuration whereby the
      client has an IP address configured (e.g. using manual configuration) and only
      contacts the server to obtain other configuration parameters, e.g. addresses of DNS servers.
      In order to obtain the stateless configuration parameters the client sends the
      DHCPINFORM message to the server with the "ciaddr" set to the address that the
      client is currently using. The server unicasts the DHCPACK message to the
      client that includes the stateless configuration ("yiaddr" not set).
      </p><p>The server will respond to the DHCPINFORM when the client is associated
      with a subnet defined in the server's configuration. An example
      subnet configuration will look like this:
        </p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24"
            "option-data": [ {
                "name": "domain-name-servers",
                "code": 6,
                "data": "192.0.2.200,192.0.2.201",
                "csv-format": true,
                "space": "dhcp4"
            } ]
        }
    ]
}</pre><p>
      </p><p>This subnet specifies the single option which will be included in
      the DHCPACK message to the client in response to DHCPINFORM. Note that
      the subnet definition does not require the address pool configuration
      if it will be used solely for the stateless configuration.
      </p><p>This server will associate the subnet with the client if one of
      the following conditions is met:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The DHCPINFORM is relayed and the giaddr matches the
            configured subnet.</li><li class="listitem">The DHCPINFORM is unicast from the client and the ciaddr
            matches the configured subnet.</li><li class="listitem">The DHCPINFORM is unicast from the client, the ciaddr is
            not set but the source address of the IP packet matches the
            configured subnet.</li><li class="listitem">The DHCPINFORM is not relayed and the IP address on the
            interface on which the message is received matches the configured
            subnet.</li></ul></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-client-classifier"></a>8.2.15. Client Classification in DHCPv4</h3></div></div></div><p>
      The DHCPv4 server includes support for client classification.  For a deeper
      discussion of the classification process see <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
      </p><p>
      In certain cases it is useful to differentiate between different types of
      clients and treat them accordingly. It is envisaged that client
      classification will be used for changing the behavior of almost any part of
      the DHCP message processing. In the current release of the software however,
      there are  only some mechanisms that take advantage of client classification:
      private options and option 43 deferred unpacking, subnet selection,
      pool selection, assignment of different options, and, for cable modems, there
      are specific options for use with the TFTP server address and the boot file field.
      </p><p>
      Kea can be instructed to limit access to given subnets based on class information.
      This is particularly useful for cases where two types of devices share the
      same link and are expected to be served from two different subnets. The
      primary use case for such a scenario is cable networks. Here, there are two
      classes of devices: the cable modem itself, which should be handed a lease
      from subnet A and all other devices behind the modem that should get a lease
      from subnet B. That segregation is essential to prevent overly curious
      users from playing with their cable modems. For details on how to set up
      class restrictions on subnets, see <a class="xref" href="#classification-subnets" title="13.6. Configuring Subnets With Class Information">Section 13.6, “Configuring Subnets With Class Information”</a>.
      </p><p>
      When subnets belong to a shared network the classification applies
      to subnet selection but not to pools, e.g., a pool in a subnet
      limited to a particular class can still be used by clients which do not
      belong to the class if the pool they are expected to use is exhausted.
      So the limit access based on class information is also available
      at the pool level, see <a class="xref" href="#classification-pools" title="13.7. Configuring Pools With Class Information">Section 13.7, “Configuring Pools With Class Information”</a>,
      within a subnet.
      This is useful when to segregate clients belonging to the same subnet
      into different address ranges.
      </p><p>
      The process of doing classification is conducted in several steps. The first step
      is to assess an incoming packet and assign it to zero or more classes.  The
      second step is to choose a subnet, possibly based on the class information.
      The third step is to assign classes from host reservations and
      evaluate class expressions depending on the "KNOWN" class.
      After the list of required classes is built and each class of the list
      has its expression evaluated: when it returns true the packet is added
      as a member of the class.
      The last step is to assign options, again possibly based on the class
      information.
      More complete and detailed description is available in
      <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
      </p><p>
      There are two main methods of doing classification. The first is automatic and relies
      on examining the values in the vendor class options or existence of a
      host reservation. Information from these
      options is extracted and a class name is constructed from it and added to
      the class list for the packet. The second allows for specifying an expression
      that is evaluated for each packet. If the result is true the packet is
      a member of the class.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Care should be taken with client classification as it is easy for
        clients that do not meet class criteria to be denied any service altogether.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56743056"></a>8.2.15.1. Setting Fixed Fields in Classification</h4></div></div></div><p>
          It is possible to specify that clients belonging to a particular class
          should receive packets with specific values in certain fixed fields.
          In particular, three fixed fields are supported:
          <span class="command"><strong>next-server</strong></span> (that conveys an IPv4 address, which is
          set in the siaddr field), <span class="command"><strong>server-hostname</strong></span> (that
          conveys a server hostname, can be up to 64 bytes long and will be sent
          in the sname field) and <span class="command"><strong>boot-file-name</strong></span> (that
          conveys the configuration file, can be up to 128 bytes long and will
          be sent using file field).
        </p><p>
          Obviously, there are many ways to assign clients to specific classes,
          but for the PXE clients the client architecture type option (code 93)
          seems to be particularly suited to
          make the distinction. The following example checks if the client
          identifies itself as PXE device with architecture EFI x86-64, and
          sets several fields if it does. See
          <a class="ulink" href="https://tools.ietf.org/html/rfc4578#section-2.1" target="_top">Section 2.1 of RFC 4578</a>)
          or the documentation of your client for specific values.
        </p><pre class="screen">
"Dhcp4": {
    "client-classes": [
        {
            "name": "ipxe_efi_x64",
            "test": "option[93].hex == 0x0009",
            <strong class="userinput"><code>"next-server": "192.0.2.254",
            "server-hostname": "hal9000",
            "boot-file-name": "/dev/null"</code></strong>
        },
        ...
    ],
    ...
          }</pre><p>
            If there are multiple classes defined and an incoming packet is matched
            to multiple classes, the class which is evaluated first is used.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            In Kea versions prior to 1.4.0 the alphabetical order of class names was used.
            Starting from Kea 1.4.0 the classes are ordered as specified in the configuration.
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56750304"></a>8.2.15.2. Using Vendor Class Information in Classification</h4></div></div></div><p>
        The server checks whether an incoming packet includes the vendor class identifier
        option (60). If it does, the content of that option is prepended with
        "VENDOR_CLASS_", it is interpreted as a class. For example,
        modern cable modems will send this option with value "docsis3.0"
        and as a result the packet will belong to class "VENDOR_CLASS_docsis3.0".
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          Kea 1.0 and earlier versions performed special actions for
          clients that were in VENDOR_CLASS_docsis3.0. This is no longer the
          case in Kea 1.1 and later. In these versions the old behavior
          can be achieved by defining VENDOR_CLASS_docsis3.0 and setting
          its next-server and boot-file-name values appropriately.
        </p></div><p>
        This example shows a configuration using an automatically generated
        "VENDOR_CLASS_" class. The administrator of the network has
        decided that addresses from range 192.0.2.10 to 192.0.2.20 are
        going to be managed by the Dhcp4 server and only clients belonging to the
        docsis3.0 client class are allowed to use that pool.

        </p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            <strong class="userinput"><code>"client-class": "VENDOR_CLASS_docsis3.0"</code></strong>
        }
    ],
    ...
}</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp56755248"></a>8.2.15.3. Defining and Using Custom Classes</h4></div></div></div><p>
        The following example shows how to configure a class using an expression
        and a subnet that makes use of the class. This configuration defines the
        class named "Client_foo".
        It is comprised of all clients who's client ids (option 61) start with the
        string "foo". Members of this class will be given addresses from
        192.0.2.10 to 192.0.2.20 and the addresses of their DNS servers
        set to 192.0.2.1 and 192.0.2.2.

          </p><pre class="screen">
"Dhcp4": {
    "client-classes": [
        {<strong class="userinput"><code>
            "name": "Client_foo",
            "test": "substring(option[61].hex,0,3) == 'foo'",
            "option-data": [
                {
                    "name": "domain-name-servers",
                    "code": 6,
                    "space": "dhcp4",
                    "csv-format": true,
                    "data": "192.0.2.1, 192.0.2.2"
                }
            ]</code></strong>
        },
        ...
    ],
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            <strong class="userinput"><code>"client-class": "Client_foo"</code></strong>
        },
        ...
    ],
    ...
}</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcp4-required-class"></a>8.2.15.4. Required Classification</h4></div></div></div><p>
        In some cases it is useful to limit the scope of a class to
        a shared-network, subnet or pool. There are two parameters
        which are used to limit the scope of the class by instructing
        the server to perform evaluation of test expressions when
        required.
        </p><p>
        The first one is the per-class <span class="command"><strong>only-if-required</strong></span>
        flag which is false by default. When it is set to
        <span class="command"><strong>true</strong></span> the test expression of the class is not
        evaluated at the reception of the incoming packet but later and
        only if the class evaluation is required.
        </p><p>
        The second is the <span class="command"><strong>require-client-classes</strong></span> which
        takes a list of class names and is valid in shared-network,
        subnet and pool scope. Classes in these lists are marked as
        required and evaluated after selection of this specific
        shared-network/subnet/pool and before output option processing.
        </p><p>
        In this example, a class is assigned to the incoming packet
        when the specified subnet is used.

        </p><pre class="screen">
"Dhcp4": {
    "client-classes": [
       {<strong class="userinput"><code>
           "name": "Client_foo",
           "test": "member('ALL')",
           "only-if-required": true</code></strong>
       },
       ...
    ],
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            <strong class="userinput"><code>"require-client-classes": [ "Client_foo" ],</code></strong>
            ...
        },
        ...
    ],
    ...
}</pre><p>
         </p><p>
         Required evaluation can be used to express complex dependencies,
         for example, subnet membership. It can also be used to reverse the
         precedence: if you set an option-data in a subnet it takes
         precedence over an option-data in a class. When you move the
         option-data to a required class and require it in
         the subnet, a class evaluated earlier may take precedence.
         </p><p>
         Required evaluation is also available at shared-network and
         pool levels. The order in which required classes are considered is:
         shared-network, subnet and pool, i.e. the opposite order
         option-data are processed.
         </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-ddns-config"></a>8.2.16. DDNS for DHCPv4</h3></div></div></div><p>
      As mentioned earlier, kea-dhcp4 can be configured to generate requests to the
      DHCP-DDNS server (referred to here as "D2" ) to update DNS entries.  These requests are known as
      NameChangeRequests or NCRs.  Each NCR contains the following information:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      Whether it is a request to add (update) or remove DNS entries
      </p></li><li class="listitem"><p>
      Whether the change requests forward DNS updates (A records), reverse
      DNS updates (PTR records), or both.
      </p></li><li class="listitem"><p>
      The FQDN, lease address, and DHCID
      </p></li></ol></div><p>
      The parameters for controlling the generation of NCRs for submission to D2
      are contained in the <span class="command"><strong>dhcp-ddns</strong></span> section of the kea-dhcp4 server
      configuration. The mandatory parameters for the DHCP DDNS configuration
      are <span class="command"><strong>enable-updates</strong></span> which is unconditionally
      required, and <span class="command"><strong>qualifying-suffix</strong></span> which has no
      default value and is required when <span class="command"><strong>enable-updates</strong></span>
      is set to <span class="command"><strong>true</strong></span>.

      The two (disabled and enabled) minimal DHCP DDNS configurations are:
</p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"enable-updates": false</code></strong>
    },
    ...
}
</pre><p>
      and for example:
</p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"enable-updates": true,
        "qualifying-suffix": "example."</code></strong>
    },
    ...
}
</pre><p>

      The default values for the "dhcp-ddns" section are as follows:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <span class="command"><strong>"server-ip": "127.0.0.1"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"server-port": 53001</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"sender-ip": ""</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"sender-port": 0</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"max-queue-size": 1024</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"ncr-protocol": "UDP"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"ncr-format": "JSON"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"override-no-update": false</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"override-client-update": false</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"replace-client-name": "never"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"generated-prefix": "myhost"</strong></span>
      </li></ul></div><p>
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv4-d2-io-config"></a>8.2.16.1. DHCP-DDNS Server Connectivity</h4></div></div></div><p>
      In order for NCRs to reach the D2 server, kea-dhcp4 must be able
      to communicate with it.  kea-dhcp4 uses the following configuration
      parameters to control this communication:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <span class="command"><strong>enable-updates</strong></span> - determines whether or not kea-dhcp4 will
      generate NCRs.  By default, this value is false hence DDNS updates are
      disabled.  To enable DDNS updates set this value to true:
      </li><li class="listitem">
      <span class="command"><strong>server-ip</strong></span> - IP address on which D2 listens for requests. The default is
      the local loopback interface at address 127.0.0.1. You may specify
      either an IPv4 or IPv6 address.
      </li><li class="listitem">
      <span class="command"><strong>server-port</strong></span> - port on which D2 listens for requests.  The default value
      is 53001.
      </li><li class="listitem">
      <span class="command"><strong>sender-ip</strong></span> - IP address which kea-dhcp4 should use to send requests to D2.
      The default value is blank which instructs kea-dhcp4 to select a suitable
      address.
      </li><li class="listitem">
      <span class="command"><strong>sender-port</strong></span> - port which kea-dhcp4 should use to send requests to D2. The
      default value of 0 instructs kea-dhcp4 to select a suitable port.
      </li><li class="listitem">
      <span class="command"><strong>max-queue-size</strong></span> - maximum number of requests allowed to queue waiting to
      be sent to D2. This value guards against requests accumulating
      uncontrollably if they are being generated faster than they can be
      delivered.  If the number of requests queued for transmission reaches
      this value, DDNS updating will be turned off until the queue backlog has
      been sufficiently reduced.  The intention is to allow the kea-dhcp4 server to
      continue lease operations without running the risk that its memory usage
      grows without limit.  The default value is 1024.
      </li><li class="listitem">
      <span class="command"><strong>ncr-protocol</strong></span> - socket protocol use when sending requests to D2.  Currently
      only UDP is supported.  TCP may be available in an upcoming release.
      </li><li class="listitem">
      <span class="command"><strong>ncr-format</strong></span> - packet format to use when sending requests to D2.
      Currently only JSON format is supported.  Other formats may be available
      in future releases.
      </li></ul></div><p>
      By default, kea-dhcp-ddns is assumed to be running on the same machine as kea-dhcp4, and
      all of the default values mentioned above should be sufficient.
      If, however, D2 has been configured to listen on a different address or
      port, these values must be altered accordingly. For example, if D2 has been
      configured to listen on 192.168.1.10 port 900, the following configuration
      would be required:
</p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"server-ip": "192.168.1.10",
        "server-port": 900</code></strong>,
        ...
    },
    ...
}
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv4-d2-rules-config"></a>8.2.16.2. When Does the kea-dhcp4 Server Generate DDNS Requests?</h4></div></div></div><p>kea-dhcp4 follows the behavior prescribed for DHCP servers in
      <a class="ulink" href="http://tools.ietf.org/html/rfc4702" target="_top">RFC 4702</a>.
      It is important to keep in mind that kea-dhcp4 provides the initial decision
      making of when and what to update and forwards that information to D2 in
      the form of NCRs. Carrying out the actual DNS updates and dealing with
      such things as conflict resolution are within the purview of D2 itself (<a class="xref" href="#dhcp-ddns-server" title="Chapter 11. The DHCP-DDNS Server">Chapter 11, <i>The DHCP-DDNS Server</i></a>).
      This section describes when kea-dhcp4 will generate NCRs and the
      configuration parameters that can be used to influence this decision.
      It assumes that the <span class="command"><strong>enable-updates</strong></span> parameter is true.
      </p><p>
      In general, kea-dhcp4 will generate DDNS update requests when:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      A new lease is granted in response to a DHCP REQUEST
      </p></li><li class="listitem"><p>
      An existing lease is renewed but the FQDN associated with it has
      changed.
      </p></li><li class="listitem"><p>
      An existing lease is released in response to a DHCP RELEASE
      </p></li></ol></div><p>
      In the second case, lease renewal, two  DDNS requests will be issued: one
      request to remove entries for the previous FQDN and a second request to
      add entries for the new FQDN.  In the last case, a lease release, a
      single DDNS request to remove its entries will be made.
      </p><p>
      The decision making involved when granting a new lease (the first case) is more
      involved.  When a new lease is granted, kea-dhcp4 will generate a DDNS
      update request if the DHCP REQUEST contains either the FQDN option
      (code 81) or the Host Name option (code 12). If both are present,
      the server will use the FQDN option. By default kea-dhcp4
      will respect the FQDN N and S flags specified by the client as shown
      in the following table:
      </p><div class="table"><a name="fqdn-flag-table"></a><p class="title"><b>Table 8.3. Default FQDN Flag Behavior</b></p><div class="table-contents"><table summary="Default FQDN Flag Behavior" border="1"><colgroup><col align="left" class="cflags"><col align="left" class="meaning"><col align="left" class="response"><col align="left" class="sflags"></colgroup><thead><tr><th align="left">Client Flags:N-S</th><th align="left">Client Intent</th><th align="left">Server Response</th><th align="left">Server Flags:N-S-O</th></tr></thead><tbody><tr><td align="left">0-0</td><td align="left">
                Client wants to do forward updates, server should do reverse updates
                </td><td align="left">Server generates reverse-only request</td><td align="left">1-0-0</td></tr><tr><td align="left">0-1</td><td align="left">Server should do both forward and reverse updates</td><td align="left">Server generates request to update both directions</td><td align="left">0-1-0</td></tr><tr><td align="left">1-0</td><td align="left">Client wants no updates done</td><td align="left">Server does not generate a request</td><td align="left">1-0-0</td></tr></tbody></table></div></div><br class="table-break"><p>
      The first row in the table above represents "client delegation". Here
      the DHCP client states that it intends to do the forward DNS updates and
      the server should do the reverse updates.  By default, kea-dhcp4 will honor
      the client's wishes and generate a DDNS request to the D2 server to update only
      reverse DNS data.  The parameter <span class="command"><strong>override-client-update</strong></span> can be used
      to instruct the server to override client delegation requests.  When
      this parameter is true, kea-dhcp4 will disregard requests for client
      delegation and generate a DDNS request to update both forward and
      reverse DNS data.  In this case, the N-S-O flags in the server's
      response to the client will be 0-1-1 respectively.
      </p><p>
      (Note that the flag combination N=1, S=1 is prohibited according to
      <a class="ulink" href="http://tools.ietf.org/html/rfc4702" target="_top">RFC 4702</a>. If such a
      combination is received from the client, the packet will be dropped by kea-dhcp4.)
      </p><p>
      To override client delegation, set the following values in the configuration file:
      </p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"override-client-update": true</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The third row in the table above describes the case in which the client
      requests that no DNS updates be done. The parameter, <span class="command"><strong>override-no-update</strong></span>,
      can be used to instruct the server to disregard the client's wishes. When
      this parameter is true, kea-dhcp4 will generate DDNS update requests to kea-dhcp-ddns
      even if the client requests that no updates be done.  The N-S-O flags in the
      server's response to the client will be 0-1-1.
      </p><p>
      To override client delegation, the following values should be set in your configuration:
      </p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"override-no-update": true</code></strong>,
        ...
    },
    ...
}
</pre><p>
      kea-dhcp4 will always generate DDNS update requests if the client request
      only contains the Host Name option. In addition it will include an FQDN
      option in the response to the client with the FQDN N-S-O flags set to
      0-1-0 respectively. The domain name portion of the FQDN option will be
      the name submitted to D2 in the DDNS update request.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv4-fqdn-name-generation"></a>8.2.16.3. kea-dhcp4 name generation for DDNS update requests</h4></div></div></div><p>Each NameChangeRequest must of course include the fully qualified domain
      name whose DNS entries are to be affected.  kea-dhcp4 can be configured to
      supply a portion or all of that name based upon what it receives from
      the client in the DHCP REQUEST.</p><p>
       The default rules for constructing the FQDN that will be used for DNS
       entries are:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        If the DHCPREQUEST contains the client FQDN option, the candidate name
        is taken from there, otherwise it is taken from the Host Name option.
      </p></li><li class="listitem"><p>
        If the candidate name is a partial (i.e. unqualified) name then add a
        configurable suffix to the name and use the result as the FQDN.
      </p></li><li class="listitem"><p>
        If the candidate name provided is empty, generate a FQDN using a
        configurable prefix and suffix.
      </p></li><li class="listitem"><p>
        If the client provided neither option, then no DNS action will be taken.
      </p></li></ol></div><p>
        These rules can amended by setting the
        <span class="command"><strong>replace-client-name</strong></span> parameter which provides the
        following modes of behavior:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <span class="command"><strong>never</strong></span> - Use the name the client sent.  If the client
        sent no name, do not generate one.  This is the default mode.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>always</strong></span> - Replace the name the client sent. If the
        client sent no name, generate one for the client.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>when-present</strong></span> - Replace the name the client sent.
        If the client sent no name, do not generate one.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>when-not-present</strong></span> - Use the name the client sent.
        If the client sent no name, generate one for the client.
      </p></li></ul></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    Note that formerly, this parameter was a boolean and permitted only values
    of <span class="command"><strong>true</strong></span> and <span class="command"><strong>false</strong></span>.  Boolean values
    have been deprecated and are no longer accepted.  If you are currently using
    booleans, you must replace them with the desired mode name. A value of
    <span class="command"><strong>true</strong></span> maps to <span class="command"><strong>"when-present"</strong></span>, while
    <span class="command"><strong>false</strong></span> maps to <span class="command"><strong>"never"</strong></span>.
        </p></div><p>

      For example, To instruct kea-dhcp4 to always generate the FQDN for a
      client, set the parameter <span class="command"><strong>replace-client-name</strong></span> to
      <span class="command"><strong>always</strong></span> as follows:
      </p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"replace-client-name": "always"</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The prefix used in the generation of a FQDN is specified by the
      <span class="command"><strong>generated-prefix</strong></span> parameter.  The default value is "myhost".  To alter
      its value, simply set it to the desired string:
      </p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"generated-prefix": "another.host"</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The suffix used when generating a FQDN or when qualifying a
      partial name is specified by
      the <span class="command"><strong>qualifying-suffix</strong></span> parameter. This
      parameter has no default value, thus it is mandatory when
      DDNS updates are enabled.
      To set its value simply set it to the desired string:
      </p><pre class="screen">
"Dhcp4": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"qualifying-suffix": "foo.example.org"</code></strong>,
        ...
    },
    ...
}
</pre><p>
      When generating a name, kea-dhcp4 will construct name of the format:
      </p><p>
        [generated-prefix]-[address-text].[qualifying-suffix].
      </p><p>
      where address-text is simply the lease IP address converted to a
      hyphenated string.  For example, if the lease address is 172.16.1.10,
      the qualifying suffix "example.com", and the default value is used for
      <span class="command"><strong>generated-prefix</strong></span>, the generated FQDN would be:
      </p><p>
        myhost-172-16-1-10.example.com.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-next-server"></a>8.2.17. Next Server (siaddr)</h3></div></div></div><p>In some cases, clients want to obtain configuration from a TFTP server.
      Although there is a dedicated option for it, some devices may use the siaddr field
      in the DHCPv4 packet for that purpose. That specific field can be configured
      using <span class="command"><strong>next-server</strong></span> directive. It is possible to define it in the global scope or
      for a given subnet only. If both are defined, the subnet value takes precedence.
      The value in subnet can be set to 0.0.0.0, which means that <span class="command"><strong>next-server</strong></span> should
      not be sent. It may also be set to an empty string, which means the same as if
      it was not defined at all, i.e. use the global value.
      </p><p>
      The <span class="command"><strong>server-hostname</strong></span> (that conveys a server hostname,
      can be up to 64 bytes long and will be sent in the sname field) and
      <span class="command"><strong>boot-file-name</strong></span> (that conveys the configuration file,
      can be up to 128 bytes long and will be sent using file field)
      directives are handled the same way as <span class="command"><strong>next-server</strong></span>.
      </p><pre class="screen">
"Dhcp4": {
    <strong class="userinput"><code>"next-server": "192.0.2.123",
    "boot-file-name": "/dev/null"</code></strong>,
    ...,
    "subnet4": [
        {
            <strong class="userinput"><code>"next-server": "192.0.2.234",
            "server-hostname": "some-name.example.org",
            "boot-file-name": "bootfile.efi"</code></strong>,
            ...
        }
    ]
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-echo-client-id"></a>8.2.18. Echoing Client-ID (RFC 6842)</h3></div></div></div><p>The original DHCPv4 specification
      (<a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>)
      states that the DHCPv4
      server must not send back client-id options when responding to
      clients. However, in some cases that confused clients that did
      not have MAC address or client-id; see
      <a class="ulink" href="http://tools.ietf.org/html/rfc6842" target="_top">RFC 6842</a>.
      for details. That
      behavior has changed with the publication of
      <a class="ulink" href="http://tools.ietf.org/html/rfc6842" target="_top">RFC 6842</a>
      which updated
      <a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>.
      That update states that the server must
      send client-id if the client sent it. That is Kea's default behavior.
      However, in some cases older devices that do not support
      <a class="ulink" href="http://tools.ietf.org/html/rfc6842" target="_top">RFC 6842</a>.
      may refuse to accept responses that include the
      client-id option. To enable backward compatibility, an optional
      configuration parameter has been introduced. To configure it,
      use the following configuration statement:</p><pre class="screen">
"Dhcp4": {
    <strong class="userinput"><code>"echo-client-id": false</code></strong>,
    ...
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-match-client-id"></a>8.2.19. Using Client Identifier and Hardware Address</h3></div></div></div><p>The DHCP server must be able to identify the client (and distinguish it from
      other clients) from which it receives the message. There are many reasons
      why this identification is required and the most important ones are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">When the client contacts the server to allocate a new
        lease, the server must store the client identification information in
        the lease database as a search key.</li><li class="listitem">When the client is trying to renew or release the existing
        lease, the server must be able to find the existing lease entry in the
        database for this client, using the client identification information as a
        search key.</li><li class="listitem">Some configurations use static reservations for the IP
        addresses and other configuration information. The server's administrator
        uses client identification information to create these static assignments.
        </li><li class="listitem">In the dual stack networks there is often a need to
        correlate the lease information stored in DHCPv4 and DHCPv6 server for
        a particular host. Using common identification information by the DHCPv4
        and DHCPv6 client allows the network administrator to achieve this
        correlation and better administer the network.</li></ul></div><p>
      </p><p>DHCPv4 makes use of two distinct identifiers which are placed
      by the client in the queries sent to the server and copied by the server
      to its responses to the client: "chaddr" and "client identifier". The
      former was introduced as a part of the BOOTP specification and it is also
      used by DHCP to carry the hardware address of the interface used to send
      the query to the server (MAC address for the Ethernet). The latter is
      carried in the Client-identifier option, introduced in
      <a class="ulink" href="http://tools.ietf.org/html/rfc2132" target="_top">RFC 2132</a>.
      </p><p><a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>
      indicates that the server may use both of these identifiers to identify
      the client but the "client identifier", if present, takes precedence
      over "chaddr". One of the reasons for this is that "client identifier"
      is independent from the hardware used by the client to communicate with
      the server. For example, if the client obtained the lease using one
      network card and then the network card is moved to another host, the
      server will wrongly identify this host is the one which has obtained
      the lease. Moreover,
      <a class="ulink" href="https://tools.ietf.org/html/rfc4361" target="_top">RFC 4361</a> gives
      the recommendation to use a DUID
      (see <a class="ulink" href="https://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>,
      the DHCPv6 specification)
      carried as "client identifier" when dual stack networks are in use
      to provide consistent identification information of the client, regardless
      of the protocol type it is using. Kea adheres to these specifications and
      the "client identifier" by default takes precedence over the value carried
      in "chaddr" field when the server searches, creates, updates or removes
      the client's lease.
      </p><p>When the server receives a DHCPDISCOVER or DHCPREQUEST message from the
      client, it will try to find out if the client already has a lease in the
      database and will hand out that lease rather than allocate
      a new one. Each lease in the lease database is associated with the
      "client identifier" and/or "chaddr". The server will first use the
      "client identifier" (if present) to search the lease. If the lease is
      found, the server will treat this lease as belonging to the client
      even if the current "chaddr" and the "chaddr" associated with
      the lease do not match. This facilitates the scenario when the network card
      on the client system has been replaced and thus the new MAC address
      appears in the messages sent by the DHCP client. If the server fails
      to find the lease using the "client identifier" it will perform another lookup
      using the "chaddr". If this lookup returns no result, the client is
      considered as not having a lease and the new lease will be created.
      </p><p>A common problem reported by network operators is that poor
      client implementations do not use stable client identifiers, instead
      generating a new "client identifier" each time the client connects
      to the network. Another well known case is when the client changes its
      "client identifier" during the multi-stage boot process (PXE). In such
      cases, the MAC address of the client's interface remains stable and
      using "chaddr" field to identify the client guarantees that the
      particular system is considered to be the same client, even though its
      "client identifier" changes.
      </p><p>To address this problem, Kea includes a configuration option
      which enables client identification using "chaddr" only by instructing
      the server to disregard server to "ignore" the "client identifier" during
      lease lookups and allocations for a particular subnet. Consider the following
      simplified server configuration:</p><pre class="screen">
"Dhcp4": {
    ...
    <strong class="userinput"><code>"match-client-id": true,</code></strong>
    ...
    "subnet4": [
    {
        "subnet": "192.0.10.0/24",
        "pools": [ { "pool": "192.0.2.23-192.0.2.87" } ],
        <strong class="userinput"><code>"match-client-id": false</code></strong>
    },
    {
        "subnet": "10.0.0.0/8",
        "pools": [ { "pool": "10.0.0.23-10.0.2.99" } ],
    }
    ]
}
</pre><p>The <span class="command"><strong>match-client-id</strong></span> is a boolean value which
     controls this behavior. The default value of <strong class="userinput"><code>true</code></strong>
     indicates that the server will use the "client identifier" for lease
     lookups and "chaddr" if the first lookup returns no results. The
     <span class="command"><strong>false</strong></span> means that the server will only
     use the "chaddr" to search for client's lease. Whether the DHCID for
     DNS updates is generated from the "client identifier" or "chaddr" is
     controlled through the same parameter accordingly.</p><p>The <span class="command"><strong>match-client-id</strong></span> parameter may appear
     both in the global configuration scope and/or under any subnet
     declaration. In the example shown above, the effective value of the
     <span class="command"><strong>match-client-id</strong></span> will be <strong class="userinput"><code>false</code></strong>
     for the subnet 192.0.10.0/24, because the subnet specific setting
     of the parameter overrides the global value of the parameter. The
     effective value of the <span class="command"><strong>match-client-id</strong></span> for the subnet
     10.0.0.0/8 will be set to <strong class="userinput"><code>true</code></strong> because the
     subnet declaration lacks this parameter and the global setting is
     by default used for this subnet. In fact, the global entry for this
     parameter could be omitted in this case, because
     <strong class="userinput"><code>true</code></strong> is the default value.
     </p><p>It is important to explain what happens when the client obtains
     its lease for one setting of the <span class="command"><strong>match-client-id</strong></span>
     and then renews when the setting has been changed. First consider
     the case when the client obtains the lease when the
     <span class="command"><strong>match-client-id</strong></span> is set to <strong class="userinput"><code>true</code></strong>.
     The server will store the lease information including "client identifier"
     (if supplied) and "chaddr" in the lease database. When the setting is
     changed and the client renews the lease the server will determine that
     it should use the "chaddr" to search for the existing lease. If the
     client hasn't changed its MAC address the server should successfully
     find the existing lease. The "client identifier" associated with the
     returned lease is ignored and the client is allowed to use this lease.
     When the lease is renewed only the "chaddr" is recorded for this
     lease according to the new server setting.
     </p><p>In the second case the client has the lease with only a "chaddr"
     value recorded. When the setting is changed to
     <span class="command"><strong>match-client-id</strong></span> set to <strong class="userinput"><code>true</code></strong>
     the server will first try to use the "client identifier" to find the
     existing client's lease. This will return no results because the
     "client identifier" was not recorded for this lease. The server will
     then use the "chaddr" and the lease will be found. If the lease appears
     to have no "client identifier" recorded, the server will assume that
     this lease belongs to the client and that it was created with the previous
     setting of the <span class="command"><strong>match-client-id</strong></span>.
     However, if the lease contains "client identifier" which is different
     from the "client identifier" used by the client the lease will be
     assumed to belong to another client and the new lease will be
     allocated.
     </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-dhcp4o6-config"></a>8.2.20. DHCPv4-over-DHCPv6: DHCPv4 Side</h3></div></div></div><p>
      The support of DHCPv4-over-DHCPv6 transport is described in
      <a class="ulink" href="http://tools.ietf.org/html/rfc7341" target="_top">RFC 7341</a>
      and is implemented using cooperating DHCPv4 and DHCPv6 servers.
      This section is about the configuration of the DHCPv4 side
      (the DHCPv6 side is described in <a class="xref" href="#dhcp6-dhcp4o6-config" title="9.2.22. DHCPv4-over-DHCPv6: DHCPv6 Side">Section 9.2.22, “DHCPv4-over-DHCPv6: DHCPv6 Side”</a>).
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>DHCPv4-over-DHCPv6 support is experimental and the
        details of the inter-process communication can change: both
        the DHCPv4 and DHCPv6 sides should be running the same version
        of Kea. For instance the support of port relay (RFC 8357) introduced
        such incompatible change.</p></div><p>
      The <span class="command"><strong>dhcp4o6-port</strong></span> global parameter specifies
      the first of the two consecutive ports of the UDP sockets used
      for the communication between the DHCPv6 and DHCPv4 servers
      (the DHCPv4 server is bound to ::1 on <span class="command"><strong>port</strong></span> + 1
      and connected to ::1 on <span class="command"><strong>port</strong></span>).
      </p><p>
      With DHCPv4-over-DHCPv6 the DHCPv4 server does not have access
      to several of the identifiers it would normally use to select a
      subnet.  In order to address this issue three new configuration
      entries have been added.  The presence of any of these allows the
      subnet to be used with DHCPv4-over-DHCPv6.  These entries are:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>4o6-subnet</strong></span>: Takes a prefix (i.e., an
        IPv6 address followed by a slash and a prefix length) which is
        matched against the source address.
        </li><li class="listitem"><span class="command"><strong>4o6-interface-id</strong></span>: Takes a relay interface
        ID option value.
        </li><li class="listitem"><span class="command"><strong>4o6-interface</strong></span>: Takes an interface name
        which is matched against the incoming interface name.
        </li></ul></div><p>
      </p><p>
      The following configuration was used during some tests:
</p><pre class="screen">
{

# DHCPv4 conf
"Dhcp4": {
    "interfaces-config": {
        "interfaces": [ "eno33554984" ]
    },

    "lease-database": {
        "type": "memfile",
        "name": "leases4"
    },

    "valid-lifetime": 4000,

    "subnet4": [ {
        "subnet": "10.10.10.0/24",
        <strong class="userinput"><code>"4o6-interface": "eno33554984",</code></strong>
        <strong class="userinput"><code>"4o6-subnet": "2001:db8:1:1::/64",</code></strong>
        "pools": [ { "pool": "10.10.10.100 - 10.10.10.199" } ]
    } ],

    <strong class="userinput"><code>"dhcp4o6-port": 6767</code></strong>

},

"Logging": {
    "loggers": [ {
        "name": "kea-dhcp4",
        "output_options": [ {
            "output": "/tmp/kea-dhcp4.log"
        } ],
        "severity": "DEBUG",
        "debuglevel": 0
    } ]
}

}
</pre><p>
    </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="host-reservation-v4"></a>8.3. Host Reservation in DHCPv4</h2></div></div></div><p>There are many cases where it is useful to provide a configuration on
    a per host basis. The most obvious one is to reserve a specific, static
    address for exclusive use by a given client (host) ‐ the returning client will
    receive the same address from the server every time, and other clients will
    generally not receive that address.
    Another example when the host reservations are applicable is when a host
    has specific requirements, e.g. a printer that needs additional DHCP options.
    Yet another possible use case is to define unique names for hosts.</p><p>Note that there may be cases when the
    new reservation has been made for the client for the address being currently
    in use by another client. We call this situation a "conflict". The conflicts
    get resolved automatically over time as described in subsequent sections.
    Once the conflict is resolved, the client will keep receiving the reserved
    configuration when it renews.</p><p>Host reservations are defined as parameters for each subnet. Each host
    has to be identified by an identifier, for example the hardware/MAC address. There is an optional
    <span class="command"><strong>reservations</strong></span> array in the <span class="command"><strong>Subnet4</strong></span>
    element. Each element in that array is a structure that holds information
    about reservations for a single host. In particular, the structure has
    to have an identifier that uniquely identifies a host.  In the DHCPv4 context, the
    identifier is usually a hardware or MAC address.  In most cases an IP address
    will be specified. It is also possible to specify a hostname, host
    specific options or fields carried within DHCPv4 message such as siaddr,
    sname or file.</p><p>In Kea 1.0.0 it was only possible to create host reservations
    using client's hardware address. Host reservations by client
    identifier, DUID and circuit-id have been added in Kea 1.1.0.</p><p>The following example shows how to reserve addresses for specific
    hosts:

</p><pre class="screen">
"subnet4": [
    {
        "pools": [ { "pool":  "192.0.2.1 - 192.0.2.200" } ],
        "subnet": "192.0.2.0/24",
        "interface": "eth0",
        <strong class="userinput"><code>"reservations": [
            {
                "hw-address": "1a:1b:1c:1d:1e:1f",
                "ip-address": "192.0.2.202"
            },
            {
                "duid": "0a:0b:0c:0d:0e:0f",
                "ip-address": "192.0.2.100",
                "hostname": "alice-laptop"
            },
            {
                "circuit-id": "'charter950'",
                "ip-address": "192.0.2.203"
            },
            {
                "client-id": "01:11:22:33:44:55:66",
                "ip-address": "192.0.2.204"
            }
        ]</code></strong>
    }
]
</pre><p>
    The first entry reserves the 192.0.2.202 address for the client that uses
    a MAC address of 1a:1b:1c:1d:1e:1f. The second entry reserves the address
    192.0.2.100 and the hostname of alice-laptop for the client using a DUID
    0a:0b:0c:0d:0e:0f. (Note that if you plan to do DNS updates, it
    is strongly recommended for the hostnames to be unique.) The third
    example reserves address 192.0.3.203 to a client whose request
    would be relayed by a relay agent that inserts a circuit-it option
    with the value 'charter950'. The fourth entry reserves address
    192.0.2.204 for a client that uses a client identifier with value
    01:11:22:33:44:55:66.</p><p>The above example is used for illustrational purposes only
    and in actual deployments it is recommended to use as few types as possible
    (preferably just one). See <a class="xref" href="#reservations4-tuning" title="8.3.8. Fine Tuning DHCPv4 Host Reservation">Section 8.3.8, “Fine Tuning DHCPv4 Host Reservation”</a> for a detailed
    discussion of this point.</p><p>Making a reservation for a mobile host that may visit multiple subnets
    requires a separate host definition in each subnet it is expected to visit.
    It is not allowed to define multiple host definitions with the same hardware
    address in a single subnet. Multiple host definitions with the same hardware
    address are valid if each is in a different subnet.
    </p><p>Adding host reservation incurs a performance penalty. In principle,
    when a server that does not support host reservation responds to a query,
    it needs to check whether there is a lease for a given address being
    considered for allocation or renewal. The server that also supports host
    reservation has to perform additional checks: not only if the address is
    currently used (i.e. if there is a lease for it), but also whether the address
    could be used by someone else (i.e. there is a reservation for it). That
    additional check incurs additional overhead.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-types"></a>8.3.1. Address Reservation Types</h3></div></div></div><p>In a typical scenario there is an IPv4 subnet defined,
      e.g. 192.0.2.0/24, with certain part of it dedicated for dynamic allocation
      by the DHCPv4 server. That dynamic part is referred to as a dynamic pool or
      simply a pool. In principle, a host reservation can reserve any address
      that belongs to the subnet. The reservations that specify addresses that
      belong to configured pools are called "in-pool reservations".
      In contrast, those that do not belong to dynamic pools are called
      "out-of-pool reservations". There is no formal difference
      in the reservation syntax and both reservation types are
      handled uniformly. However, upcoming releases may offer improved performance
      if there are only out-of-pool reservations as the server will be able
      to skip reservation checks when dealing with existing leases. Therefore,
      system administrators are encouraged to use out-of-pool reservations if
      possible.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-conflict"></a>8.3.2. Conflicts in DHCPv4 Reservations</h3></div></div></div><p>As the reservations and lease information are stored separately,
      conflicts may arise. Consider the following series of events. The server
      has configured the dynamic pool of addresses from the range of 192.0.2.10 to
      192.0.2.20. Host A requests an address and gets 192.0.2.10. Now the system
      administrator decides to reserve address 192.0.2.10 for Host B.
      In general, reserving an address that
      is currently assigned to someone else is not recommended, but there are
      valid use cases where such an operation is warranted.</p><p>The server now has a conflict to resolve. Let's analyze the
      situation here. If Host B boots up and requests an address, the server is
      not able to assign the reserved address 192.0.2.10. A naive approach
      would to be immediately remove the existing lease for the Host A
      and create a new one for the Host B. That would not solve the problem,
      though, because as soon as the Host B gets the address, it will detect
      that the address is already in use by the Host A and would send
      the DHCPDECLINE message. Therefore, in this situation, the server has
      to temporarily assign a different address (not matching what has been
      reserved) to the Host B.</p><p>When Host A renews its address, the server will discover that
      the address being renewed is now reserved for another host - Host
      B. Therefore the server will inform the Host A that it is no longer
      allowed to use it by sending a DHCPNAK message. The server will not remove the
      lease, though, as there's small chance that the DHCPNAK may be lost if the
      network is lossy. If that happens, the client will not receive any
      responses, so it will retransmit its DHCPREQUEST packet. Once the
      DHCPNAK is received by Host A, it will revert to the server
      discovery and will eventually get a different address. Besides
      allocating a new lease, the server will also remove the old one. As
      a result, address 192.0.2.10 will become free . When Host B
      tries to renew its temporarily assigned address, the server will detect
      that it has a valid lease, but there is a reservation for a different
      address. The server will send DHCPNAK to inform Host B that its address
      is no longer usable, but will keep its lease (again, the DHCPNAK may be
      lost, so the server will keep it, until the client returns for a new
      address). Host B will revert to the server discovery phase and will
      eventually send a DHCPREQUEST message. This time the server will find
      out that there is a reservation for that host and the reserved address
      192.0.2.10 is not used, so it will be granted. It will also remove the
      lease for the temporarily assigned address that Host B previously
      obtained.</p><p>This recovery will succeed, even if other hosts will attempt to get
      the reserved address. Had the Host C requested address 192.0.2.10 after
      the reservation was made, the server will either offer a different
      address (when responding to DHCPDISCOVER) or would send DHCPNAK
      (when responding to DHCPREQUEST).</p><p>This recovery mechanism allows the server to fully recover from a
      case where reservations conflict with the existing leases. This procedure
      takes time and will roughly take as long as the value set for of renew-timer.
      The best way to avoid such recovery is to not define new reservations that
      conflict with existing leases. Another recommendation is to use
      out-of-pool reservations. If the reserved address does not belong to a
      pool, there is no way that other clients could get this address.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-hostname"></a>8.3.3. Reserving a Hostname</h3></div></div></div><p>When the reservation for a client includes the <span class="command"><strong>hostname</strong></span>,
      the server will return this hostname to the client in
      the Client FQDN or Hostname options. The server responds with the Client
      FQDN option only if the client has included Client FQDN option in its
      message to the server. The server will respond with the Hostname option
      if the client included Hostname option in its message to the server
      or when the client requested Hostname option using Parameter Request
      List option. The server will return the Hostname option even if it is not
      configured to perform DNS updates. The reserved hostname always takes
      precedence over the hostname supplied by the client or the autogenerated
      (from the IPv4 address) hostname.</p><p>The server qualifies the reserved hostname with the value
      of the <span class="command"><strong>qualifying-suffix</strong></span> parameter. For example, the
      following subnet configuration:
</p><pre class="screen">
    {
        "subnet4": [ {
            "subnet": "10.0.0.0/24",
            "pools": [ { "pool": "10.0.0.10-10.0.0.100" } ],
            "reservations": [
               {
                 "hw-address": "aa:bb:cc:dd:ee:ff",
                 "hostname": "alice-laptop"
               }
            ]
         }],
        "dhcp-ddns": {
            "enable-updates": true,
            "qualifying-suffix": "example.isc.org."
        }
    }
</pre><p>
      will result in assigning the "alice-laptop.example.isc.org." hostname to the
      client using the MAC address "aa:bb:cc:dd:ee:ff". If the <span class="command"><strong>qualifying-suffix
      </strong></span> is not specified, the default (empty) value will be used, and
      in this case the value specified as a <span class="command"><strong>hostname</strong></span> will
      be treated as fully qualified name. Thus, by leaving the
      <span class="command"><strong>qualifying-suffix</strong></span> empty it is possible to qualify
      hostnames for the different clients with different domain names:
</p><pre class="screen">
    {
        "subnet4": [ {
            "subnet": "10.0.0.0/24",
            "pools": [ { "pool": "10.0.0.10-10.0.0.100" } ],
            "reservations": [
               {
                 "hw-address": "aa:bb:cc:dd:ee:ff",
                 "hostname": "alice-laptop.isc.org."
               },
               {
                 "hw-address": "12:34:56:78:99:AA",
                 "hostname": "mark-desktop.example.org."
               }

            ]
         }],
        "dhcp-ddns": {
            "enable-updates": true,
        }
    }
</pre><p>

      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-options"></a>8.3.4. Including Specific DHCPv4 Options in Reservations</h3></div></div></div><p>Kea 1.1.0 introduced the ability to specify options on a
      per host basis. The options follow the same rules as any other
      options. These can be standard options (see <a class="xref" href="#dhcp4-std-options" title="8.2.8. Standard DHCPv4 Options">Section 8.2.8, “Standard DHCPv4 Options”</a>), custom options (see <a class="xref" href="#dhcp4-custom-options" title="8.2.9. Custom DHCPv4 options">Section 8.2.9, “Custom DHCPv4 options”</a>) or vendor specific options
      (see <a class="xref" href="#dhcp4-vendor-opts" title="8.2.11. DHCPv4 Vendor Specific Options">Section 8.2.11, “DHCPv4 Vendor Specific Options”</a>). The following
      example demonstrates how standard options can be defined.</p><pre class="screen">
{
    "subnet4": [ {
        "reservations": [
        {
            "hw-address": "aa:bb:cc:dd:ee:ff",
            "ip-address": "192.0.2.1",
            <strong class="userinput"><code>"option-data": [
            {
                "name": "cookie-servers",
                "data": "10.1.1.202,10.1.1.203"
            },
            {
                "name": "log-servers",
                "data": "10.1.1.200,10.1.1.201"
            } ]</code></strong>
        } ]
    } ]
}</pre><p>Vendor specific options can be reserved in a similar manner:</p><pre class="screen">
{
    "subnet4": [ {
        "reservations": [
        {
            "hw-address": "aa:bb:cc:dd:ee:ff",
            "ip-address": "10.0.0.7",
            <strong class="userinput"><code>"option-data": [
            {
                "name": "vivso-suboptions",
                "data": "4491"
            },
            {
                "name": "tftp-servers",
                "space": "vendor-4491",
                "data": "10.1.1.202,10.1.1.203"
            } ]</code></strong>
        } ]
    } ]
}</pre><p>
 Options defined on host level have the highest priority. In other words,
 if there are options defined with the same type on global, subnet, class and
 host level, the host specific values will be used.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-message-fields"></a>8.3.5. Reserving Next Server, Server Hostname and Boot File Name</h3></div></div></div><p>BOOTP/DHCPv4 messages include "siaddr", "sname" and "file" fields.
      Even though, DHCPv4 includes corresponding options, such as option 66 and
      option 67, some clients may not support these options. For this reason, server
      administrators often use the "siaddr", "sname" and "file" fields instead.</p><p>With Kea, it is possible to make static reservations for these DHCPv4
      message fields:</p><pre class="screen">
{
    "subnet4": [ {
        "reservations": [
        {
            "hw-address": "aa:bb:cc:dd:ee:ff",
            <strong class="userinput"><code>"next-server": "10.1.1.2",
            "server-hostname": "server-hostname.example.org",
            "boot-file-name": "/tmp/bootfile.efi"</code></strong>
        } ]
    } ]
}</pre><p>Note that those parameters can be specified in combination with
    other parameters for a reservation, e.g. reserved IPv4 address. These
    parameters are optional, i.e. a subset of them can specified, or all of
    them can be omitted.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation4-client-classes"></a>8.3.6. Reserving Client Classes in DHCPv4</h3></div></div></div><p><a class="xref" href="#classification-using-expressions" title="13.3. Using Expressions In Classification">Section 13.3, “Using Expressions In Classification”</a> explains how
      to configure the server to assign classes to a client based on the content
      of the options that this client sends to the server. Host reservations
      mechanisms also allow for statically assigning classes to the clients.
      The definitions of these classes should exist in the Kea
      configuration. The following configuration snippet shows how to specify
      that a client belongs to classes <span class="command"><strong>reserved-class1</strong></span>
      and <span class="command"><strong>reserved-class2</strong></span>. Those classes are associated with
      specific options being sent to the clients which belong to them.
      </p><pre class="screen">
{
    "client-classes": [
    {
       "name": "reserved-class1",
       "option-data": [
       {
           "name": "routers",
           "data": "10.0.0.200"
       }
       ]
    },
    {
       "name": "reserved-class2",
       "option-data": [
       {
           "name": "domain-name-servers",
           "data": "10.0.0.201"
       }
       ]
    }
    ],
    "subnet4": [ {
        "subnet": "10.0.0.0/24",
        "pools": [ { "pool": "10.0.0.10-10.0.0.100" } ],
        "reservations": [
        {
            "hw-address": "aa:bb:cc:dd:ee:ff",
            <strong class="userinput"><code>
            "client-classes": [ "reserved-class1", "reserved-class2" ]
            </code></strong>
        }
        ]
    } ]
}

</pre><p>Static class assignments, as shown above, can be used in conjunction
    with classification using expressions. The "KNOWN" builtin class is
    added to the packet and any class depending on it directly or indirectly
    and not only-if-required is evaluated.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you want to force the evaluation of a class expression after
     the host reservation lookup, for instance because of a dependency on
     "reserved-class1" from the previous example, you should add a
     "member('KNOWN')" in the expression.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservations4-mysql-pgsql-cql"></a>8.3.7. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</h3></div></div></div><p>
        It is possible to store host reservations in MySQL, PostgreSQL or Cassandra. See
        <a class="xref" href="#hosts6-storage" title="9.2.3. Hosts Storage">Section 9.2.3, “Hosts Storage”</a> for information on how to configure Kea to use
        reservations stored in MySQL, PostgreSQL or Cassandra. Kea provides dedicated hook for
        managing reservations in a database, section <a class="xref" href="#host-cmds" title="14.4.4. host_cmds: Host Commands">Section 14.4.4, “host_cmds: Host Commands”</a> provide
        detailed information. <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/HostReservationsHowTo" target="_top">http://kea.isc.org/wiki/HostReservationsHowTo</a></code>
        provides some examples how to conduct common host reservation operations.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In Kea maximum length of an option specified per host is
      arbitrarily set to 4096 bytes.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservations4-tuning"></a>8.3.8. Fine Tuning DHCPv4 Host Reservation</h3></div></div></div><p>The host reservation capability introduces additional restrictions for the
      allocation engine (the component of Kea that selects an address for a client)
      during lease selection and renewal. In particular, three
      major checks are necessary. First, when selecting a new lease, it is not
      sufficient for a candidate lease to not be used by another DHCP client. It
      also must not be reserved for another client. Second, when renewing a lease,
      additional check must be performed whether the address being renewed is not
      reserved for another client. Finally, when a host renews an address, the server
      has to check whether there is a reservation for this host, so the existing
      (dynamically allocated) address should be revoked and the reserved one be
      used instead.
      </p><p>Some of those checks may be unnecessary in certain deployments and not
      performing them may improve performance. The Kea server provides the
      <span class="command"><strong>reservation-mode</strong></span> configuration parameter to select the
      types of reservations allowed for the particular subnet. Each reservation
      type has different constraints for the checks to be performed by the
      server when allocating or renewing a lease for the client.
      Allowed values are:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"> <span class="command"><strong>all</strong></span> - enables all host reservation
      types. This is the default value. This setting is the safest and the most
      flexible. It allows in-pool and out-of-pool reservations. As all checks
      are conducted, it is also the slowest.
      </li><li class="listitem"> <span class="command"><strong>out-of-pool</strong></span> - allows only out of
      pool host reservations.  With this setting in place, the server may assume
      that all host reservations are for addresses that do not belong to the
      dynamic pool. Therefore it can skip the reservation checks when dealing
      with in-pool addresses, thus improving performance. Do not use this mode
      if any of your reservations use in-pool address. Caution is advised when
      using this setting: Kea does not sanity check the reservations against
      <span class="command"><strong>reservation-mode</strong></span> and misconfiguration may cause problems.
      </li><li class="listitem">
      <span class="command"><strong>disabled</strong></span> - host reservation support is disabled. As there
      are no reservations, the server will skip all checks. Any reservations defined
      will be completely ignored. As the checks are skipped, the server may
      operate faster in this mode.
      </li></ul></div><p>
      </p><p>
        An example configuration that disables reservation looks like follows:
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
    {
        "subnet": "192.0.2.0/24",
        <strong class="userinput"><code>"reservation-mode": "disabled"</code></strong>,
        ...
    }
    ]
}
</pre><p>
      </p><p>Another aspect of the host reservations are the different types of
      identifiers. Kea 1.1.0 supports four types of identifiers
      (hw-address, duid, client-id and circuit-id), but more identifier types
      are likely to be added in the future. This is beneficial from a
      usability perspective. However, there is a drawback. For each incoming
      packet Kea has to to extract each identifier type and then query the
      database to see if there is a reservation done by this particular
      identifier. If nothing is found, the next identifier is extracted and the next
      query is issued. This process continues until either a reservation is
      found or all identifier types have been checked. Over time with an increasing
      number of supported identifier types, Kea would become slower and
      slower.</p><p>To address this problem, a parameter called
      <span class="command"><strong>host-reservation-identifiers</strong></span> has been introduced. It
      takes a list of identifier types as a parameter. Kea will check only those
      identifier types enumerated in host-reservation-identifiers. From a
      performance perspective the number of identifier types should be kept to a
      minimum, ideally limited to one. If your deployment uses several
      reservation types, please enumerate them from most to least frequently
      used as this increases the chances of Kea finding the reservation using the
      fewest number of queries. An example of host reservation identifiers looks
      as follows:

</p><pre class="screen">
<strong class="userinput"><code>"host-reservation-identifiers": [ "circuit-id", "hw-address", "duid", "client-id" ],</code></strong>
"subnet4": [
    {
        "subnet": "192.0.2.0/24",
        ...
    }
]</pre><p>
</p><p>
If not specified, the default value is:
</p><pre class="screen">
<strong class="userinput"><code>"host-reservation-identifiers": [ "hw-address", "duid", "circuit-id", "client-id" ]</code></strong>
</pre><p>


</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shared-network4"></a>8.4. Shared networks in DHCPv4</h2></div></div></div><p>DHCP servers use subnet information in two ways. First, it is used
    to determine the point of attachment, or simply put, where the client is
    connected to the network. Second, the subnet information is used to group
    information pertaining to specific location in the network. This approach
    works well in general case, but the are scenarios where the boundaries are
    blurred. Sometimes it is useful to have more than one logical IP subnet
    being deployed on the same physical link. The need to understand
    that two or more subnets are used on the same link requires additional logic
    in the DHCP server. This capability has been added in Kea 1.3.0. It is
    called "shared networks" in Kea and ISC DHCP projects. It is sometimes also
    called "shared subnets". In Microsoft's nomenclature it is called "multinet".
    </p><p>There are many use cases where the feature is useful. This paragraph
    explains just a handful of the most common ones. The first and by far the most
    common use case is an existing network that has grown and is running out of
    available address space. Rather than migrating all devices to a new, larger
    subnet, it is easier to simply configure additional subnet on top of the
    existing one. Sometimes, due to address space fragmentation (e.g. only many
    disjoint /24s are available) this is the only choice. Also, configuring
    additional subnet has the advantage of not disrupting the operation of
    existing devices.</p><p>Another very frequent use case comes from cable networks. There are two types
    of devices in cable networks: cable modems and the end user devices behind
    them. It is a common practice to use different subnet for cable modems to
    prevent users from tinkering with their cable modems. In this case, the
    distinction is based on the type of device, rather than address space
    exhaustion.</p><p>A client connected to a shared network may be assigned an address from
    any of the address pools defined within the subnets belonging to the shared
    network. Internally, the server selects one of the subnets belonging to a
    shared network and tries to allocate an address from this subnet. If the
    server is unable to allocate an address from the selected subnet (e.g. due
    to address pools exhaustion) it will use another subnet from the same shared
    network and try to allocate an address from this subnet etc. Therefore, in the
    typical case, the server will allocate all addresses available for a given
    subnet before it starts allocating addresses from other subnets belonging to
    the same shared network. However, in certain situations the client can be
    allocated an address from the other subnets before the address pools in the
    first subnet get exhausted, e.g. when the client provides a hint that
    belongs to another subnet or the client has reservations in a different than
    default subnet.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is strongly discouraged for the Kea deployments to assume that the
      server doesn't allocate addresses from other subnets until it uses all
      the addresses from the first subnet in the shared network. Apart from the
      fact that hints, host reservations and client classification affect subnet
      selection, it is also foreseen that we will enhance allocation strategies
      for shared networks in the future versions of Kea, so as the selection
      of subnets within a shared network is equally probable (unpredictable).</p></div><p>In order to define a shared network an additional configuration scope
    is introduced:
</p><pre class="screen">
{
"Dhcp4": {
    <strong class="userinput"><code>"shared-networks": [
        {
            // Name of the shared network. It may be an arbitrary string
            // and it must be unique among all shared networks.
            "name": "my-secret-lair-level-1",

            // Subnet selector can be specifed on the shared network level.
            // Subnets from this shared network will be selected for directly
            // connected clients sending requests to server's "eth0" interface.
            "interface": "eth0",

            // This starts a list of subnets in this shared network.
            // There are two subnets in this example.
            "subnet4": [
                {
                    "subnet": "10.0.0.0/8",
                    "pools": [ { "pool":  "10.0.0.1 - 10.0.0.99" } ],
                },
                {
                    "subnet": "192.0.2.0/24",
                    "pools": [ { "pool":  "192.0.2.100 - 192.0.2.199" } ]
                }
            ],
        } ]</code></strong>, // end of shared-networks

    // It is likely that in your network you'll have a mix of regular,
    // "plain" subnets and shared networks. It is perfectly valid to mix
    // them in the same config file.
    //
    // This is regular subnet. It's not part of any shared-network.
    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [ { "pool":  "192.0.3.1 - 192.0.3.200" } ],
            "interface": "eth1"
        }
    ]

} // end of Dhcp4
}
</pre><p>
    </p><p>As you see in the example, it is possible to mix shared and regular
    ("plain") subnets. Each shared network must have a unique name. This is
    similar to ID for subnets, but gives you more flexibility. This is used
    for logging, but also internally for identifying shared networks.</p><p>In principle it makes sense to define only shared networks that
    consist of two or more subnets. However, for testing purposes it is allowed
    to define a shared network with just one subnet or even an empty one.  This
    is not a recommended practice in production networks, as the shared network
    logic requires additional processing and thus lowers server's performance.
    To avoid unnecessary performance degradation the shared subnets should only
    be defined when required by the deployment.
    </p><p>Shared networks provide an ability to specify many parameters in
    the shared network scope that will apply to all subnets within it. If
    necessary, you can specify a parameter on the shared network scope and then
    override its value in the subnet scope. For example:
</p><pre class="screen">
"shared-networks": [
    {
        "name": "lab-network3",

        "interface": "eth0",

        // This applies to all subnets in this shared network, unless
        // values are overridden on subnet scope.
        <strong class="userinput"><code>"valid-lifetime": 600</code></strong>,

        // This option is made available to all subnets in this shared
        // network.
        <strong class="userinput"><code>"option-data": [ {
            "name": "log-servers",
            "data": "1.2.3.4"
        } ]</code></strong>,

        "subnet4": [
            {
                "subnet": "10.0.0.0/8",
                "pools": [ { "pool":  "10.0.0.1 - 10.0.0.99" } ],

                // This particular subnet uses different values.
                <strong class="userinput"><code>"valid-lifetime": 1200,
                "option-data": [
                {
                    "name": "log-servers",
                    "data": "10.0.0.254"
                },
                {
                    "name": "routers",
                    "data": "10.0.0.254"
                } ]</code></strong>
            },
            {
                 "subnet": "192.0.2.0/24",
                 "pools": [ { "pool":  "192.0.2.100 - 192.0.2.199" } ],

                 // This subnet does not specify its own valid-lifetime value,
                 // so it is inherited from shared network scope.
                 <strong class="userinput"><code>"option-data": [
                 {
                     "name": "routers",
                     "data": "192.0.2.1"
                 } ]</code></strong>
            }
        ]
    } ]</pre><p>
    In this example, there is a log-servers option defined that is available to
    clients in both subnets in this shared network. Also, a valid lifetime is
    set to 10 minutes (600s). However, the first subnet overrides some of the values
    (valid lifetime is 20 minutes, different IP address for log-servers), but
    also adds its own option (router address). Assuming a client asking for
    router and log servers options is assigned a lease from this subnet, he will
    get a lease for 20 minutes and log-servers and routers value of 10.0.0.254.
    If the same client is assigned to the second subnet, he will get a 10
    minutes long lease, log-servers value of 1.2.3.4 and routers set to 192.0.2.1.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp56996800"></a>8.4.1. Local and relayed traffic in shared networks</h3></div></div></div><p>It is possible to specify interface name in the shared network scope to
    tell the server that this specific shared network is reachable directly (not
    via relays) using local network interface. It is sufficient to specify
    it once on the shared network level. As all subnets in a shared network are
    expected to be used on the same physical link, it is a configuration error
    to attempt to define a shared network using subnets that are reachable over
    different interfaces. It is allowed to specify interface parameter on each
    subnet, although its value must be the same for each subnet. Thus it's
    usually more convenient to specify it once on the shared network level.
</p><pre class="screen">
"shared-networks": [
    {
        "name": "office-floor-2",

        // This tells Kea that the whole shared networks is reachable over
        // local interface. This applies to all subnets in this network.
        <strong class="userinput"><code>"interface": "eth0"</code></strong>,

        "subnet4": [
            {
                "subnet": "10.0.0.0/8",
                "pools": [ { "pool":  "10.0.0.1 - 10.0.0.99" } ],
                <strong class="userinput"><code>"interface": "eth0"</code></strong>
            },
            {
                 "subnet": "192.0.2.0/24",
                 "pools": [ { "pool":  "192.0.2.100 - 192.0.2.199" } ]

                 // Specifying a different interface name is configuration
                 // error:
                 // "interface": "eth1"
            }
        ]
    } ]
</pre><p>
</p><p>Somewhat similar to interface names, also relay IP addresses can be
specified for the whole shared network. However, depending on your relay
configuration, it may use different IP addresses depending on which subnet
is being used. Thus there is no requirement to use the same IP relay address
for each subnet. Here's an example:

</p><pre class="screen">
"shared-networks": [
    {
        "name": "kakapo",
        <strong class="userinput"><code>"relay": {
            "ip-addresses": [ "192.3.5.6" ]
        }</code></strong>,
        "subnet4": [
            {
                "subnet": "192.0.2.0/26",
                <strong class="userinput"><code>"relay": {
                    "ip-addresses": [ "192.1.1.1" ]
                }</code></strong>,
                "pools": [ { "pool": "192.0.2.63 - 192.0.2.63" } ]
            },
            {
                "subnet": "10.0.0.0/24",
                <strong class="userinput"><code>"relay": {
                    "ip-addresses": [ "192.2.2.2" ]
                }</code></strong>,
                "pools": [ { "pool": "10.0.0.16 - 10.0.0.16" } ]
            }
        ]
    }
]</pre><p>
In this particular case the relay IP address specified on network level doesn't
have much sense, as it is overridden in both subnets, but it was left there
as an example of how one could be defined on network level. Note that the
relay agent IP address typically belongs to the subnet it relays packets from,
but this is not a strict requirement. Therefore Kea accepts any value here
as long as it is valid IPv4 address.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57004464"></a>8.4.2. Client classification in shared networks</h3></div></div></div><p>Sometimes it is desired to segregate clients into specific subnets
      based on some properties. This mechanism is called client classification
      and is described in <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>. Client classification
      can be applied to subnets belonging to shared networks in the same way
      as it is used for subnets specified outside of shared networks.
      It is important to understand how the server selects subnets for
      the clients when client classification is in use, to assure that the
      desired subnet is selected for a given client type.</p><p>If a subnet is associated with some classes, only the clients
      belonging to any of these classes can use this subnet. If there are no
      classes specified for a subnet, any client connected to a given shared
      network can use this subnet. A common mistake is to assume that the
      subnet including client classes is preferred over subnets without
      client classes. Consider the following example:

</p><pre class="screen">
{
    "client-classes": [
        {
            "name": "b-devices",
            "test": "option[93].hex == 0x0002"
        }
    ],
    "shared-networks": [
        {
            "name": "galah",
            "interface": "eth0",
            "subnet4": [
                {
                    "subnet": "192.0.2.0/26",
                    "pools": [ { "pool": "192.0.2.1 - 192.0.2.63" } ],
                },
                {
                    "subnet": "10.0.0.0/24",
                    "pools": [ { "pool": "10.0.0.2 - 10.0.0.250" } ],
                    <strong class="userinput"><code>"client-class": "b-devices"</code></strong>
                }
            ]
        }
    ]
}
</pre><p>

        If the client belongs to "b-devices" class (because it includes option
        93 with a value of 0x0002) it doesn't guarantee that the subnet 10.0.0.0/24
        will be used (or preferred) for this client. The server can use any of
        the two subnets because the subnet 192.0.2.0/26 is also allowed for
        this client. The client classification used in this case should be pereceived
        as a way to restrict access to certain subnets, rather than a way to express
        subnet preference. For example, if the client doesn't belong to the
        "b-devices" class it may only use the subnet 192.0.2.0/26 and will
        never use the subnet 10.0.0.0/24.
      </p><p>A typical use case for client classification is in the cable network,
      where cable modems should use one subnet and other devices should use
      another subnet within the same shared network. In this case it is required
      to apply classification on all subnets. The following example defines two
      classes of devices. The subnet selection is  made based on option 93 values.
</p><pre class="screen">
{
    "client-classes": [
        {

            "name": "a-devices",
            "test": "option[93].hex == 0x0001"
        },
        {
            "name": "b-devices",
            "test": "option[93].hex == 0x0002"
        }
    ],
    "shared-networks": [
        {
            "name": "galah",
            "interface": "eth0",
            "subnet4": [
                {
                    "subnet": "192.0.2.0/26",
                    "pools": [ { "pool": "192.0.2.1 - 192.0.2.63" } ],
                    <strong class="userinput"><code>"client-class": "a-devices"</code></strong>
                },
                {
                    "subnet": "10.0.0.0/24",
                    "pools": [ { "pool": "10.0.0.2 - 10.0.0.250" } ],
                    <strong class="userinput"><code>"client-class": "b-devices"</code></strong>
                }
            ]
        }
    ]
}
</pre><p>
In this example each class has its own restriction. Only clients that belong to
class "a-devices" will be able to use subnet 192.0.2.0/26 and only clients
belonging to b-devices will be able to use subnet 10.0.0.0/24. Care should be
taken to not define too restrictive classification rules, as clients that are
unable to use any subnets will be refused service. Although, this may be a
desired outcome if one desires to service only clients of known properties
(e.g. only VoIP phones allowed on a given link).</p><p>
      Note that it is possible to achieve similar effect as presented in this
      section without the use of shared networks. If the subnets are placed in
      the global subnets scope, rather than in the shared network, the server
      will still use classification rules to pick the right subnet for a given
      class of devices. The major benefit of placing subnets within the
      shared network is that common parameters for the logically grouped
      subnets can be specified once, in the shared network scope, e.g.
      "interface" or "relay" parameter. All subnets belonging to this shared
      network will inherit those parameters.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57014272"></a>8.4.3. Host reservations in shared networks</h3></div></div></div><p>
  Subnets being part of a shared network allow host reservations, similar to
  regular subnets:
  </p><pre class="screen">
{
    "shared-networks": [
    {
        "name": "frog",
        "interface": "eth0",
        "subnet4": [
            {
                "subnet": "192.0.2.0/26",
                "id": 100,
                "pools": [ { "pool": "192.0.2.1 - 192.0.2.63" } ],
                <strong class="userinput"><code>"reservations": [
                    {
                        "hw-address": "aa:bb:cc:dd:ee:ff",
                        "ip-address": "192.0.2.28"
                    }
                ]</code></strong>
            },
            {
                "subnet": "10.0.0.0/24",
                "id": 101,
                "pools": [ { "pool": "10.0.0.1 - 10.0.0.254" } ],
                <strong class="userinput"><code>"reservations": [
                    {
                        "hw-address": "11:22:33:44:55:66",
                        "ip-address": "10.0.0.29"
                    }
                ]</code></strong>
            }
        ]
    }
    ]
}
  </pre><p>
</p><p>It is worth noting that Kea conducts additional checks when processing a
packet if shared networks are defined. First, instead of simply checking if
there's a reservation for a given client in his initially selected subnet, it
goes through all subnets in a shared network looking for a reservation. This is
one of the reasons why defining a shared network may impact performance. If
there is a reservation for a client in any subnet, that particular subnet will
be picked for the client. Although it's technically not an error, it is
considered a bad practice to define reservations for the same host in multiple
subnets belonging to the same shared network.</p><p>While not strictly mandatory, it is strongly recommended to use explicit
"id" values for subnets if you plan to use database storage for host
reservations. If ID is not specified, the values for it be autogenerated,
i.e. it will assign increasing integer values starting from 1. Thus, the
autogenerated IDs are not stable across configuration changes.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-serverid"></a>8.5. Server Identifier in DHCPv4</h2></div></div></div><p>
        The DHCPv4 protocol uses a "server identifier" to allow clients
        to discriminate between several servers present on the same link: this
        value is an IPv4 address of the server. The server chooses the IPv4 address
        of the interface on which the message from the client (or relay) has been
        received. A single server instance will use multiple server identifiers
        if it is receiving queries on multiple interfaces.
      </p><p>
        It is possible to override default server identifier values by specifying
        "dhcp-server-identifier" option. This option is only supported on the
        global, shared network and subnet level. It must not be specified
        on client class and host reservation level.
      </p><p>
        The following example demonstrates how to override server identifier for
        a subnet:
</p><pre class="screen">
"subnet4": [
    {
        "subnet": "192.0.2.0/24",
        "option-data": [
            {
                "name": "dhcp-server-identifier",
                "data": "10.2.5.76"
            }
        ],
        ...
    }
]</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-subnet-selection"></a>8.6. How the DHCPv4 Server Selects a Subnet for the Client</h2></div></div></div><p>
        The DHCPv4 server differentiates between the directly connected clients,
        clients trying to renew leases and clients sending their messages through
        relays. For directly connected clients, the server will check the
        configuration for the interface on which the message has been received and,
        if the server configuration doesn't match any configured subnet, the
        message is discarded.</p><p>Assuming that the server's interface is configured with the
        IPv4 address 192.0.2.3, the server will only process messages received through
        this interface from a directly connected client if there is a subnet
        configured to which this IPv4 address belongs, e.g. 192.0.2.0/24.
        The server will use this subnet to assign IPv4 address for the client.
      </p><p>
        The rule above does not apply when the client unicasts its message, i.e.
        is trying to renew its lease. Such a message is accepted through any
        interface. The renewing client sets ciaddr to the currently used IPv4
        address. The server uses this address to select the subnet for the client
        (in particular, to extend the lease using this address).
      </p><p>
        If the message is relayed it is accepted through any interface. The giaddr
        set by the relay agent is used to select the subnet for the client.
      </p><p>
        It is also possible to specify a relay IPv4 address for a given subnet. It
        can be used to match incoming packets into a subnet in uncommon configurations,
        e.g. shared networks. See <a class="xref" href="#dhcp4-relay-override" title="8.6.1. Using a Specific Relay Agent for a Subnet">Section 8.6.1, “Using a Specific Relay Agent for a Subnet”</a> for details.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The subnet selection mechanism described in this section is based
        on the assumption that client classification is not used. The classification
        mechanism alters the way in which a subnet is selected for the client,
        depending on the classes to which the client belongs.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-relay-override"></a>8.6.1. Using a Specific Relay Agent for a Subnet</h3></div></div></div><p>
        A relay has to have an interface connected to the link on which
        the clients are being configured. Typically the relay has an IPv4
        address configured on that interface that belongs to the subnet from which
        the server will assign addresses. In the typical case, the
        server is able to use the IPv4 address inserted by the relay (in the giaddr
        field of the DHCPv4 packet) to select the appropriate subnet.
      </p><p>
        However, that is not always the case. In certain uncommon —
        but valid — deployments, the relay address may not match the subnet. This
        usually means that there is more than one subnet allocated for a given
        link. The two most common examples where this is the case are long lasting
        network renumbering (where both old and new address space is still being
        used) and a cable network. In a cable network both cable modems and the
        devices behind them are physically connected to the same link, yet
        they use distinct addressing. In such a case, the DHCPv4 server needs
        additional information (the IPv4 address of the relay) to properly select
        an appropriate subnet.
      </p><p>
        The following example assumes that there is a subnet 192.0.2.0/24
        that is accessible via a relay that uses 10.0.0.1 as its IPv4 address.
        The server will be able to select this subnet for any incoming packets
        that came from a relay that has an address in 192.0.2.0/24 subnet.
        It will also select that subnet for a relay with address 10.0.0.1.
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            <strong class="userinput"><code>"relay": {
                "ip-addresses": [ "10.0.0.1" ]
            }</code></strong>,
            ...
        }
    ],
    ...
}
</pre><p>
      </p><p>If "relay" is specified, the "ip-addresses" parameter within
      it is mandatory.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      As of Kea 1.4, the "ip-address" parameter has been deprecated in favor 
      of "ip-addresses" which supports specifying a list of addresses.  
      Configuration parsing, will honor the singular form for now but users are
      encouraged to migrate.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp4-srv-example-client-class-relay"></a>8.6.2. Segregating IPv4 Clients in a Cable Network</h3></div></div></div><p>
          In certain cases, it is useful to mix relay address information,
          introduced in <a class="xref" href="#dhcp4-relay-override" title="8.6.1. Using a Specific Relay Agent for a Subnet">Section 8.6.1, “Using a Specific Relay Agent for a Subnet”</a> with client
          classification, explained in <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
          One specific example is cable network, where typically modems
          get addresses from a different subnet than all devices connected
          behind them.
        </p><p>
          Let us assume that there is one CMTS (Cable Modem Termination System)
          with one CM MAC (a physical link that modems are connected to).
          We want the modems to get addresses from the 10.1.1.0/24 subnet, while
          everything connected behind modems should get addresses from another
          subnet (192.0.2.0/24). The CMTS that acts as a relay uses address
          10.1.1.1. The following configuration can serve that configuration:
</p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "10.1.1.0/24",
            "pools":  [ { "pool": "10.1.1.2 - 10.1.1.20" } ],
            <strong class="userinput"><code>"client-class" "docsis3.0",
            "relay": {
                "ip-addresses": [ "10.1.1.1 ]"
            }</code></strong>
        },
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            <strong class="userinput"><code>"relay": {
                "ip-addresses": [ "10.1.1.1" ]
            }</code></strong>
        }
    ],
    ...
}
</pre><p>
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-decline"></a>8.7. Duplicate Addresses (DHCPDECLINE Support)</h2></div></div></div><p>The DHCPv4 server is configured with a certain pool of addresses
      that it is expected to hand out to the DHCPv4 clients.  It is
      assumed that the server is authoritative and has complete jurisdiction
      over those addresses. However, due to various reasons, such as
      misconfiguration or a faulty client implementation that retains its
      address beyond the valid lifetime, there may be devices connected that use
      those addresses without the server's approval or knowledge.</p><p>Such an
      unwelcome event can be detected by legitimate clients (using ARP or ICMP
      Echo Request mechanisms) and reported to the DHCPv4 server using a DHCPDECLINE
      message. The server will do a sanity check (if the client declining an
      address really was supposed to use it), and then will conduct a clean up
      operation. Any DNS entries related to that address will be removed, the
      fact will be logged and hooks will be triggered. After that is done, the
      address will be marked as declined (which indicates that it is used by an
      unknown entity and thus not available for assignment to anyone) and a
      probation time will be set on it. Unless otherwise configured, the
      probation period lasts 24 hours. After that period, the server will
      recover the lease (i.e. put it back into the available state) and the address will
      be available for assignment again. It should be noted that if the
      underlying issue of a misconfigured device is not resolved, the duplicate
      address scenario will repeat. On the other hand, it provides an
      opportunity to recover from such an event automatically, without any
      sysadmin intervention.</p><p>To configure the decline probation period to a value other
      than the default, the following syntax can be used:
</p><pre class="screen">
  "Dhcp4": {
    <strong class="userinput"><code>"decline-probation-period": 3600</code></strong>,
    "subnet4": [ ... ],
    ...
}
</pre><p>
      The parameter is expressed in seconds, so the example above will instruct
      the server to recycle declined leases after an hour.</p><p>There are several statistics and hook points associated with the
      Decline handling procedure. The lease4_decline hook is triggered after the
      incoming DHCPDECLINE message has been sanitized and the server is about to
      decline the lease. The declined-addresses statistic is increased after the
      hook returns (both global and subnet specific variants). (See
      <a class="xref" href="#dhcp4-stats" title="8.8. Statistics in the DHCPv4 Server">Section 8.8, “Statistics in the DHCPv4 Server”</a> and <a class="xref" href="#hooks-libraries" title="Chapter 14. Hooks Libraries">Chapter 14, <i>Hooks Libraries</i></a> for more details
      on DHCPv4 statistics and Kea hook points.)</p><p>Once the probation time elapses, the declined lease is recovered
      using the standard expired lease reclamation procedure, with several
      additional steps. In particular, both declined-addresses statistics
      (global and subnet specific) are decreased. At the same time,
      reclaimed-declined-addresses statistics (again in two variants, global and
      subnet specific) are increased.</p><p>Note about statistics: The server does not decrease the
      assigned-addresses statistics when a DHCPDECLINE is received and processed
      successfully. While technically a declined address is no longer assigned,
      the primary usage of the assigned-addresses statistic is to monitor pool
      utilization. Most people would forget to include declined-addresses in the
      calculation, and simply do assigned-addresses/total-addresses. This would
      have a bias towards under-representing pool utilization. As this has a
      potential for major issues, we decided not to decrease assigned addresses
      immediately after receiving DHCPDECLINE, but to do it later when we
      recover the address back to the available pool.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-stats"></a>8.8. Statistics in the DHCPv4 Server</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This section describes DHCPv4-specific statistics. For a general
        overview and usage of statistics, see <a class="xref" href="#stats" title="Chapter 15. Statistics">Chapter 15, <i>Statistics</i></a>.</p></div><p>
        The DHCPv4 server supports the following statistics:
      </p><div class="table"><a name="dhcp4-statistics"></a><p class="title"><b>Table 8.4. DHCPv4 Statistics</b></p><div class="table-contents"><table summary="DHCPv4 Statistics" border="1"><colgroup><col align="center" class="statistic"><col align="center" class="type"><col align="left" class="description"></colgroup><thead><tr><th align="center">Statistic</th><th align="center">Data Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">pkt4-received</td><td align="center">integer</td><td align="left">
            Number of DHCPv4 packets received. This includes all packets: valid,
            bogus, corrupted, rejected etc.  This statistic is expected to grow
            rapidly.
            </td></tr><tr><td align="center">pkt4-discover-received</td><td align="center">integer</td><td align="left">
            Number of DHCPDISCOVER packets received. This statistic is expected to grow.
            Its increase means that clients that just booted started their configuration process
            and their initial packets reached your server.
            </td></tr><tr><td align="center">pkt4-offer-received</td><td align="center">integer</td><td align="left">
            Number of DHCPOFFER packets received. This statistic
            is expected to remain zero at all times, as DHCPOFFER packets are sent
            by the server and the server is never expected to receive them. Non-zero
            value indicates an error. One likely cause would be a misbehaving relay
            agent that incorrectly forwards DHCPOFFER messages towards the server,
            rather back to the clients.
            </td></tr><tr><td align="center">pkt4-request-received</td><td align="center">integer</td><td align="left">
            Number of DHCPREQUEST packets received. This statistic
            is expected to grow. Its increase means that clients that just booted
            received server's response (DHCPOFFER), accepted it and now requesting
            an address (DHCPREQUEST).
            </td></tr><tr><td align="center">pkt4-ack-received</td><td align="center">integer</td><td align="left">
            Number of DHCPACK packets received. This statistic
            is expected to remain zero at all times, as DHCPACK packets are sent
            by the server and the server is never expected to receive them. Non-zero
            value indicates an error. One likely cause would be a misbehaving relay
            agent that incorrectly forwards DHCPACK messages towards the server,
            rather back to the clients.
            </td></tr><tr><td align="center">pkt4-nak-received</td><td align="center">integer</td><td align="left">
            Number of DHCPNAK packets received. This statistic
            is expected to remain zero at all times, as DHCPNAK packets are sent
            by the server and the server is never expected to receive them. Non-zero
            value indicates an error. One likely cause would be a misbehaving relay
            agent that incorrectly forwards DHCPNAK messages towards the server,
            rather back to the clients.
            </td></tr><tr><td align="center">pkt4-release-received</td><td align="center">integer</td><td align="left">
            Number of DHCPRELEASE packets received. This statistic
            is expected to grow. Its increase means that clients that had an address
            are shutting down or stop using their addresses.
            </td></tr><tr><td align="center">pkt4-decline-received</td><td align="center">integer</td><td align="left">
            Number of DHCPDECLINE packets received. This statistic
            is expected to remain close to zero. Its increase means that a client
            that leased an address, but discovered that the address is currently
            used by an unknown device in your network.
            </td></tr><tr><td align="center">pkt4-inform-received</td><td align="center">integer</td><td align="left">
            Number of DHCPINFORM packets received. This statistic
            is expected to grow. Its increase means that there are clients that
            either do not need an address or already have an address and are
            interested only in getting additional configuration parameters.
            </td></tr><tr><td align="center">pkt4-unknown-received</td><td align="center">integer</td><td align="left">
            Number of packets received of an unknown type. Non-zero
            value of this statistic indicates that the server received a packet
            that it wasn't able to recognize: either with unsupported type
            or possibly malformed (without message type option).
            </td></tr><tr><td align="center">pkt4-sent</td><td align="center">integer</td><td align="left">
            Number of DHCPv4 packets sent. This statistic is expected to grow
            every time the server transmits a packet. In general, it should
            roughly match pkt4-received, as most incoming packets cause
            server to respond. There are exceptions (e.g. DHCPRELEASE), so
            do not worry, if it is lesser than pkt4-received.
            </td></tr><tr><td align="center">pkt4-offer-sent</td><td align="center">integer</td><td align="left">
            Number of DHCPOFFER packets sent. This statistic is expected to
            grow in most cases after a DHCPDISCOVER is processed. There are
            certain uncommon, but valid cases where incoming DHCPDISCOVER is
            dropped, but in general this statistic is expected to be close to
            pkt4-discover-received.
            </td></tr><tr><td align="center">pkt4-ack-sent</td><td align="center">integer</td><td align="left">
            Number of DHCPACK packets sent. This statistic is expected to
            grow in most cases after a DHCPREQUEST is processed. There are
            certain cases where DHCPNAK is sent instead. In general, the sum of
            pkt4-ack-sent and pkt4-nak-sent should be close to
            pkt4-request-received.
            </td></tr><tr><td align="center">pkt4-nak-sent</td><td align="center">integer</td><td align="left">
            Number of DHCPNAK packets sent. This statistic is expected
            to grow when the server chooses to not honor the address
            requested by a client. In general, the sum of
            pkt4-ack-sent and pkt4-nak-sent should be close to
            pkt4-request-received.
            </td></tr><tr><td align="center">pkt4-parse-failed</td><td align="center">integer</td><td align="left">
            Number of incoming packets that could not be parsed.  A non-zero value of
            this statistic indicates that the server received malformed or truncated packet.
            This may indicate problems in your network, faulty clients or a bug in the server.
            </td></tr><tr><td align="center">pkt4-receive-drop</td><td align="center">integer</td><td align="left">
            Number of incoming packets that were dropped. The
            exact reason for dropping packets is logged, but the most common
            reasons may be: an unacceptable packet type, direct responses are
            forbidden, or the server-id sent by the client does not match
            the server's server-id.
            </td></tr><tr><td align="center">subnet[id].total-addresses</td><td align="center">integer</td><td align="left">The total number of addresses available for DHCPv4
              management. In other words, this is the sum of all addresses in
              all configured pools. This statistic changes only during
              configuration changes. Note it does not take into account any
              addresses that may be reserved due to host reservation. The
              <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
              statistic is exposed for each subnet separately. This statistic is
              reset during reconfiguration event.</td></tr><tr><td align="center">subnet[id].assigned-addresses</td><td align="center">integer</td><td align="left">This statistic shows the number of assigned addresses in a
              given subnet. It increases every time a new lease is
              allocated (as a result of receiving a DHCPREQUEST message) and is
              decreased every time a lease is released (a DHCPRELEASE message is
              received) or expires. The <span class="emphasis"><em>id</em></span> is the subnet-id
              of the subnet. This statistic is exposed for each subnet
              separately. This statistic is reset during reconfiguration event.
              </td></tr><tr><td align="center">reclaimed-leases</td><td align="center">integer</td><td align="left">This statistic is the number of expired leases that have
              been reclaimed since server startup. It is incremented each time
              an expired lease is reclaimed and is reset when the server is
              reconfigured.
              </td></tr><tr><td align="center">subnet[id].reclaimed-leases</td><td align="center">integer</td><td align="left">This statistic is the number of expired leases associated
              with a given subnet (<span class="emphasis"><em>id</em></span> is the subnet-id)
              that have been reclaimed since server startup. It is incremented
              each time an expired lease is reclaimed and is reset when the
              server is reconfigured.
              </td></tr><tr><td align="center">declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv4 addresses that are
              currently declined, so counting the number of leases
              currently unavailable. Once a lease is recovered, this
              statistic will be decreased. Ideally, this statistic should be
              zero. If this statistic is non-zero (or worse increasing),
              a network administrator should investigate if there is
              a misbehaving device in his network. This is a global statistic
              that covers all subnets.
            </td></tr><tr><td align="center">subnet[id].declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv4 addresses that are
              currently declined in a given subnet, so is a count of the
              number of leases currently unavailable. Once a lease is
              recovered, this statistic will be decreased. Ideally, this
              statistic should be zero. If this statistic is
              non-zero (or worse increasing), a network administrator should
              investigate if there is a misbehaving device in his network. The
              <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
              statistic is exposed for each subnet separately.
            </td></tr><tr><td align="center">reclaimed-declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv4 addresses that were
              declined, but have now been recovered. Unlike
              declined-addresses, this statistic never decreases. It can be used
              as a long term indicator of how many actual valid Declines were
              processed and recovered from. This is a global statistic that
              covers all subnets.
            </td></tr><tr><td align="center">subnet[id].reclaimed-declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv4 addresses that were
              declined, but have now been recovered. Unlike
              declined-addresses, this statistic never decreases. It can be used
              as a long term indicator of how many actual valid Declines were
              processed and recovered from. The
              <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
              statistic is exposed for each subnet separately.
            </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-ctrl-channel"></a>8.9. Management API for the DHCPv4 Server</h2></div></div></div><p>
        The management API allows the issuing of specific
        management commands, such as statistics retrieval, reconfiguration or shutdown.
        For more details, see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>. Currently the only
        supported communication channel type is UNIX stream socket. By default there
        are no sockets open. To instruct Kea to open a socket, the following entry
        in the configuration file can be used:
</p><pre class="screen">
"Dhcp4": {
    "control-socket": {
        "socket-type": "unix",
        "socket-name": <strong class="userinput"><code>"/path/to/the/unix/socket"</code></strong>
    },

    "subnet4": [
        ...
    ],
    ...
}
</pre><p>
      </p><p>
        The length of the path specified by the <span class="command"><strong>socket-name</strong></span>
        parameter is restricted by the maximum length for the unix socket name
        on your operating system, i.e. the size of the <span class="command"><strong>sun_path</strong></span>
        field in the <span class="command"><strong>sockaddr_un</strong></span> structure, decreased by 1.
        This value varies on different operating systems between 91 and 107
        characters. Typical values are 107 on Linux and 103 on FreeBSD.
      </p><p>
        Communication over control channel is conducted using JSON structures.
        See the Control Channel section in the Kea Developer's Guide for more
        details.
      </p><p>The DHCPv4 server supports the following operational commands:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">build-report</li><li class="listitem">config-get</li><li class="listitem">config-reload</li><li class="listitem">config-set</li><li class="listitem">config-test</li><li class="listitem">config-write</li><li class="listitem">dhcp-disable</li><li class="listitem">dhcp-enable</li><li class="listitem">leases-reclaim</li><li class="listitem">list-commands</li><li class="listitem">shutdown</li><li class="listitem">version-get</li></ul></div><p>
         as described in <a class="xref" href="#commands-common" title="16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers">Section 16.3, “Commands Supported by Both the DHCPv4 and DHCPv6 Servers”</a>.  In addition,
         it supports the following statistics related commands:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">statistic-get</li><li class="listitem">statistic-reset</li><li class="listitem">statistic-remove</li><li class="listitem">statistic-get-all</li><li class="listitem">statistic-reset-all</li><li class="listitem">statistic-remove-all</li></ul></div><p>
        as described here <a class="xref" href="#command-stats" title="15.3. Commands for Manipulating Statistics">Section 15.3, “Commands for Manipulating Statistics”</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-std"></a>8.10. Supported DHCP Standards</h2></div></div></div><p>The following standards are currently supported:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="emphasis"><em>Dynamic Host Configuration Protocol</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>:
            Supported messages are DHCPDISCOVER (1), DHCPOFFER (2),
            DHCPREQUEST (3), DHCPRELEASE (7), DHCPINFORM (8), DHCPACK (5), and
            DHCPNAK(6).</li><li class="listitem"><span class="emphasis"><em>DHCP Options and BOOTP Vendor Extensions</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc2132" target="_top">RFC 2132</a>:
            Supported options are: PAD (0),
            END(255), Message Type(53), DHCP Server Identifier (54),
            Domain Name (15), DNS Servers (6), IP Address Lease Time
            (51), Subnet mask (1), and Routers (3).</li><li class="listitem"><span class="emphasis"><em>DHCP Relay Agent Information Option</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc3046" target="_top">RFC 3046</a>:
            Relay Agent Information option is supported.</li><li class="listitem"><span class="emphasis"><em>Vendor-Identifying Vendor Options for
            Dynamic Host Configuration Protocol version 4</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc3925" target="_top">RFC 3925</a>:
            Vendor-Identifying Vendor Class and Vendor-Identifying Vendor-Specific
            Information options are supported.</li><li class="listitem"><span class="emphasis"><em>Client Identifier Option in DHCP Server Replies</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc6842" target="_top">RFC 6842</a>:
            Server by default sends back client-id option. That capability may be
            disabled. See <a class="xref" href="#dhcp4-echo-client-id" title="8.2.18. Echoing Client-ID (RFC 6842)">Section 8.2.18, “Echoing Client-ID (RFC 6842)”</a> for details.
            </li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-user-contexts"></a>8.11. User contexts in IPv4</h2></div></div></div><p>
          Kea allows loading hook libraries that sometimes could benefit from
          additional parameters. If such a parameter is specific to the whole
          library, it is typically defined as a parameter for the hook library.
          However, sometimes there is a need to specify parameters that are
          different for each pool.
        </p><p>
          User contexts can store arbitrary data as long as it is valid JSON
          syntax and its top level element is a map (i.e. the data must be
          enclosed in curly brackets). Some hook libraries may expect specific
          formatting, though.  Please consult specific hook library
          documentation for details.
        </p><p>
          User contexts can be specified on either global scope,
          shared network, subnet, pool, client class, option data or
          definition level, and host reservation. One other useful
          usage is the ability to store comments or descriptions.
        </p><p>
          Let's consider an imaginary case of devices that have color LED
          lights. Depending on their location, they should glow red, blue or
          green. It would be easy to write a hook library that would send
          specific values as maybe a vendor option. However, the server has to
          have some way to specify that value for each pool. This need is
          addressed by user contexts. In essence, any user data can specified
          in the user context as long as it is a valid JSON map. For example,
          the forementioned case of LED devices could be configured in the
          following way:

          </p><pre class="screen">
"Dhcp4": {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ {
                "pool": "192.0.2.10 - 192.0.2.20",
                // This is pool specific user context
                <strong class="userinput"><code>"user-context": { "colour": "red" }</code></strong>
            } ],

            // This is a subnet specific user context. You can put whatever type
            // of information you want as long as it is a valid JSON.
            <strong class="userinput"><code>"user-context": {
                "comment": "network on the second floor",
                "last-modified": "2017-09-04 13:32",
                "description": "you can put here anything you like",
                "phones": [ "x1234", "x2345" ],
                "devices-registered": 42,
                "billing": false
            }</code></strong>
        },
        ...
    ],
    ...
}</pre><p>
        </p><p>
          It should be noted that Kea will not use that information, but will
          simply store and make it available to hook libraries. It is up to the
          hook library to extract that information and make use of it.
          The parser translates a "comment" entry into a user-context
          with the entry, this allows to attach a comment inside the
          configuration itself.
        </p><p>
          For more background information, see <a class="xref" href="#user-context" title="14.5. User contexts">Section 14.5, “User contexts”</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-limit"></a>8.12. DHCPv4 Server Limitations</h2></div></div></div><p>These are the current limitations of the DHCPv4 server
      software. Most of them are reflections of the current stage of
      development and should be treated as <span class="quote">“<span class="quote">not implemented
      yet</span>”</span>, rather than actual limitations. However, some of them
      are implications of the design choices made. Those are clearly
      marked as such.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              BOOTP (<a class="ulink" href="http://tools.ietf.org/html/rfc951" target="_top">RFC 951</a>)
              is not supported. This is a design choice: BOOTP support is not planned.
            </li><li class="listitem">On Linux and BSD system families the DHCP messages are sent
            and received over the raw sockets (using LPF and BPF) and all packet
            headers (including data link layer, IP and UDP headers) are created and
            parsed by Kea, rather than the system kernel. Currently, Kea can
            only parse the data link layer headers with a format adhering to
            IEEE 802.3 standard and assumes this data link layer header format
            for all interfaces. Hence, Kea will fail to work on interfaces
            which use different data link layer header formats (e.g. Infiniband).
            </li><li class="listitem">The DHCPv4 server does not  verify that
            assigned address is unused. According to <a class="ulink" href="http://tools.ietf.org/html/rfc2131" target="_top">RFC 2131</a>, the
            allocating server should verify that address is not used by
            sending ICMP echo request.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp4-srv-examples"></a>8.13. Kea DHCPv4 server examples</h2></div></div></div><p>
        A collection of simple to use examples for DHCPv4 component of Kea is
        available with the sources. It is located in doc/examples/kea4
        directory. At the time of writing this text there were 15 examples,
        but the number is growing slowly with each release.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="dhcp6"></a>Chapter 9. The DHCPv6 Server</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#dhcp6-start-stop">9.1. Starting and Stopping the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-configuration">9.2. DHCPv6 Server Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp57194240">9.2.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp57194368">9.2.2. Lease Storage</a></span></dt><dt><span class="section"><a href="#hosts6-storage">9.2.3. Hosts Storage</a></span></dt><dt><span class="section"><a href="#dhcp6-interface-selection">9.2.4. Interface Selection</a></span></dt><dt><span class="section"><a href="#ipv6-subnet-id">9.2.5. IPv6 Subnet Identifier</a></span></dt><dt><span class="section"><a href="#dhcp6-unicast">9.2.6. Unicast Traffic Support</a></span></dt><dt><span class="section"><a href="#dhcp6-address-config">9.2.7. Subnet and Address Pool</a></span></dt><dt><span class="section"><a href="#idp57326512">9.2.8. Subnet and Prefix Delegation Pools</a></span></dt><dt><span class="section"><a href="#pd-exclude-option">9.2.9. Prefix Exclude Option</a></span></dt><dt><span class="section"><a href="#dhcp6-std-options">9.2.10. Standard DHCPv6 Options</a></span></dt><dt><span class="section"><a href="#s46-options">9.2.11. Common Softwire46 Options</a></span></dt><dt><span class="section"><a href="#dhcp6-custom-options">9.2.12. Custom DHCPv6 Options</a></span></dt><dt><span class="section"><a href="#dhcp6-vendor-opts">9.2.13. DHCPv6 Vendor-Specific Options</a></span></dt><dt><span class="section"><a href="#dhcp6-option-spaces">9.2.14. Nested DHCPv6 Options (Custom Option Spaces)</a></span></dt><dt><span class="section"><a href="#dhcp6-option-data-defaults">9.2.15. Unspecified Parameters for DHCPv6 Option Configuration</a></span></dt><dt><span class="section"><a href="#dhcp6-config-subnets">9.2.16. IPv6 Subnet Selection</a></span></dt><dt><span class="section"><a href="#dhcp6-rapid-commit">9.2.17. Rapid Commit</a></span></dt><dt><span class="section"><a href="#dhcp6-relays">9.2.18. DHCPv6 Relays</a></span></dt><dt><span class="section"><a href="#dhcp6-rsoo">9.2.19. Relay-Supplied Options</a></span></dt><dt><span class="section"><a href="#dhcp6-client-classifier">9.2.20. Client Classification in DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-ddns-config">9.2.21. DDNS for DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-dhcp4o6-config">9.2.22. DHCPv4-over-DHCPv6: DHCPv6 Side</a></span></dt></dl></dd><dt><span class="section"><a href="#host-reservation-v6">9.3. Host Reservation in DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#reservation6-types">9.3.1. Address/Prefix Reservation Types</a></span></dt><dt><span class="section"><a href="#reservation6-conflict">9.3.2. Conflicts in DHCPv6 Reservations</a></span></dt><dt><span class="section"><a href="#reservation6-hostname">9.3.3. Reserving a Hostname</a></span></dt><dt><span class="section"><a href="#reservation6-options">9.3.4. Including Specific DHCPv6 Options in Reservations</a></span></dt><dt><span class="section"><a href="#reservation6-client-classes">9.3.5. Reserving Client Classes in DHCPv6</a></span></dt><dt><span class="section"><a href="#reservations6-mysql-pgsql-cql">9.3.6. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</a></span></dt><dt><span class="section"><a href="#reservations6-tuning">9.3.7. Fine Tuning DHCPv6 Host Reservation</a></span></dt></dl></dd><dt><span class="section"><a href="#shared-network6">9.4. Shared networks in DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#idp57794880">9.4.1. Local and relayed traffic in shared networks</a></span></dt><dt><span class="section"><a href="#idp57802400">9.4.2. Client classification in shared networks</a></span></dt><dt><span class="section"><a href="#idp57812720">9.4.3. Host reservations in shared networks</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp6-serverid">9.5. Server Identifier in DHCPv6</a></span></dt><dt><span class="section"><a href="#stateless-dhcp6">9.6. Stateless DHCPv6 (Information-Request Message)</a></span></dt><dt><span class="section"><a href="#dhcp6-rfc7550">9.7. Support for RFC 7550</a></span></dt><dt><span class="section"><a href="#dhcp6-relay-override">9.8. Using Specific Relay Agent for a Subnet</a></span></dt><dt><span class="section"><a href="#dhcp6-client-class-relay">9.9. Segregating IPv6 Clients in a Cable Network</a></span></dt><dt><span class="section"><a href="#mac-in-dhcpv6">9.10. MAC/Hardware Addresses in DHCPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-decline">9.11. Duplicate Addresses (DECLINE Support)</a></span></dt><dt><span class="section"><a href="#dhcp6-stats">9.12. Statistics in the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-ctrl-channel">9.13. Management API for the DHCPv6 Server</a></span></dt><dt><span class="section"><a href="#dhcp6-user-contexts">9.14. User contexts in IPv6</a></span></dt><dt><span class="section"><a href="#dhcp6-std">9.15. Supported DHCPv6 Standards</a></span></dt><dt><span class="section"><a href="#dhcp6-limit">9.16. DHCPv6 Server Limitations</a></span></dt><dt><span class="section"><a href="#dhcp6-srv-examples">9.17. Kea DHCPv6 server examples</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-start-stop"></a>9.1. Starting and Stopping the DHCPv6 Server</h2></div></div></div><p>
        It is recommended that the Kea DHCPv6 server be started and stopped
        using <span class="command"><strong>keactrl</strong></span> (described in <a class="xref" href="#keactrl" title="Chapter 6. Managing Kea with keactrl">Chapter 6, <i>Managing Kea with keactrl</i></a>).
        However, it is also possible to run the server directly: it accepts
        the following command-line switches:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>-c <em class="replaceable"><code>file</code></em></strong></span> -
            specifies the configuration file. This is the only mandatory
            switch.</li><li class="listitem">
            <span class="command"><strong>-d</strong></span> - specifies whether the server
            logging should be switched to verbose mode. In verbose mode,
            the logging severity and debuglevel specified in the configuration
            file are ignored and "debug" severity and the maximum debuglevel
            (99) are assumed. The flag is convenient, for temporarily
            switching the server into maximum verbosity, e.g. when
            debugging.</li><li class="listitem">
            <span class="command"><strong>-p <em class="replaceable"><code>port</code></em></strong></span> -
            specifies UDP port on which the server will listen. This is only
            useful during testing, as a DHCPv6 server listening on
            ports other than the standard ones will not be able to
            handle regular DHCPv6 queries.</li><li class="listitem">
            <span class="command"><strong>-t <em class="replaceable"><code>file</code></em></strong></span> -
            specifies the configuration file to be tested. Kea-dhcp6
            will attempt to load it, and will conduct sanity
            checks. Note that certain checks are possible only while
            running the actual server. The actual status is reported
            with exit code (0 = configuration looks ok, 1 = error
            encountered). Kea will print out log messages to standard
            output and error to standard error when testing
            configuration.</li><li class="listitem">
              <span class="command"><strong>-v</strong></span> - prints out the Kea version and exits.
            </li><li class="listitem">
              <span class="command"><strong>-V</strong></span> - prints out the Kea extended version with
              additional parameters and exits. The listing includes the versions
              of the libraries dynamically linked to Kea.
            </li><li class="listitem">
              <span class="command"><strong>-W</strong></span> - prints out the Kea configuration report
              and exits. The report is a copy of the
              <code class="filename">config.report</code> file produced by
              <strong class="userinput"><code>./configure</code></strong>: it is embedded in the
              executable binary.
            </li></ul></div><p>
        The <code class="filename">config.report</code> may also be accessed more
        directly.  The following command may be used to extract this
        information.  The binary <strong class="userinput"><code>path</code></strong> may be found
        in the install directory or in the <code class="filename">.libs</code>
        subdirectory in the source tree. For example
        <code class="filename">kea/src/bin/dhcp6/.libs/kea-dhcp6</code>.

</p><pre class="screen">
strings <strong class="userinput"><code>path</code></strong>/kea-dhcp6 | sed -n 's/;;;; //p'
</pre><p>
      </p><p>
        On start-up, the server will detect available network interfaces
        and will attempt to open UDP sockets on all interfaces
        mentioned in the configuration file.
        Since the DHCPv6 server opens privileged ports, it requires root
        access. Make sure you run this daemon as root.
      </p><p>
        During startup the server will attempt to create a PID file of the
        form: localstatedir]/[conf name].kea-dhcp6.pid where:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>localstatedir</strong></span>: The value as passed into the
            build configure script. It defaults to "/usr/local/var".  Note
            that this value may be overridden at run time by setting the environment
            variable KEA_PIDFILE_DIR.  This is intended primarily for testing purposes.
            </li><li class="listitem"><span class="command"><strong>conf name</strong></span>: The configuration file name
            used to start the server, minus all preceding path and file extension.
            For example, given a pathname of "/usr/local/etc/kea/myconf.txt", the
            portion used would be "myconf".
            </li></ul></div><p>
        If the file already exists and contains the PID of a live process,
        the server will issue a DHCP6_ALREADY_RUNNING log message and exit. It
        is possible, though unlikely, that the file is a remnant of a system crash
        and the process to which the PID belongs is unrelated to Kea.  In such a
        case it would be necessary to manually delete the PID file.
      </p><p>
        The server can be stopped using the <span class="command"><strong>kill</strong></span> command.
        When running in a console, the server can be shut down by
        pressing ctrl-c. It detects the key combination and shuts
        down gracefully.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-configuration"></a>9.2. DHCPv6 Server Configuration</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57194240"></a>9.2.1. Introduction</h3></div></div></div><p>
        This section explains how to configure the DHCPv6 server using the
        Kea configuration backend. (Kea configuration using any other
        backends is outside of scope of this document.) Before DHCPv6
        is started, its configuration file has to be created. The
        basic configuration is as follows:
</p><pre class="screen">
{
# DHCPv6 configuration starts on the next line
"Dhcp6": {

# First we set up global values
    "valid-lifetime": 4000,
    "renew-timer": 1000,
    "rebind-timer": 2000,
    "preferred-lifetime": 3000,

# Next we setup the interfaces to be used by the server.
    "interfaces-config": {
        "interfaces": [ "eth0" ]
    },

# And we specify the type of lease database
    "lease-database": {
        "type": "memfile",
        "persist": true,
        "name": "/var/kea/dhcp6.leases"
    },

# Finally, we list the subnets from which we will be leasing addresses.
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::1-2001:db8:1::ffff"
                 }
             ]
        }
    ]
# DHCPv6 configuration ends with the next line
}

} </pre><p>
</p><p>The following paragraphs provide a brief overview of the parameters in
the above example together with
their format. Subsequent sections of this chapter go into much greater detail
for these and other parameters.</p><p>The lines starting with a hash (#) are comments and are ignored by
the server; they do not impact its
operation in any way.</p><p>The configuration starts in the first line with the initial
opening curly bracket (or brace). Each configuration consists of
one or more objects. In this specific example, we have only one
object, called Dhcp6. This is a simplified configuration, as usually
there will be additional objects, like <span class="command"><strong>Logging</strong></span> or
<span class="command"><strong>DhcpDdns</strong></span>, but we omit them now for clarity. The Dhcp6
configuration starts with the <span class="command"><strong>"Dhcp6": {</strong></span> line
and ends with the corresponding closing brace (in the above example,
the brace after the last comment).  Everything defined between those
lines is considered to be the Dhcp6 configuration.</p><p>In the general case, the order in which those parameters appear does not
matter. There are two caveats here though. The first one is to remember that
the configuration file must be well formed JSON. That means that parameters
for any given scope must be separated by a comma and there must not be a comma
after the last parameter. When reordering a configuration file, keep in mind that
moving a parameter to or from the last position in a given scope may also require
moving the comma. The second caveat is that it is uncommon — although
legal JSON — to
repeat the same parameter multiple times. If that happens, the last occurrence of a
given parameter in a given scope is used while all previous instances are
ignored. This is unlikely to cause any confusion as there are no real life
reasons to keep multiple copies of the same parameter in your configuration
file.</p><p>Moving onto the DHCPv6 configuration elements, the very first few elements
define some global parameters. <span class="command"><strong>valid-lifetime</strong></span>
defines for how long the addresses (leases) given out by the server are valid. If
nothing changes, a client that got an address is allowed to use it for 4000
seconds. (Note that integer numbers are specified as is, without any quotes
around them.) The address will become deprecated in 3000 seconds (clients are
allowed to keep old connections, but can't use this address for creating new
connections). <span class="command"><strong>renew-timer</strong></span> and
<span class="command"><strong> rebind-timer</strong></span> are values that define T1 and T2 timers that
govern when the client will begin the renewal and rebind procedures.</p><p>The <span class="command"><strong>interfaces-config</strong></span> map specifies the server
configuration concerning the network interfaces, on which the server should
listen to the DHCP messages. The <span class="command"><strong>interfaces</strong></span> parameter
specifies a list of network interfaces on which the server should listen.
Lists are opened and closed with square brackets, with elements separated
by commas. Had we wanted to listen on two interfaces, the
<span class="command"><strong>interfaces-config</strong></span> would look like this:
</p><pre class="screen">
"interfaces-config": {
    "interfaces": [ "eth0", "eth1" ]
},
</pre><p>
</p><p>The next couple of lines define the lease database, the place where the server
stores its lease information. This particular example tells the server to use
<span class="command"><strong>memfile</strong></span>, which is the simplest (and fastest) database
backend. It uses an in-memory database and stores leases on disk in a CSV
file. This is a very simple configuration. Usually the lease database configuration
is more extensive and contains additional parameters.  Note that
<span class="command"><strong>lease-database</strong></span>
is an object and opens up a new scope, using an opening brace.
Its parameters (just one in this example - <span class="command"><strong>type</strong></span>)
follow. Had there been more than one, they would be separated by commas. This
scope is closed with a closing brace. As more parameters for the Dhcp6 definition
follow, a trailing comma is present.</p><p>Finally, we need to define a list of IPv6 subnets. This is the
most important DHCPv6 configuration structure as the server uses that
information to process clients' requests. It defines all subnets from
which the server is expected to receive DHCP requests. The subnets are
specified with the <span class="command"><strong>subnet6</strong></span> parameter.  It is a list,
so it starts and ends with square brackets.  Each subnet definition in
the list has several attributes associated with it, so it is a structure
and is opened and closed with braces. At minimum, a subnet definition
has to have at least two parameters: <span class="command"><strong>subnet</strong></span> (that
defines the whole subnet) and <span class="command"><strong>pools</strong></span> (which is a list of
dynamically allocated pools that are governed by the DHCP server).</p><p>The example contains a single subnet. Had more than one been defined,
additional elements
in the <span class="command"><strong>subnet6</strong></span> parameter would be specified and
separated by commas. For example, to define two subnets, the following
syntax would be used:
</p><pre class="screen">
"subnet6": [
    {
        "pools": [ { "pool": "2001:db8:1::/112" } ],
        "subnet": "2001:db8:1::/64"
    },
    {
        "pools": [ { "pool": "2001:db8:2::1-2001:db8:2::ffff" } ],
        "subnet": "2001:db8:2::/64"
    }
]
</pre><p>
Note that indentation is optional and is used for aesthetic purposes only.
In some cases in may be preferable to use more compact notation.
</p><p>After all parameters are specified, we have two contexts open:
global and Dhcp6, hence we need two closing curly brackets to close them.
In a real life configuration file there most likely would be additional
components defined such as Logging or DhcpDdns, so the closing brace would
be followed by a comma and another object definition.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57194368"></a>9.2.2. Lease Storage</h3></div></div></div><p>All leases issued by the server are stored in the lease database.
  Currently there are four database backends available:  memfile (which is the
  default backend), MySQL, PostgreSQL and Cassandra.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57216128"></a>9.2.2.1. Memfile - Basic Storage for Leases</h4></div></div></div><p>The server is able to store lease data in different repositories. Larger
  deployments may elect to store leases in a database. <a class="xref" href="#database-configuration6" title="9.2.2.2. Lease Database Configuration">Section 9.2.2.2, “Lease Database Configuration”</a> describes this option. In typical
  smaller deployments though, the server will store lease information in a CSV file rather
  than a database. As well as requiring less administration, an
  advantage of using a file for storage is that it
  eliminates a dependency on third-party database software.</p><p>The configuration of the file backend (Memfile) is controlled through
  the Dhcp6/lease-database parameters. The <span class="command"><strong>type</strong></span> parameter
  is mandatory and it specifies which storage for leases the server should use.
  The value of <strong class="userinput"><code>"memfile"</code></strong> indicates that the file should
  be used as the storage. The following list gives additional, optional,
  parameters that can be used to configure the Memfile backend.

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>persist</strong></span>: controls whether the new leases and
      updates to existing leases are written to the file. It is strongly
      recommended that the value of this parameter is set to
      <strong class="userinput"><code>true</code></strong> at all times, during the server's normal
      operation. Not writing leases to disk will mean that if a server is restarted
      (e.g. after a power failure), it will not know what addresses have been
      assigned.  As a result, it may hand out addresses to new clients that are
      already in use. The value of <strong class="userinput"><code>false</code></strong> is mostly useful
      for performance testing purposes. The default value of the
      <span class="command"><strong>persist</strong></span> parameter is <strong class="userinput"><code>true</code></strong>,
      which enables writing lease updates
      to the lease file.
      </li><li class="listitem"><span class="command"><strong>name</strong></span>: specifies an absolute location of the lease
      file in which new leases and lease updates will be recorded. The default value
      for this parameter is <strong class="userinput"><code>"[kea-install-dir]/var/kea/kea-leases6.csv"
      </code></strong>.</li><li class="listitem"><span class="command"><strong>lfc-interval</strong></span>: specifies the interval in seconds, at
      which the server will perform a lease file cleanup (LFC).  This
      removes redundant (historical) information from the lease file
      and effectively reduces the lease file size. The cleanup process is described
      in more detailed fashion further in this section. The default value of the
      <span class="command"><strong>lfc-interval</strong></span> is <strong class="userinput"><code>3600</code></strong>. A value of 0
      disables the LFC.</li></ul></div><p>
  </p><p>An example configuration of the Memfile backend is presented below:

</p><pre class="screen">
"Dhcp6": {
    "lease-database": {
        <strong class="userinput"><code>"type": "memfile"</code></strong>,
        <strong class="userinput"><code>"persist": true</code></strong>,
        <strong class="userinput"><code>"name": "/tmp/kea-leases6.csv"</code></strong>,
        <strong class="userinput"><code>"lfc-interval": 1800</code></strong>
    }
}
</pre><p>

    This configuration selects the <code class="filename">/tmp/kea-leases6.csv</code> as
    the storage for lease information and enables persistence (writing lease updates
    to this file). It also configures the backend perform the periodic cleanup
    of the lease files, executed every 30 minutes.
  </p><p>It is important to know how the lease file contents are organized
  to understand why the periodic lease file cleanup is needed. Every time
  the server updates a lease or creates a new lease for the client, the new
  lease information must be recorded in the lease file. For performance reasons,
  the server does not update the existing client's lease in the file, as it would
  potentially require rewriting the entire file. Instead, it simply appends the new lease
  information to the end of the file: the previous lease entries for the
  client are not removed. When the server loads leases from the lease file, e.g.
  at the server startup, it assumes that the latest lease entry for the client
  is the valid one. The previous entries are discarded. This means that the
  server can re-construct the accurate information about the leases even though
  there may be many lease entries for each client. However, storing many entries
  for each client results in bloated lease file and impairs the performance of
  the server's startup and reconfiguration as it needs to process a larger number
  of lease entries.
  </p><p>Lease file cleanup (LFC) removes all previous entries for each client and
  leaves only the latest ones. The interval at which the cleanup is performed
  is configurable, and it should be selected according to the frequency of lease
  renewals initiated by the clients. The more frequent the renewals, the smaller
  the value of <span class="command"><strong>lfc-interval</strong></span> should be. Note however, that the
  LFC takes time and thus it is possible (although unlikely) that new cleanup
  is started while the previous cleanup instance is still running, if the
  <span class="command"><strong>lfc-interval</strong></span> is too short. The server would recover from
  this by skipping the new cleanup when it detects that the previous cleanup
  is still in progress. But it implies that the actual cleanups will be
  triggered more rarely than configured. Moreover, triggering a new cleanup
  adds an overhead to the server which will not be able to respond to new
  requests for a short period of time when the new cleanup process is spawned.
  Therefore, it is recommended that the <span class="command"><strong>lfc-interval</strong></span> value
  is selected in a way that would allow for the LFC to complete the cleanup before a
  new cleanup is triggered.
  </p><p>Lease file cleanup is performed by a separate process (in background) to avoid
  a performance impact on the server process. In order to avoid the conflicts
  between two processes both using the same lease files, the LFC process
  operates on the copy of the original lease file, rather than on the lease
  file used by the server to record lease updates. There are also other files
  being created as a side effect of the lease file cleanup. The detailed
  description of the LFC is located on the Kea wiki:
  <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/LFCDesign" target="_top">http://kea.isc.org/wiki/LFCDesign</a></code>.
  </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="database-configuration6"></a>9.2.2.2. Lease Database Configuration</h4></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Lease database access information must be configured for the DHCPv6 server,
    even if it has already been configured for the DHCPv4 server.  The servers
    store their information independently, so each server can use a separate
    database or both servers can use the same database.</p></div><p>Lease database configuration is controlled through the
  Dhcp6/lease-database parameters. The type of the database must be set to
  "memfile", "mysql", "postgresql" or "cql", e.g.
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... }
</pre><p>
  Next, the name of the database is to hold the leases must be set: this is the
  name used when the database was created
  (see <a class="xref" href="#mysql-database-create" title="4.3.2.1. First Time Creation of the MySQL Database">Section 4.3.2.1, “First Time Creation of the MySQL Database”</a>,
  <a class="xref" href="#pgsql-database-create" title="4.3.3.1. First Time Creation of the PostgreSQL Database">Section 4.3.3.1, “First Time Creation of the PostgreSQL Database”</a>
  or <a class="xref" href="#cql-database-create" title="4.3.4.1. First Time Creation of the Cassandra Database">Section 4.3.4.1, “First Time Creation of the Cassandra Database”</a>).
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"name": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  For Cassandra:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"keyspace": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  If the database is located on a different system to the DHCPv6 server, the
  database host name must also be specified. (It should be noted that this
  configuration may have a severe impact on server performance.):
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"host": "<em class="replaceable"><code>remote-host-name</code></em>"</code></strong>, ... }, ... }
</pre><p>
  For Cassandra, multiple contact points can be provided:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"contact-points": "<em class="replaceable"><code>remote-host-name[, ...]</code></em>" </code></strong>, ... }, ... }
</pre><p>
  The usual state of affairs will be to have the database on the same machine as
  the DHCPv6 server.  In this case, set the value to the empty string:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"host" : ""</code></strong>, ... }, ... }
</pre><p>
  For Cassandra:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"contact-points": ""</code></strong>, ... }, ... }
</pre><p>
  Should the database use a port different than default, it may be
  specified as well:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"port" : 12345</code></strong>, ... }, ... }
</pre><p>
  Should the database be located on a different system, you may need to specify a longer interval
  for the connection timeout:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"connect-timeout" : <em class="replaceable"><code>timeout-in-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
The default value of five seconds should be more than adequate for local connections.
If a timeout is given though, it should be an integer greater than zero.
  </p><p>
The maxiumum number of times the server will automatically attempt to reconnect to
the lease database after connectivity has been lost may be specified:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"max-reconnect-tries" : <em class="replaceable"><code>number-of-tries</code></em></code></strong>, ... }, ... }
</pre><p>
If the server is unable to reconnect to the database after making the maximum number
of attempts the server will exit. A value of zero (the default) disables automatic
recovery and the server will exit immediately upon detecting a loss of connectivity
(MySQL and Postgres only).
  </p><p>
The number of seconds the server will wait in between attempts to reconnect to the
lease database after connectivity has been lost may also be specified:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"reconnect-wait-time" : <em class="replaceable"><code>number-of-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
A value of zero (the default) disables automatic recovery and the server will exit
immediately upon detecting a loss of connectivity (MySQL and Postgres only).
  </p><p>
    Note that host parameter is used by MySQL and PostgreSQL
    backends. Cassandra has a concept of contact points that could be
    used to contact the cluster, instead of a single IP or
    hostname. It takes a list of comma separated IP addresses. This may be specified as:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"contact-points" : "192.0.2.1,192.0.2.2"</code></strong>, ... }, ... }
</pre><p>
  </p><p>Finally, the credentials of the account under which the server will
  access the database should be set:
</p><pre class="screen">
"Dhcp6": { "lease-database": { <strong class="userinput"><code>"user": "<em class="replaceable"><code>user-name</code></em>"</code></strong>,
                               <strong class="userinput"><code>"password": "<em class="replaceable"><code>password</code></em>"</code></strong>,
                              ... },
           ... }
</pre><p>
  If there is no password to the account, set the password to the empty string
  "". (This is also the default.)</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cassandra-database-configuration6"></a>9.2.2.3. Cassandra specific parameters</h4></div></div></div><p>The parameters are the same for DHCPv4 and DHCPv6. See <a class="xref" href="#cassandra-database-configuration4" title="8.2.2.3. Cassandra specific parameters">Section 8.2.2.3, “Cassandra specific parameters”</a> for details.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hosts6-storage"></a>9.2.3. Hosts Storage</h3></div></div></div><p>Kea is also able to store information about host reservations in the
    database. The hosts database configuration uses the same syntax as the lease
    database. In fact, a Kea server opens independent connections for each
    purpose, be it lease or hosts information. This arrangement gives the most
    flexibility. Kea can be used to keep leases and host reservations
    separately, but can also point to the same database. Currently the
    supported hosts database types are MySQL and PostgreSQL. The Cassandra
    backend does not support host reservations yet.</p><p>Please note that usage of hosts storage is optional. A user can define
    all host reservations in the configuration file. That is the recommended way
    if the number of reservations is small. However, when the number of
    reservations grows it's more convenient to use host storage. Please note
    that both storage methods (configuration file and one of the supported databases)
    can be used together. If hosts are defined in both places, the definitions
    from the configuration file are checked first and external storage is checked
    later, if necessary.</p><p>Version 1.4 extends the host storage to multiple storages. Operations
    are performed on host storages in the configuration order with a special
    case for addition: read-only storages must be configured after a
    required read-write storage, or host reservation addition will
    always fail.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hosts-databases-configuration6"></a>9.2.3.1. DHCPv6 Hosts Database Configuration</h4></div></div></div><p>Hosts database configuration is controlled through the Dhcp6/hosts-database
  parameters. If enabled, the type of the database must be set to "mysql" or
  "postgresql". Other hosts backends may be added in later version of Kea.
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... }
</pre><p>
  Next, the name of the database to hold the reservations must be set: this is the
  name used when the database was created  (see <a class="xref" href="#supported-databases" title="4.3. Supported Databases">Section 4.3, “Supported Databases”</a>
  for instructions how to setup desired database type).
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"name": "<em class="replaceable"><code>database-name</code></em>" </code></strong>, ... }, ... }
</pre><p>
  If the database is located on a different system than the DHCPv6 server, the
  database host name must also be specified. (Again it should be noted that this
  configuration may have a severe impact on server performance):
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"host": <em class="replaceable"><code>remote-host-name</code></em></code></strong>, ... }, ... }
</pre><p>
  The usual state of affairs will be to have the database on the same machine as
  the DHCPv6 server.  In this case, set the value to the empty string:
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"host" : ""</code></strong>, ... }, ... }
</pre><p>
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"port" : 12345</code></strong>, ... }, ... }
</pre><p>
  </p><p>
The maxiumum number of times the server will automatically attempt to reconnect to
the host database after connectivity has been lost may be specified:
</p><pre class="screen">
"Dhcp6": { "host-database": { <strong class="userinput"><code>"max-reconnect-tries" : <em class="replaceable"><code>number-of-tries</code></em></code></strong>, ... }, ... }
</pre><p>
If the server is unable to reconnect to the database after making the maximum number
of attempts the server will exit. A value of zero (the default) disables automatic
recovery and the server will exit immediately upon detecting a loss of connectivity
(MySQL and Postgres only).
  </p><p>
The number of seconds the server will wait in between attempts to reconnect to the
host database after connectivity has been lost may also be specified:
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"reconnect-wait-time" : <em class="replaceable"><code>number-of-seconds</code></em></code></strong>, ... }, ... }
</pre><p>
A value of zero (the default) disables automatic recovery and the server will exit
immediately upon detecting a loss of connectivity (MySQL and Postgres only).
  </p><p>Finally, the credentials of the account under which the server will
  access the database should be set:
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"user": "<em class="replaceable"><code>user-name</code></em>"</code></strong>,
                               <strong class="userinput"><code>"password": "<em class="replaceable"><code>password</code></em>"</code></strong>,
                              ... },
           ... }
</pre><p>
  If there is no password to the account, set the password to the empty string
  "". (This is also the default.)</p><p>The multiple storage extension uses a similar syntax: a configuration
  is placed into a "hosts-databases" list instead of into a "hosts-database"
  entry as in:
</p><pre class="screen">
"Dhcp6": { "hosts-databases": [ { <strong class="userinput"><code>"type": "mysql"</code></strong>, ... }, ... ], ... }
</pre><p>
  </p><p>
    For additional Cassandra specific parameters, see <a class="xref" href="#cassandra-database-configuration4" title="8.2.2.3. Cassandra specific parameters">Section 8.2.2.3, “Cassandra specific parameters”</a>.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="read-only-database-configuration6"></a>9.2.3.2. Using Read-Only Databases for Host Reservations</h4></div></div></div><p>
In some deployments the database user whose name is specified in the database backend
configuration may not have write privileges to the database. This is often
required by the policy within a given network to secure the data from being
unintentionally modified. In many cases administrators have inventory databases
deployed, which contain substantially more information about the hosts than
static reservations assigned to them. The inventory database can be used to create
a view of a Kea hosts database and such view is often read only.
</p><p>
Kea host database backends operate with an implicit configuration to both
read from and write to the database. If the database user does not have
write access to the host database, the backend will fail to start and the
server will refuse to start (or reconfigure). However, if access to a read
only host database is required for retrieving reservations for clients
and/or assign specific addresses and options, it is possible to explicitly
configure Kea to start in "read-only" mode. This is controlled by the
<span class="command"><strong>readonly</strong></span> boolean parameter as follows:
</p><pre class="screen">
"Dhcp6": { "hosts-database": { <strong class="userinput"><code>"readonly": true</code></strong>, ... }, ... }
</pre><p>
Setting this parameter to <strong class="userinput"><code>false</code></strong> would configure the
database backend to operate in "read-write" mode, which is also a default
configuration if the parameter is not specified.
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="command"><strong>readonly</strong></span> parameter is currently only supported
for MySQL and PostgreSQL databases.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-interface-selection"></a>9.2.4. Interface Selection</h3></div></div></div><p>The DHCPv6 server has to be configured to listen on specific network
  interfaces.  The simplest network interface configuration instructs the server to
  listen on all available interfaces:
  </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"*"</code></strong> ]
    }
    ...
}
</pre><p>
  The asterisk plays the role of a wildcard and means "listen on all interfaces".
  However, it is usually a good idea to explicitly specify interface names:
  </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3"</code></strong> ]
    },
    ...
}
  </pre><p>
</p><p>It is possible to use wildcard interface name (asterisk) concurrently
  with the actual interface names:
  </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3", "*"</code></strong> ]
    },
    ...
}
  </pre><p>
It is anticipated that this will form of usage only be used where it is desired to
temporarily override a list of interface names and listen on all interfaces.
  </p><p>As for the DHCPv4 server binding to specific addresses and
  disabling re-detection of interfaces are supported. But
  <span class="command"><strong>dhcp-socket-type</strong></span> is not because DHCPv6 uses
  UDP/IPv6 sockets only. The following example shows how to disable the
  interface detection:
  </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1", "eth3"</code></strong> ],
        "re-detect": <strong class="userinput"><code>false</code></strong>
    },
    ...
}
  </pre><p>The loopback interfaces (i.e. the "lo" or "lo0" interface)
  are not configured by default, unles explicitely mentioned in
  the configration. Note Kea requires a link-local address which does
  not exist on all systems, or a specified unicast address as in:
  </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"lo/::1"</code></strong> ]
    },
    ...
}
  </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="ipv6-subnet-id"></a>9.2.5. IPv6 Subnet Identifier</h3></div></div></div><p>
        The subnet identifier is a unique number associated with a particular subnet.
        In principle, it is used to associate clients' leases with their respective subnets.
        When a subnet identifier is not specified for a subnet being configured, it will
        be automatically assigned by the configuration mechanism. The identifiers
        are assigned from 1 and are monotonically increased for each subsequent
        subnet: 1, 2, 3 ....
      </p><p>
        If there are multiple subnets configured with auto-generated identifiers and
        one of them is removed, the subnet identifiers may be renumbered. For example:
        if there are four subnets and the third is removed the last subnet will be assigned
        the identifier that the third subnet had before removal. As a result, the leases
        stored in the lease database for subnet 3 are now associated with
        subnet 4, something that may have unexpected consequences. It is planned
        to implement a mechanism to preserve auto-generated subnet ids in a
        future version of Kea.  However, the only remedy for this issue
        at present is to
        manually specify a unique identifier for each subnet.
      </p><p>
        The following configuration will assign the specified subnet
        identifier to the newly configured subnet:

        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            <strong class="userinput"><code>"id": 1024</code></strong>,
            ...
        }
    ]
}
</pre><p>
        This identifier will not change for this subnet unless the "id" parameter is
        removed or set to 0. The value of 0 forces auto-generation of the subnet
        identifier.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-unicast"></a>9.2.6. Unicast Traffic Support</h3></div></div></div><p>
        When the DHCPv6 server starts, by default it listens to the DHCP traffic
        sent to multicast address ff02::1:2 on each interface that it is
        configured to listen on (see <a class="xref" href="#dhcp6-interface-selection" title="9.2.4. Interface Selection">Section 9.2.4, “Interface Selection”</a>).
        In some cases it is useful to configure a server to handle incoming
        traffic sent to the global unicast addresses as well. The most common
        reason for this is to have relays send their traffic to the server
        directly. To configure the server to listen on a specific unicast address,
        nn interface name can be
        optionally followed by a slash, followed by the global unicast address on which
        the server should listen. The server listens to this address in addition to normal
        link-local binding and listening on ff02::1:2 address. The sample configuration
        below shows how to listen on 2001:db8::1 (a global address)
        configured on the eth1 interface.
      </p><p>
 </p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ <strong class="userinput"><code>"eth1/2001:db8::1"</code></strong> ]
    },
    ...
    "option-data": [
        {
            "name": "unicast",
            "data": "2001:db8::1"
        } ],
    ...
}
 </pre><p>

        This configuration will cause the server to listen on
        eth1 on the link-local address, the multicast group (ff02::1:2) and 2001:db8::1.
      </p><p>
        Usually unicast support is associated with a server unicast option
        which allows clients to send unicast messages to the server.
        The example above includes a server unicast option specification
        which will cause the client to send messages to the specified
        unicast address.
      </p><p>
        It is possible to mix interface names, wildcards and interface name/addresses
        in the list of interfaces. It is not possible however to specify more than one
        unicast address on a given interface.
      </p><p>
        Care should be taken to specify proper unicast addresses. The server will
        attempt to bind to the addresses specified without any additional checks.
        This approach has selected on purpose to allow the software to
        communicate over uncommon addresses if so desired.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-address-config"></a>9.2.7. Subnet and Address Pool</h3></div></div></div><p>
        The main role of a DHCPv6 server is address assignment. For this,
        the server has to be configured with at least one subnet and one pool of dynamic
        addresses to be managed. For example, assume that the server
        is connected to a network segment that uses the 2001:db8:1::/64
        prefix. The Administrator of that network has decided that addresses from range
        2001:db8:1::1 to 2001:db8:1::ffff are going to be managed by the Dhcp6
        server. Such a configuration can be achieved in the following way:
        </p><pre class="screen">
"Dhcp6": {
    <strong class="userinput"><code>"subnet6": [
       {
           "subnet": "2001:db8:1::/64",
           "pools": [
               {
                   "pool": "2001:db8:1::1-2001:db8:1::ffff"
               }
           ],
           ...
       }
    ]</code></strong>
}</pre><p>

        Note that <span class="command"><strong>subnet</strong></span> is defined as a simple string, but
        the <span class="command"><strong>pools</strong></span> parameter is actually a list of pools: for
        this reason, the pool definition is enclosed in square brackets, even
        though only one range of addresses is specified.</p><p>Each <span class="command"><strong>pool</strong></span> is a structure that contains the
        parameters that describe a single pool. Currently there is only one
        parameter, <span class="command"><strong>pool</strong></span>, which gives the range of addresses
        in the pool. Additional parameters will be added in future releases of
        Kea.</p><p>It is possible to define more than one pool in a
        subnet: continuing the previous example, further assume that
        2001:db8:1:0:5::/80 should also be managed by the server. It could be written as
        2001:db8:1:0:5:: to 2001:db8:1::5:ffff:ffff:ffff, but typing so many 'f's
        is cumbersome. It can be expressed more simply as 2001:db8:1:0:5::/80. Both
        formats are supported by Dhcp6 and can be mixed in the pool list.
        For example, one could define the following pools:
        </p><pre class="screen">
"Dhcp6": {
    <strong class="userinput"><code>"subnet6": [
    {
        "subnet": "2001:db8:1::/64",
        "pools": [
            { "pool": "2001:db8:1::1-2001:db8:1::ffff" },
            { "pool": "2001:db8:1:05::/80" }
        ]</code></strong>,
        ...
    }
    ]
}</pre><p>
        White space in pool definitions is ignored, so spaces before and after the hyphen are optional.
        They can be used to improve readability.
      </p><p>
        The number of pools is not limited, but for performance reasons it is recommended to
        use as few as possible.
      </p><p>
         The server may be configured to serve more than one subnet. To add a second subnet,
         use a command similar to the following:
        </p><pre class="screen">
"Dhcp6": {
    <strong class="userinput"><code>"subnet6": [
    {
        "subnet": "2001:db8:1::/64",
        "pools": [
            { "pool": "2001:db8:1::1-2001:db8:1::ffff" }
        ]
    },
    {
        "subnet": "2001:db8:2::/64",
        "pools": [
            { "pool": "2001:db8:2::/64" }
        ]
    },
</code></strong>
        ...
    ]
}</pre><p>
        In this example, we allow the server to
        dynamically assign all addresses available in the whole subnet. Although
        rather wasteful, it is certainly a valid configuration to dedicate the
        whole /64 subnet for that purpose. Note that the Kea server does not preallocate
        the leases, so there is no danger in using gigantic address pools.
      </p><p>
        When configuring a DHCPv6 server using prefix/length notation, please pay
        attention to the boundary values. When specifying that the server can use
        a given pool, it will also be able to allocate the first (typically network
        address) address from that pool. For example, for pool 2001:db8:2::/64 the
        2001:db8:2:: address may be assigned as well. If you want to avoid this,
        use the "min-max" notation.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57326512"></a>9.2.8. Subnet and Prefix Delegation Pools</h3></div></div></div><p>
        Subnets may also be configured to delegate prefixes, as defined in
        <a class="ulink" href="http://tools.ietf.org/html/rfc3633" target="_top">RFC 3633</a>.  A
        subnet may have one or more prefix delegation pools.  Each pool has a
        prefixed address, which is specified as a prefix
        (<span class="command"><strong>prefix</strong></span>) and a prefix length
        (<span class="command"><strong>prefix-len</strong></span>), as well as a delegated prefix length
        (<span class="command"><strong>delegated-len</strong></span>). The delegated length must not be
        shorter (that is it must be numerically greater or equal) than the
        prefix length.  If both the delegated and prefix lengths are equal, the
        server will be able to delegate only one prefix. The delegated prefix
        does not have to match the subnet prefix.
      </p><p> Below is a sample subnet configuration which enables prefix
      delegation for the subnet:
      </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:d8b:1::/64",
            <strong class="userinput"><code>"pd-pools": [
                {
                    "prefix": "3000:1::",
                    "prefix-len": 64,
                    "delegated-len": 96
                }
            ]</code></strong>
        }
    ],
    ...
}</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="pd-exclude-option"></a>9.2.9. Prefix Exclude Option</h3></div></div></div><p>
          For each delegated prefix the delegating router may choose to exclude
          a single prefix out of the delegated prefix as specified in the
          <a class="ulink" href="http://tools.ietf.org/html/rfc6603" target="_top"> RFC 6603</a>.
          The requesting router must not assign the excluded prefix to any
          of its downstream interfaces and it is intended to be used on a
          link through which the delegating router exchanges DHCPv6 messages with
          the requesting router. The configuration example below demonstrates how
          to specify an excluded prefix within a prefix pool definition. The
          excluded prefix "2001:db8:1:babe:cafe:80::/72" will be sent to a
          requesting router which includes Prefix Exclude option in the ORO, and
          which is delegated a prefix from this pool.
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/48",
            "pd-pools": [
                {
                    "prefix": "2001:db8:1:8000::",
                    "prefix-len": 48,
                    "delegated-len": 64,
                    "excluded-prefix": "2001:db8:1:babe:cafe:80::",
                    "excluded-prefix-len": 72
                }
            ]
        }
    ]
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-std-options"></a>9.2.10. Standard DHCPv6 Options</h3></div></div></div><p>
        One of the major features of a DHCPv6 server is to provide configuration
        options to clients.  Although there are several options that require
        special behavior, most options are sent by the server only if the client
        explicitly requests them.  The following example shows how to
        configure DNS servers, one of the most frequently used
        options.  Options specified in this way are considered
        global and apply to all configured subnets.

        </p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "dns-servers",
           "code": 23,
           "space": "dhcp6",
           "csv-format": true,
           "data": "2001:db8::cafe, 2001:db8::babe"</code></strong>
        },
        ...
    ]
}
</pre><p>
      </p><p>
      The <span class="command"><strong>option-data</strong></span> line creates a new entry in
      the option-data table.  This table contains
      information on all global options that the server is supposed to configure
      in all subnets.  The <span class="command"><strong>name</strong></span> line specifies the option name.
      (For a complete list
      of currently supported names, see <a class="xref" href="#dhcp6-std-options-list" title="Table 9.1. List of Standard DHCPv6 Options">Table 9.1, “List of Standard DHCPv6 Options”</a>.)  The next line specifies the option code,
      which must match one of the values from that list. The line beginning with
      <span class="command"><strong>space</strong></span> specifies the option space, which must always be set
      to "dhcp6" as these are standard DHCPv6 options.  For other name spaces,
      including custom option spaces, see <a class="xref" href="#dhcp6-option-spaces" title="9.2.14. Nested DHCPv6 Options (Custom Option Spaces)">Section 9.2.14, “Nested DHCPv6 Options (Custom Option Spaces)”</a>. The following line specifies the format in
      which the data will be entered: use of CSV (comma separated values) is
      recommended. Finally, the <span class="command"><strong>data</strong></span> line gives the actual value to be sent to
      clients.  Data is specified as normal text, with values separated by
      commas if more than one value is allowed.
    </p><p>
      Options can also be configured as hexadecimal values.  If "csv-format" is
      set to false, the option data must be specified as a string of hexadecimal
      numbers.  The
      following commands configure the DNS-SERVERS option for all
      subnets with the following addresses: 2001:db8:1::cafe and
      2001:db8:1::babe.
        </p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "dns-servers",
           "code": 23,
           "space": "dhcp6",
           "csv-format": false,
           "data": "2001 0DB8 0001 0000 0000 0000 0000 CAFE
                    2001 0DB8 0001 0000 0000 0000 0000 BABE"</code></strong>
        },
        ...
    ]
}
        </pre><p>
       </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
       The value for the setting of the "data" element is split across two
       lines in this example for clarity: when entering the command, the
       whole string should be entered on the same line.
       </p></div><p>
       Care should be taken
       to use proper encoding when using hexadecimal format as Kea's ability
       to validate data correctness in hexadecimal is limited.
      </p><p>
        Most of the parameters in the "option-data" structure are
        optional and can be omitted in some circumstances as discussed
        in the <a class="xref" href="#dhcp6-option-data-defaults" title="9.2.15. Unspecified Parameters for DHCPv6 Option Configuration">Section 9.2.15, “Unspecified Parameters for DHCPv6 Option Configuration”</a>. Only one
        of name or code is required, so you don't need to specify
        both. Space has a default value of "dhcp6", so you can skip
        this as well if you define a regular (not encapsulated) DHCPv6
        option.  Finally, csv-format defaults to true, so it too can
        be skipped, unless you want to specify the option value as
        hexstring. Therefore the above example can be simplified to:
        </p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "dns-servers",
           "data": "2001:db8::cafe, 2001:db8::babe"</code></strong>
        },
        ...
    ]
}
        </pre><p>
        Defined options are added to response when the client requests them
        at a few exceptions which are always added. To enforce the addition
        of a particular option set the always-send flag to true as in:
        </p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "dns-servers",
           "data": "2001:db8::cafe, 2001:db8::babe",
           "always-send": true</code></strong>
        },
        ...
    ]
}
        </pre><p>
        The effect is the same as if the client added the option code in the
        Option Request Option (or its equivalent for vendor options) so in:
        </p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
           <strong class="userinput"><code>"name": "dns-servers",
           "data": "2001:db8::cafe, 2001:db8::babe",
           "always-send": true</code></strong>
        },
        ...
    ],
    "subnet6": [
        {
           "subnet": "2001:db8:1::/64",
           "option-data": [
               {
                   <strong class="userinput"><code>"name": "dns-servers",
                   "data": "2001:db8:1::cafe, 2001:db8:1::babe"</code></strong>
               },
               ...
           ],
           ...
        },
        ...
    ],
    ...
}
        </pre><p>
        The DNS Servers option is always added to responses
        (the always-send is "sticky") but the value is the subnet one
        when the client is localized in the subnet.
      </p><p>
      It is possible to override options on a per-subnet basis.  If
      clients connected to most of your subnets are expected to get the
      same values of a given option, you should use global options: you
      can then override specific values for a small number of subnets.
      On the other hand, if you use different values in each subnet,
      it does not make sense to specify global option values
      (Dhcp6/option-data), rather you should set only subnet-specific values
      (Dhcp6/subnet[X]/option-data[Y]).
     </p><p>
      The following commands override the global
      DNS servers option for a particular subnet, setting a single DNS
      server with address 2001:db8:1::3.
</p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            <strong class="userinput"><code>"option-data": [
                {
                    "name": "dns-servers",
                    "code": 23,
                    "space": "dhcp6",
                    "csv-format": true,
                    "data": "2001:db8:1::3"
                },
                ...
            ]</code></strong>,
            ...
        },
        ...
    ],
    ...
}
</pre><p>
    </p><p>
       In some cases it is useful to associate some options with an
       address or prefix pool from which a client is assigned a lease. Pool
       specific option values override subnet specific and global option
       values. If the client is assigned multiple leases from different
       pools, the server will assign options from all pools from which the
       leases have been obtained. However, if the particular option is specified
       in multiple pools from which the client obtains the leases, only one
       instance of this option will be handed out to the client. The server's
       administrator must not try to prioritize assignment of pool specific
       options by trying to order pools declarations in the server
       configuration. Future Kea releases may change the order in which
       options are assigned from the pools without any notice.
     </p><p>
       The following configuration snippet demonstrates how to specify the
       DNS servers option, which will be assigned to a client only if the
       client obtains an address from the given pool:
</p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "pools": [
                {
                    "pool": "2001:db8:1::100-2001:db8:1::300",
                    <strong class="userinput"><code>"option-data": [
                        {
                            "name": "dns-servers",
                            "data": "2001:db8:1::10"
                        }
                    ]</code></strong>
                }
            ]
        },
        ...
    ],
    ...
}
</pre><p>
     </p><p>
      The currently supported standard DHCPv6 options are
      listed in <a class="xref" href="#dhcp6-std-options-list" title="Table 9.1. List of Standard DHCPv6 Options">Table 9.1, “List of Standard DHCPv6 Options”</a>.
      The "Name" and "Code"
      are the values that should be used as a name in the option-data
      structures. "Type" designates the format of the data: the meanings of
      the various types is given in <a class="xref" href="#dhcp-types" title="Table 8.2. List of standard DHCP option types">Table 8.2, “List of standard DHCP option types”</a>.
    </p><p>
      Experimental options (like standard options but with a code
      which was not assigned by IANA) are listed in
      <a class="xref" href="#dhcp6-exp-options-list" title="Table 9.2. List of Experimental DHCPv6 Options">Table 9.2, “List of Experimental DHCPv6 Options”</a>.
    </p><p>When a data field is a string, and that string contains
    the comma (,; U+002C) character, the comma must be escaped with a
    reverse solidus character (\; U+005C). This double escape is
    required, because both the routine splitting CSV data into fields
    and JSON use the same escape character: a single escape (\,) would
    make the JSON invalid. For example, the string
    "EST5EDT4,M3.2.0/02:00,M11.1.0/02:00" would be
    represented as:
</p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "pools": [
                {
                    <strong class="userinput"><code>"option-data": [
                        {
                            "name": "new-posix-timezone",
                            "data": "EST5EDT4\,M3.2.0/02:00\,M11.1.0/02:00"
                        }
                    ]</code></strong>
                },
                ...
            ],
            ...
        },
        ...
    ],
    ...
}
</pre><p>
    </p><p>
      Some options are designated as arrays, which means that more than one
      value is allowed in such an option. For example the option dns-servers
      allows the specification of more than one IPv6 address, allowing
      clients to obtain the addresses of multiple DNS servers.
    </p><p>
        The <a class="xref" href="#dhcp6-custom-options" title="9.2.12. Custom DHCPv6 Options">Section 9.2.12, “Custom DHCPv6 Options”</a> describes the configuration
        syntax to create custom option definitions (formats). It is generally not
        allowed to create custom definitions for standard options, even if the
        definition being created matches the actual option format defined in the
        RFCs. There is an exception from this rule for standard options for which
        Kea does not yes provide a definition. In order to use such options,
        a server administrator must create a definition as described in
        <a class="xref" href="#dhcp6-custom-options" title="9.2.12. Custom DHCPv6 Options">Section 9.2.12, “Custom DHCPv6 Options”</a> in the 'dhcp6' option space. This
        definition should match the option format described in the relevant
        RFC but the configuration mechanism would allow any option format as it has
        no means to validate the format at the moment.
      </p><p>
      </p><div class="table"><a name="dhcp6-std-options-list"></a><p class="title"><b>Table 9.1. List of Standard DHCPv6 Options</b></p><div class="table-contents"><table summary="List of Standard DHCPv6 Options" border="1"><colgroup><col class="name"><col align="center" class="code"><col align="center" class="type"><col align="center" class="array"></colgroup><thead><tr><th>Name</th><th align="center">Code</th><th align="center">Type</th><th align="center">Array?</th></tr></thead><tbody><tr><td>preference</td><td align="center">7</td><td align="center">uint8</td><td align="center">false</td></tr><tr><td>unicast</td><td align="center">12</td><td align="center">ipv6-address</td><td align="center">false</td></tr><tr><td>vendor-opts</td><td align="center">17</td><td align="center">uint32</td><td align="center">false</td></tr><tr><td>sip-server-dns</td><td align="center">21</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>sip-server-addr</td><td align="center">22</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>dns-servers</td><td align="center">23</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>domain-search</td><td align="center">24</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>nis-servers</td><td align="center">27</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>nisp-servers</td><td align="center">28</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>nis-domain-name</td><td align="center">29</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>nisp-domain-name</td><td align="center">30</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>sntp-servers</td><td align="center">31</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>information-refresh-time</td><td align="center">32</td><td align="center">uint32</td><td align="center">false</td></tr><tr><td>bcmcs-server-dns</td><td align="center">33</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>bcmcs-server-addr</td><td align="center">34</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>geoconf-civic</td><td align="center">36</td><td align="center">record (uint8, uint16, hex)</td><td align="center">false</td></tr><tr><td>remote-id</td><td align="center">37</td><td align="center">record (uint32, hex)</td><td align="center">false</td></tr><tr><td>subscriber-id</td><td align="center">38</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>client-fqdn</td><td align="center">39</td><td align="center">record (uint8, fqdn)</td><td align="center">false</td></tr><tr><td>pana-agent</td><td align="center">40</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>new-posix-timezone</td><td align="center">41</td><td align="center">string</td><td align="center">false</td></tr><tr><td>new-tzdb-timezone</td><td align="center">42</td><td align="center">string</td><td align="center">false</td></tr><tr><td>ero</td><td align="center">43</td><td align="center">uint16</td><td align="center">true</td></tr><tr><td>lq-query (1)</td><td align="center">44</td><td align="center">record (uint8, ipv6-address)</td><td align="center">false</td></tr><tr><td>client-data (1)</td><td align="center">45</td><td align="center">empty</td><td align="center">false</td></tr><tr><td>clt-time (1)</td><td align="center">46</td><td align="center">uint32</td><td align="center">false</td></tr><tr><td>lq-relay-data (1)</td><td align="center">47</td><td align="center">record (ipv6-address, hex)</td><td align="center">false</td></tr><tr><td>lq-client-link (1)</td><td align="center">48</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>v6-lost</td><td align="center">51</td><td align="center">fqdn</td><td align="center">false</td></tr><tr><td>capwap-ac-v6</td><td align="center">52</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>relay-id</td><td align="center">53</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>v6-access-domain</td><td align="center">57</td><td align="center">fqdn</td><td align="center">false</td></tr><tr><td>sip-ua-cs-list</td><td align="center">58</td><td align="center">fqdn</td><td align="center">true</td></tr><tr><td>bootfile-url</td><td align="center">59</td><td align="center">string</td><td align="center">false</td></tr><tr><td>bootfile-param</td><td align="center">60</td><td align="center">tuple</td><td align="center">true</td></tr><tr><td>client-arch-type</td><td align="center">61</td><td align="center">uint16</td><td align="center">true</td></tr><tr><td>nii</td><td align="center">62</td><td align="center">record (uint8, uint8, uint8)</td><td align="center">false</td></tr><tr><td>aftr-name</td><td align="center">64</td><td align="center">fqdn</td><td align="center">false</td></tr><tr><td>erp-local-domain-name</td><td align="center">65</td><td align="center">fqdn</td><td align="center">false</td></tr><tr><td>rsoo</td><td align="center">66</td><td align="center">empty</td><td align="center">false</td></tr><tr><td>pd-exclude</td><td align="center">67</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>rdnss-selection</td><td align="center">74</td><td align="center">record (ipv6-address, uint8, fqdn)</td><td align="center">true</td></tr><tr><td>client-linklayer-addr</td><td align="center">79</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>link-address</td><td align="center">80</td><td align="center">ipv6-address</td><td align="center">false</td></tr><tr><td>solmax-rt</td><td align="center">82</td><td align="center">uint32</td><td align="center">false</td></tr><tr><td>inf-max-rt</td><td align="center">83</td><td align="center">uint32</td><td align="center">false</td></tr><tr><td>dhcp4o6-server-addr</td><td align="center">88</td><td align="center">ipv6-address</td><td align="center">true</td></tr><tr><td>s46-rule</td><td align="center">89</td><td align="center">record (uint8, uint8, uint8, ipv4-address, ipv6-prefix)</td><td align="center">false</td></tr><tr><td>s46-br</td><td align="center">90</td><td align="center">ipv6-address</td><td align="center">false</td></tr><tr><td>s46-dmr</td><td align="center">91</td><td align="center">ipv6-prefix</td><td align="center">false</td></tr><tr><td>s46-v4v6bind</td><td align="center">92</td><td align="center">record (ipv4-address, ipv6-prefix)</td><td align="center">false</td></tr><tr><td>s46-portparams</td><td align="center">93</td><td align="center">record(uint8, psid)</td><td align="center">false</td></tr><tr><td>s46-cont-mape</td><td align="center">94</td><td align="center">empty</td><td align="center">false</td></tr><tr><td>s46-cont-mapt</td><td align="center">95</td><td align="center">empty</td><td align="center">false</td></tr><tr><td>s46-cont-lw</td><td align="center">96</td><td align="center">empty</td><td align="center">false</td></tr><tr><td>v6-captive-portal</td><td align="center">103</td><td align="center">string</td><td align="center">false</td></tr><tr><td>ipv6-address-andsf</td><td align="center">143</td><td align="center">ipv6-address</td><td align="center">true</td></tr></tbody></table></div></div><p><br class="table-break">
      Options marked with (1) have option definitions, but the logic
      behind them is not implemented. That means that technically Kea
      knows how to parse them in incoming message or how to send them
      if configured to do so, but not what to do with them. Since the
      related RFCs require certain processing, the support for those
      options is non-functional. However, it may be useful in some
      limited lab testing, hence the definition formats are listed here.
    </p><p>
      </p><div class="table"><a name="dhcp6-exp-options-list"></a><p class="title"><b>Table 9.2. List of Experimental DHCPv6 Options</b></p><div class="table-contents"><table summary="List of Experimental DHCPv6 Options" border="1"><colgroup><col class="name"><col align="center" class="code"><col align="center" class="type"><col align="center" class="array"></colgroup><thead><tr><th>Name</th><th align="center">Code</th><th align="center">Type</th><th align="center">Array?</th></tr></thead><tbody><tr><td>public-key</td><td align="center">701</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>certificate</td><td align="center">702</td><td align="center">hex</td><td align="center">false</td></tr><tr><td>signature</td><td align="center">703</td><td align="center">record (uint8, uint8, hex)</td><td align="center">false</td></tr><tr><td>timestamp</td><td align="center">704</td><td align="center">hex</td><td align="center">false</td></tr></tbody></table></div></div><p><br class="table-break">
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="s46-options"></a>9.2.11. Common Softwire46 Options</h3></div></div></div><p>
        Softwire46 options are involved in IPv4 over IPv6 provisioning by
        means of tunneling or translation as specified in the
        <a class="ulink" href="http://tools.ietf.org/html/rfc7598" target="_top">RFC 7598</a>.
        The following sections provide configuration examples of these
        options.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="s46-containers"></a>9.2.11.1. Softwire46 Container Options</h4></div></div></div><p>
        S46 container options group rules and optional port parameters
        for a specified domain. There are three container options specified
        in the "dhcp6" (top level) option space: MAP-E Container option,
        MAP-T Container option and S46 Lightweight 4over6 Container option.
        These options only contain encapsulated options specified below.
        They do not include any data fields.
      </p><p>
        In order to configure the server to send specific container option
        along with all encapsulated options, the container option must be
        included in the server configuration as shown below:
</p><pre class="screen">
"Dhcp6": {
    ...
    "option-data": [
        {
            "name": "s46-cont-mape"
        } ],
    ...
}
</pre><p>

        This configuration will cause the server to include MAP-E Container
        option to the client. Use "s46-cont-mapt" or "s46-cont-lw" for the
        MAP-T Container and S46 Lightweight 4over6 Container options
        respectively.
      </p><p>
        All remaining softwire options described below are included in one
        of the container options. Thus, they have to be included in appropriate
        option spaces by selecting a "space" name, which specifies in which
        option they are supposed to be included.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57483376"></a>9.2.11.2. S46 Rule Option</h4></div></div></div><p>
          The S46 Rule option is used for conveying the Basic Mapping Rule (BMR)
          and Forwarding Mapping Rule (FMR).
</p><pre class="screen">
{
    "space": "s46-cont-mape-options",
    "name": "s46-rule",
    "data": "128, 0, 24, 192.0.2.0, 2001:db8:1::/64"
}
</pre><p>
         Other possible "space" value is "s46-cont-mapt-options".
        </p><p>
          The S46 Rule option conveys a number of parameters:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>flags</strong></span>, an unsigned 8 bits integer, with
          currently only the most significant bit specified. It denotes whether
          the rule can be used for forwarding (128) or not (0).
          </li><li class="listitem"><span class="command"><strong>ea-len</strong></span>, an 8 bits long Embedded Address length. Allowed values
          range from 0 to 48.</li><li class="listitem"><span class="command"><strong>IPv4 prefix length</strong></span>, 8 bits long; expresses the prefix length of the
          Rule IPv4 prefix specified in the ipv4-prefix field.  Allowed
          values range from 0 to 32.</li><li class="listitem"><span class="command"><strong>IPv4 prefix</strong></span>, a fixed-length 32-bit field that specifies the IPv4
          prefix for the S46 rule.  The bits in the prefix after prefix4-len
          number of bits are reserved and MUST be initialized to zero by the
          sender and ignored by the receiver.</li><li class="listitem"><span class="command"><strong>IPv6 prefix</strong></span> in prefix/length notation that specifies the IPv6 domain
          prefix for the S46 rule.  The field is padded on the right with zero
          bits up to the nearest octet boundary when prefix6-len is not evenly
          divisible by 8.</li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57491968"></a>9.2.11.3. S46 BR Option</h4></div></div></div><p>
              The S46 BR option is used to convey the IPv6 address of the
              Border Relay. This option is mandatory in the MAP-E
              Container option and not permitted in the MAP-T and
              S46 Lightweight 4over6 Container options.
</p><pre class="screen">
{
    "space": "s46-cont-mape-options",
    "name": "s46-br",
    "data": "2001:db8:cafe::1",
}
</pre><p>
           Other possible "space" value is "s46-cont-lw-options".
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57495312"></a>9.2.11.4. S46 DMR Option</h4></div></div></div><p>
              The S46 DMR option is used to convey values for the Default
              Mapping Rule (DMR). This option is mandatory in the MAP-T
              container option and not permitted in the MAP-E and S46
              Lightweight 4over6 Container options.
</p><pre class="screen">
{
    "space": "s46-cont-mapt-options",
    "name": "s46-dmr",
    "data": "2001:db8:cafe::/64",
}
</pre><p>
              This option must not be included in other containers.
            </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57497376"></a>9.2.11.5. S46 IPv4/IPv6 Address Binding option.</h4></div></div></div><p>
              The S46 IPv4/IPv6 Address Binding option may be used to specify
              the full or shared IPv4 address of the Customer Edge (CE).
              The IPv6 prefix field is used by the CE to identify the
              correct prefix to use for the tunnel source.
</p><pre class="screen">
{
    "space": "s46-cont-lw",
    "name": "s46-v4v6bind",
    "data": "192.0.2.3, 2001:db8:1:cafe::/64"
}
</pre><p>
            This option must not be included in other containers.
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57499744"></a>9.2.11.6. S46 Port Parameters</h4></div></div></div><p>
              The S46 Port Parameters option specifies optional port set
              information that MAY be provided to CEs
</p><pre class="screen">
{
    "space": "s46-rule-options",
    "name": "s46-portparams",
    "data": "2, 3/4",
}
</pre><p>
              Other possible "space" value is "s46-v4v6bind" to include
              this option in the S46 IPv4/IPv6 Address Binding option.
            </p><p>
              Note that the second value in the example above specifies the
              PSID and PSID length fields in the format of PSID/PSID length.
              This is equivalent to the values of PSID-len=4 and
              PSID=12288 conveyed in the S46 Port Parameters option.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-custom-options"></a>9.2.12. Custom DHCPv6 Options</h3></div></div></div><p>It is possible to define options in addition to the standard ones.
      Assume that we want to define a new DHCPv6 option called "foo" which will have
      code 100 and which will convey a single unsigned 32 bit integer value. We can define
      such an option by using the following commands:
</p><pre class="screen">
"Dhcp6": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 100,
            "type": "uint32",
            "array": false,
            "record-types": "",
            "space": "dhcp6",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The "false" value of the <span class="command"><strong>array</strong></span> parameter determines that the option does
      NOT comprise an array of "uint32" values but rather a single value.  Two
      other parameters have been left blank: <span class="command"><strong>record-types</strong></span> and
      <span class="command"><strong>encapsulate</strong></span>.
      The former specifies the comma separated list of option data fields if the
      option comprises a record of data fields. The <span class="command"><strong>record-types</strong></span> value should
      be non-empty if the <span class="command"><strong>type</strong></span> is set to "record". Otherwise it must be left
      blank. The latter parameter specifies the name of the option space being
      encapsulated by the particular option. If the particular option does not
      encapsulate any option space it should be left blank.  Note that the above
      example only defines the format of the new option, it does not set its
      value(s).
      </p><p>The <span class="command"><strong>name</strong></span>, <span class="command"><strong>code</strong></span> and
      <span class="command"><strong>type</strong></span> parameters are required, all others are
      optional. The <span class="command"><strong>array</strong></span> default value is
      <span class="command"><strong>false</strong></span>. The <span class="command"><strong>record-types</strong></span>
      and <span class="command"><strong>encapsulate</strong></span> default values are blank
      (i.e. ""). The default <span class="command"><strong>space</strong></span> is "dhcp6".
      </p><p>Once the new option format is defined, its value is set
      in the same way as for a standard option. For example the following
      commands set a global value that applies to all subnets.
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 100,
            "space": "dhcp6",
            "csv-format": true,
            "data": "12345"</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      </p><p>New options can take more complex forms than simple use of
      primitives (uint8, string, ipv6-address etc): it is possible to
      define an option comprising a number of existing primitives.
      </p><p>
      For example, assume we want to define a new option that will consist of an IPv6
      address, followed by an unsigned 16 bit integer, followed by a
      boolean value, followed by a text string. Such an option could
      be defined in the following way:
</p><pre class="screen">
"Dhcp6": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "bar",
            "code": 101,
            "space": "dhcp6",
            "type": "record",
            "array": false,
            "record-types": "ipv6-address, uint16, boolean, string",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The "type" is set to "record" to indicate that the option contains
      multiple values of different types.  These types are given as a comma-separated
      list in the "record-types" field and should be those listed in <a class="xref" href="#dhcp-types" title="Table 8.2. List of standard DHCP option types">Table 8.2, “List of standard DHCP option types”</a>.
      </p><p>
      The values of the option are set as follows:
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "bar",
            "space": "dhcp6",
            "code": 101,
            "csv-format": true,
            "data": "2001:db8:1::10, 123, false, Hello World"</code></strong>
        }
    ],
    ...
}</pre><p>

      <span class="command"><strong>csv-format</strong></span> is set <span class="command"><strong>true</strong></span> to indicate
      that the <span class="command"><strong>data</strong></span> field comprises a command-separated list
      of values.  The values in the "data" must correspond to the types set in
      the "record-types" field of the option definition.
      </p><p>
      When <span class="command"><strong>array</strong></span> is set to <span class="command"><strong>true</strong></span>
      and <span class="command"><strong>type</strong></span> is set to "record", the last field
      is an array, i.e., it can contain more than one value as in:
</p><pre class="screen">
"Dhcp6": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "bar",
            "code": 101,
            "space": "dhcp6",
            "type": "record",
            "array": true,
            "record-types": "ipv6-address, uint16",
            "encapsulate": ""</code></strong>
        }, ...
    ],
    ...
}
</pre><p>
      The new option content is one IPv6 address followed by one or more 16
      bit unsigned integers.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In the general case, boolean values are specified as <span class="command"><strong>true</strong></span> or
       <span class="command"><strong>false</strong></span>, without quotes. Some specific boolean parameters may
       accept also <span class="command"><strong>"true"</strong></span>, <span class="command"><strong>"false"</strong></span>,
       <span class="command"><strong>0</strong></span>, <span class="command"><strong>1</strong></span>, <span class="command"><strong>"0"</strong></span> and
       <span class="command"><strong>"1"</strong></span>. Future versions of Kea will accept all those values
       for all boolean parameters.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-vendor-opts"></a>9.2.13. DHCPv6 Vendor-Specific Options</h3></div></div></div><p>
      Currently there are two option spaces defined for the DHCPv6
      daemon: "dhcp6" (for top level DHCPv6 options) and "vendor-opts-space",
      which is empty by default, but in which options can be defined.
      Those options will be carried in the Vendor-Specific
      Information option (code 17). The following examples show how to
      define an option "foo" with code 1 that consists of an IPv6 address,
      an unsigned 16 bit integer and a string. The "foo" option is
      conveyed in a Vendor-Specific Information option. This option
      comprises a single uint32 value that is set to "12345".
      The sub-option "foo" follows the data field holding this value.
      </p><pre class="screen">
"Dhcp6": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "foo",
            "code": 1,
            "space": "vendor-opts-space",
            "type": "record",
            "array": false,
            "record-types": "ipv6-address, uint16, string",
            "encapsulate": ""</code></strong>
        }
    ],
    ...
}</pre><p>
     (Note that the option space is set to <span class="command"><strong>vendor-opts-space</strong></span>.)
     Once the option format is defined, the next step is to define actual values
     for that option:
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "foo",
            "space": "vendor-opts-space",
            "data": "2001:db8:1::10, 123, Hello World"</code></strong>
        },
        ...
    ],
    ...
}</pre><p>
    We should also define a value (enterprise-number) for the
    Vendor-specific Information option, that conveys our option "foo".
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        ...,
        {
            <strong class="userinput"><code>"name": "vendor-opts",
            "data": "12345"</code></strong>
        }
    ],
    ...
}</pre><p>
    Alternatively, the option can be specified using its code.
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        ...,
        {
            <strong class="userinput"><code>"code": 17,
            "data": "12345"</code></strong>
        }
    ],
    ...
}</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-option-spaces"></a>9.2.14. Nested DHCPv6 Options (Custom Option Spaces)</h3></div></div></div><p>It is sometimes useful to define completely new option
      spaces.  This is useful if the user wants their new option to
      convey sub-options that use a separate numbering scheme, for
      example sub-options with codes 1 and 2. Those option codes
      conflict with standard DHCPv6 options, so a separate option
      space must be defined.
      </p><p>Note that it is not required to create a new option space when
      defining sub-options for a standard option because it is
      created by default if the standard option is meant to convey
      any sub-options (see <a class="xref" href="#dhcp6-vendor-opts" title="9.2.13. DHCPv6 Vendor-Specific Options">Section 9.2.13, “DHCPv6 Vendor-Specific Options”</a>).
      </p><p>
      Assume that we want to have a DHCPv6 option called "container"
      with code 102 that conveys two sub-options with codes 1 and 2.
      First we need to define the new sub-options:
</p><pre class="screen">
"Dhcp6": {
    "option-def": [
        {
            <strong class="userinput"><code>"name": "subopt1",
            "code": 1,
            "space": "isc",
            "type": "ipv6-address",
            "record-types": "",
            "array": false,
            "encapsulate": ""</code></strong>
        },
        {
            <strong class="userinput"><code>"name": "subopt2",
            "code": 2,
            "space": "isc",
            "type": "string",
            "record-types": "",
            "array": false
            "encapsulate": ""</code></strong>
        }
    ],
    ...
}</pre><p>
    Note that we have defined the options to belong to a new option space
    (in this case, "isc").
    </p><p>
The next step is to define a regular DHCPv6 option and specify that it
should include options from the isc option space:
</p><pre class="screen">
"Dhcp6": {
    "option-def": [
        ...,
        {
            <strong class="userinput"><code>"name": "container",
            "code": 102,
            "space": "dhcp6",
            "type": "empty",
            "array": false,
            "record-types": "",
            "encapsulate": "isc"</code></strong>
        }
    ],
    ...
}</pre><p>

    The name of the option space in which the sub-options are defined is set in
    the <span class="command"><strong>encapsulate</strong></span> field. The <span class="command"><strong>type</strong></span> field
    is set to <span class="command"><strong>empty</strong></span> which limits this option to only carrying
    data in sub-options.
    </p><p>
    Finally, we can set values for the new options:
</p><pre class="screen">
"Dhcp6": {
    "option-data": [
        {
            <strong class="userinput"><code>"name": "subopt1",
            "code": 1,
            "space": "isc",
            "data": "2001:db8::abcd"</code></strong>
        },
        }
            <strong class="userinput"><code>"name": "subopt2",
            "code": 2,
            "space": "isc",
            "data": "Hello world"</code></strong>
        },
        {
            <strong class="userinput"><code>"name": "container",
            "code": 102,
            "space": "dhcp6"</code></strong>
        }
    ],
    ...
}
</pre><p>
    </p><p>Note that it is possible to create an option which carries some data
    in addition to the sub-options defined in the encapsulated option space.
    For example, if the "container" option from the previous example was
    required to carry an uint16 value as well as the sub-options, the "type"
    value would have to be set to "uint16" in the option definition. (Such an
    option would then have the following data structure: DHCP header, uint16
    value, sub-options.) The value specified with the "data" parameter — which
    should be a valid integer enclosed in quotes, e.g. "123" — would then be
    assigned to the uint16 field in the "container" option.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-option-data-defaults"></a>9.2.15. Unspecified Parameters for DHCPv6 Option Configuration</h3></div></div></div><p>In many cases it is not required to specify all parameters for
      an option configuration and the default values can be used. However, it is
      important to understand the implications of not specifying some of them
      as it may result in configuration errors. The list below explains
      the behavior of the server when a particular parameter is not explicitly
      specified:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>name</strong></span> - the server requires an option name or
          option code to identify an option. If this parameter is unspecified, the
          option code must be specified.
          </li><li class="listitem"><span class="command"><strong>code</strong></span> - the server requires an option name or
          option code to identify an option. This parameter may be left unspecified if
          the <span class="command"><strong>name</strong></span> parameter is specified. However, this also
          requires that the particular option has its definition (it is either a
          standard option or an administrator created a definition for the option
          using an 'option-def' structure), as the option definition associates an
          option with a particular name. It is possible to configure an option
          for which there is no definition (unspecified option format).
          Configuration of such options requires the use of option code.
          </li><li class="listitem"><span class="command"><strong>space</strong></span> - if the option space is unspecified it
          will default to 'dhcp6' which is an option space holding DHCPv6 standard
          options.
          </li><li class="listitem"><span class="command"><strong>data</strong></span> - if the option data is unspecified it
          defaults to an empty value. The empty value is mostly used for the
          options which have no payload (boolean options), but it is legal to specify
          empty values for some options which carry variable length data and which
          spec allows for the length of 0. For such options, the data parameter
          may be omitted in the configuration.</li><li class="listitem"><span class="command"><strong>csv-format</strong></span> - if this value is not
          specified the server will assume that the option data is specified as
          a list of comma separated values to be assigned to individual fields
          of the DHCP option. This behavior has changed in Kea 1.2. Older
          versions used additional logic to determine whether the csv-format
          should be true or false. That is no longer the case.
          </li></ul></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-config-subnets"></a>9.2.16. IPv6 Subnet Selection</h3></div></div></div><p>
        The DHCPv6 server may receive requests from local (connected to the
        same subnet as the server) and remote (connecting via relays) clients.
        As the server may have many subnet configurations defined, it must select
        an appropriate subnet for a given request.
      </p><p>
        The server can not assume which of the configured subnets are local. In IPv4
        it is possible as there is a reasonable expectation that the
        server will have a (global) IPv4 address configured on the interface,
        and can use that information to detect whether a subnet is local or
        not. That assumption is not true in IPv6: the DHCPv6 server must be able
        to operate while only using link-local addresses. Therefore an optional
        <span class="command"><strong>interface</strong></span> parameter is available within a subnet definition
        to designate that a given subnet is local, i.e. reachable directly over
        the specified interface. For example the server that is intended to serve
        a local subnet over eth0 may be configured as follows:
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:beef::/48",
            "pools": [
                 {
                     "pool": "2001:db8:beef::/48"
                 }
             ],
            <strong class="userinput"><code>"interface": "eth0"</code></strong>
        }
    ],
    ...
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-rapid-commit"></a>9.2.17. Rapid Commit</h3></div></div></div><p>The Rapid Commit option, described in
        <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>, is supported
        by the Kea DHCPv6 server. However, support is disabled by default for
        all subnets. It can be enabled for a particular subnet using the
        <span class="command"><strong>rapid-commit</strong></span> parameter as shown below:
</p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:beef::/48",
            <strong class="userinput"><code>"rapid-commit": true</code></strong>,
            "pools": [
                 {
                     "pool": "2001:db8:beef::1-2001:db8:beef::10"
                 }
             ],
        }
    ],
    ...
}
</pre><p>
        </p><p>
          This setting only affects the subnet for which the
          <span class="command"><strong>rapid-commit</strong></span> is set to <span class="command"><strong>true</strong></span>.
          For clients connected to other subnets, the server will ignore the
          Rapid Commit option sent by the client and will follow the 4-way
          exchange procedure, i.e. respond with an Advertise for a Solicit
          containing a Rapid Commit option.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-relays"></a>9.2.18. DHCPv6 Relays</h3></div></div></div><p>
          A DHCPv6 server with multiple subnets defined must select the
          appropriate subnet when it receives a request from a client.  For clients
          connected via relays, two mechanisms are used:
        </p><p>
          The first uses the linkaddr field in the RELAY_FORW message. The name
          of this field is somewhat misleading in that it does not contain a link-layer
          address: instead, it holds an address (typically a global address) that is
          used to identify a link. The DHCPv6 server checks if the address belongs
          to a defined subnet and, if it does, that subnet is selected for the client's
          request.
        </p><p>
          The second mechanism is based on interface-id options. While forwarding a client's
          message, relays may insert an interface-id option into the message that
          identifies the interface on the relay that received the message. (Some
          relays allow configuration of that parameter, but it is sometimes
          hardcoded and may range from the very simple (e.g. "vlan100") to the very cryptic:
          one example seen on real hardware was "ISAM144|299|ipv6|nt:vp:1:110"). The
          server can use this information to select the appropriate subnet.
          The information is also returned to the relay which then knows the
          interface to use to transmit the response to the client. In order for
          this to work successfully, the relay interface IDs must be unique within
          the network and the server configuration must match those values.
        </p><p>
          When configuring the DHCPv6 server, it should be noted that two
          similarly-named parameters can be configured for a subnet:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>interface</strong></span> defines which local network interface can be used
              to access a given subnet.
            </li><li class="listitem">
              <span class="command"><strong>interface-id</strong></span> specifies the content of the interface-id option
              used by relays to identify the interface on the relay to which
              the response packet is sent.
            </li></ul></div><p>
          The two are mutually exclusive: a subnet cannot be both reachable locally
          (direct traffic) and via relays (remote traffic). Specifying both is a
          configuration error and the DHCPv6 server will refuse such a configuration.
        </p><p>
          The following example configuration shows how to specify an interface-id with
          a value of "vlan123".
          </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:beef::/48",
            "pools": [
                 {
                     "pool": "2001:db8:beef::/48"
                 }
             ],
            <strong class="userinput"><code>"interface-id": "vlan123"</code></strong>
        }
    ],
    ...
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-rsoo"></a>9.2.19. Relay-Supplied Options</h3></div></div></div><p><a class="ulink" href="http://tools.ietf.org/html/rfc6422" target="_top">RFC 6422</a>
      defines a mechanism called Relay-Supplied DHCP Options. In certain cases relay
      agents are the only entities that may have specific information. They can
      insert options when relaying messages from the client to the server. The
      server will then do certain checks and copy those options to the response
      that will be sent to the client.</p><p>There are certain conditions that must be met for the option to be
      included. First, the server must not provide the option itself. In
      other words, if both relay and server provide an option, the server always
      takes precedence. Second, the option must be RSOO-enabled. IANA maintains a
      list of RSOO-enabled options <a class="ulink" href="http://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml#options-relay-supplied" target="_top">here</a>.
      However, there may be cases when system administrators want to echo other
      options. Kea can be instructed to treat other options as RSOO-enabled.
      For example, to mark options 110, 120 and 130 as RSOO-enabled, the following
      syntax should be used:
</p><pre class="screen">
"Dhcp6": {
    <strong class="userinput"><code>"relay-supplied-options": [ "110", "120", "130" ],</code></strong>
    ...
}
</pre><p>
      </p><p>As of March 2015, only option 65 is RSOO-enabled by IANA. This
      option will always be treated as such and there's no need to explicitly
      mark it. Also, when enabling standard options, it is possible to use their
      names, rather than option code, e.g. (e.g. use
      <span class="command"><strong>dns-servers</strong></span> instead of <span class="command"><strong>23</strong></span>). See
      <a class="xref" href="#dhcp6-std-options-list" title="Table 9.1. List of Standard DHCPv6 Options">Table 9.1, “List of Standard DHCPv6 Options”</a> for the names. In certain cases
      it could also work for custom options, but due to the nature of the parser
      code this may be unreliable and should be avoided.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-client-classifier"></a>9.2.20. Client Classification in DHCPv6</h3></div></div></div><p>
      The DHCPv6 server includes support for client classification.  For a deeper
      discussion of the classification process see <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
      </p><p>In certain cases it is useful to configure the server to differentiate between
      DHCP clients types and treat them accordingly. It is envisaged that client
      classification will be used for modifying the behavior of almost any part of
      the DHCP message processing. In the current release of Kea, there are three
      mechanisms that take advantage of the client classification in DHCPv6: subnet
      selection, address pool selection and DHCP options assignment.
      </p><p>
      In certain cases it is useful to differentiate between different types
      of clients and treat them accordingly. It is envisaged that client
      classification will be used for changing the behavior of almost any part of
      the DHCP message processing. In the current release of the software however,
      there are only some mechanisms that take advantage of client classification:
      subnet selection, pool selection, and assignment of different options.
      </p><p>
      Kea can be instructed to limit access to given subnets based on class information.
      This is particularly useful for cases where two types of devices share the
      same link and are expected to be served from two different subnets. The
      primary use case for such a scenario is cable networks. Here, there are two
      classes of devices: the cable modem itself, which should be handed a lease
      from subnet A and all other devices behind the modem that should get a lease
      from subnet B. That segregation is essential to prevent overly curious
      users from playing with their cable modems. For details on how to set up
      class restrictions on subnets, see <a class="xref" href="#classification-subnets" title="13.6. Configuring Subnets With Class Information">Section 13.6, “Configuring Subnets With Class Information”</a>.
      </p><p>
      When subnets belong to a shared network the classification applies
      to subnet selection but not to pools, e.g., a pool in a subnet
      limited to a particular class can still be used by clients which do not
      belong to the class if the pool they are expected to use is exhausted.
      So the limit access based on class information is also available
      at the address/prefix pool level, see <a class="xref" href="#classification-pools" title="13.7. Configuring Pools With Class Information">Section 13.7, “Configuring Pools With Class Information”</a> within a subnet.
      This is useful when to segregate clients belonging to the same subnet
      into different address ranges.
      </p><p>
      The process of doing classification is conducted in several steps. The first step
      is to assess an incoming packet and assign it to zero or more classes.  The
      second step is to choose a subnet, possibly based on the class information.
      The third step is to assign classes from host reservations and
      evaluate class expressions depending on the "KNOWN" class.
      After the list of required classes is built and each class of the list
      has its expression evaluated: when it returns true the packet is added
      as a member of the class.
      The last step is to assign options again possibly based on the class
      information.
      More complete and detailed description is available in
      <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
      </p><p>
      There are two main methods of doing classification. The first is automatic and relies
      on examining the values in the vendor class options or existence of a
      host reservation. Information from these
      options is extracted and a class name is constructed from it and added to
      the class list for the packet. The second allows for specifying an expression
      that is evaluated for each packet. If the result is true the packet is
      a member of the class.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Care should be taken with client classification as it is easy for
        clients that do not meet class criteria to be denied any service altogether.
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp57597456"></a>9.2.20.1. Defining and Using Custom Classes</h4></div></div></div><p>
        The following example shows how to configure a class using an expression
        and a subnet making use of that class. This configuration defines the
        class named "Client_enterprise". It is comprised
        of all clients whose client identifiers start with the given hex string (which
        would indicate a DUID based on an enterprise id of 0xAABBCCDD).
        They will be given an address from 2001:db8:1::0 to 2001:db8:1::FFFF and
        the addresses of their DNS servers set to 2001:db8:0::1 and 2001:db8:2::1.

        </p><pre class="screen">
"Dhcp6": {
    "client-classes": [
        {<strong class="userinput"><code>
            "name": "Client_enterprise",
            "test": "substring(option[1].hex,0,6) == 0x0002AABBCCDD'",
            "option-data": [
                {
                    "name": "dns-servers",
                    "code": 23,
                    "space": "dhcp6",
                    "csv-format": true,
                    "data": "2001:db8:0::1, 2001:db8:2::1"
                }
            ]</code></strong>
        },
        ...
    ],
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [ { "pool": "2001:db8:1::-2001:db8:1::ffff" } ],
            <strong class="userinput"><code>"client-class": "Client_enterprise"</code></strong>
        }
    ],
    ...
}</pre><p>
      </p><p>
      This example shows a configuration using an automatically generated
      "VENDOR_CLASS_" class. The Administrator of the network has
      decided that addresses from range 2001:db8:1::1 to 2001:db8:1::ffff are
      going to be managed by the Dhcp6 server and only clients belonging to the
      eRouter1.0 client class are allowed to use that pool.

        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::-2001:db8:1::ffff"
                 }
             ],
            <strong class="userinput"><code>"client-class": "VENDOR_CLASS_eRouter1.0"</code></strong>
        }
    ],
    ...
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcp6-required-class"></a>9.2.20.2. Required classification</h4></div></div></div><p>
        In some cases it is useful to limit the scope of a class to
        a shared-network, subnet or pool. There are two parameters
        which are used to limit the scope of the class by instructing
        the server to perform evaluation of test expressions when
        required.
        </p><p>
        The first one is the per-class <span class="command"><strong>only-if-required</strong></span>
        flag which is false by default. When it is set to
        <span class="command"><strong>true</strong></span> the test expression of the class is not
        evaluated at the reception of the incoming packet but later and
        only if the class evaluation is required.
        </p><p>
        The second is the <span class="command"><strong>require-client-classes</strong></span> which
        takes a list of class names and is valid in shared-network,
        subnet and pool scope. Classes in these lists are marked as
        required and evaluated after selection of this specific
        shared-network/subnet/pool and before output option processing.
        </p><p>
        In this example, a class is assigned to the incoming packet
        when the specified subnet is used.

        </p><pre class="screen">
"Dhcp6": {
    "client-classes": [
       {<strong class="userinput"><code>
           "name": "Client_foo",
           "test": "member('ALL')",
           "only-if-required": true</code></strong>
       },
       ...
    ],
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64"
            "pools": [
                 {
                     "pool": "2001:db8:1::-2001:db8:1::ffff"
                 }
             ],
            <strong class="userinput"><code>"require-client-classes": [ "Client_foo" ],</code></strong>
            ...
        },
        ...
    ],
    ...
}</pre><p>
         </p><p>
         Required evaluation can be used to express complex dependencies,
         for example, subnet membership. It can also be used to reverse the
         precedence: if you set an option-data in a subnet it takes
         precedence over an option-data in a class. When you move the
         option-data to a required class and require it in
         the subnet, a class evaluated earlier may take precedence.
         </p><p>
         Required evaluation is also available at shared-network and
         pool/pd-pool levels. The order in which required classes are
         considered is: shared-network, subnet and (pd-)pool, i.e.
         the opposite order option-data are processed.
         </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-ddns-config"></a>9.2.21. DDNS for DHCPv6</h3></div></div></div><p>
      As mentioned earlier, kea-dhcp6 can be configured to generate requests to
      the DHCP-DDNS server (referred to here as "D2") to update
      DNS entries.  These requests are known as NameChangeRequests or NCRs.
      Each NCR contains the following information:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      Whether it is a request to add (update) or remove DNS entries
      </p></li><li class="listitem"><p>
      Whether the change requests forward DNS updates (AAAA records), reverse
      DNS updates (PTR records), or both.
      </p></li><li class="listitem"><p>
      The FQDN, lease address, and DHCID
      </p></li></ol></div><p>
      The parameters controlling the generation of NCRs for submission to D2
      are contained in the <span class="command"><strong>dhcp-ddns</strong></span> section of the kea-dhcp6
      configuration. The mandatory parameters for the DHCP DDNS configuration
      are <span class="command"><strong>enable-updates</strong></span> which is unconditionally
      required, and <span class="command"><strong>qualifying-suffix</strong></span> which has no
      default value and is required when <span class="command"><strong>enable-updates</strong></span>
      is set to <span class="command"><strong>true</strong></span>.

      The two (disabled and enabled) minimal DHCP DDNS configurations are:
</p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"enable-updates": false</code></strong>
    },
    ...
}
</pre><p>
      and for example:
</p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"enable-updates": true,
        "qualifying-suffix": "example."</code></strong>
    },
    ...
}
</pre><p>

      The default values for the "dhcp-ddns" section are as follows:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <span class="command"><strong>"server-ip": "127.0.0.1"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"server-port": 53001</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"sender-ip": ""</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"sender-port": 0</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"max-queue-size": 1024</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"ncr-protocol": "UDP"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"ncr-format": "JSON"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"override-no-update": false</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"override-client-update": false</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"replace-client-name": "never"</strong></span>
      </li><li class="listitem">
      <span class="command"><strong>"generated-prefix": "myhost"</strong></span>
      </li></ul></div><p>
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv6-d2-io-config"></a>9.2.21.1. DHCP-DDNS Server Connectivity</h4></div></div></div><p>
      In order for NCRs to reach the D2 server, kea-dhcp6 must be able
      to communicate with it.  kea-dhcp6 uses the following configuration
      parameters to control this communication:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <span class="command"><strong>enable-updates</strong></span> - determines whether or not kea-dhcp6 will
      generate NCRs.  If missing, this value is assumed to be false hence DDNS updates
      are disabled.  To enable DDNS updates set this value to true:
      </li><li class="listitem">
      <span class="command"><strong>server-ip</strong></span> - IP address on which D2 listens for requests. The default is
      the local loopback interface at address 127.0.0.1. You may specify
      either an IPv4 or IPv6 address.
      </li><li class="listitem">
      <span class="command"><strong>server-port</strong></span> - port on which D2 listens for requests.  The default value
      is 53001.
      </li><li class="listitem">
      <span class="command"><strong>sender-ip</strong></span> - IP address which kea-dhcp6 should use to send requests to D2.
      The default value is blank which instructs kea-dhcp6 to select a suitable
      address.
      </li><li class="listitem">
      <span class="command"><strong>sender-port</strong></span> - port which kea-dhcp6 should use to send requests to D2. The
      default value of 0 instructs kea-dhcp6 to select a suitable port.
      </li><li class="listitem">
      <span class="command"><strong>max-queue-size</strong></span> - maximum number of requests allowed to queue waiting to
      be sent to D2. This value guards against requests accumulating
      uncontrollably if they are being generated faster than they can be
      delivered.  If the number of requests queued for transmission reaches
      this value, DDNS updating will be turned off until the queue backlog has
      been sufficiently reduced.  The intent is to allow kea-dhcp6 to
      continue lease operations.  The default value is 1024.
      </li><li class="listitem">
      <span class="command"><strong>ncr-protocol</strong></span> - socket protocol use when sending requests to D2.  Currently
      only UDP is supported.  TCP may be available in an upcoming release.
      </li><li class="listitem">
      <span class="command"><strong>ncr-format</strong></span> - packet format to use when sending requests to D2.
      Currently only JSON format is supported.  Other formats may be available
      in future releases.
      </li></ul></div><p>
      By default, kea-dhcp-ddns is assumed to running on the same machine as kea-dhcp6, and
      all of the default values mentioned above should be sufficient.
      If, however, D2 has been configured to listen on a different address or
      port, these values must altered accordingly. For example, if D2 has been
      configured to listen on 2001:db8::5 port 900, the following configuration
      would be required:
</p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"server-ip": "2001:db8::5",
        "server-port": 900</code></strong>,
        ...
    },
    ...
}
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv6-d2-rules-config"></a>9.2.21.2. When Does kea-dhcp6 Generate a DDNS Request?</h4></div></div></div><p>kea-dhcp6 follows the behavior prescribed for DHCP servers in
      <a class="ulink" href="http://tools.ietf.org/html/rfc4704" target="_top">RFC 4704</a>.
      It is important to keep in mind that kea-dhcp6 provides the initial
      decision making of when and what to update and forwards that
      information to D2 in the form of NCRs. Carrying out the actual
      DNS updates and dealing with such things as conflict resolution
      are within the purview of D2 itself (<a class="xref" href="#dhcp-ddns-server" title="Chapter 11. The DHCP-DDNS Server">Chapter 11, <i>The DHCP-DDNS Server</i></a>).
      This section describes when kea-dhcp6 will generate NCRs and the
      configuration parameters that can be used to influence this decision.
      It assumes that the <span class="command"><strong>enable-updates</strong></span> parameter is true.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Currently the interface between kea-dhcp6 and D2 only supports requests
        which update DNS entries for a single IP address.  If a lease grants
        more than one address, kea-dhcp6 will create the DDNS update request for
        only the first of these addresses.  Support for multiple address
        mappings may be provided in a future release.
        </p></div><p>
      In general, kea-dhcp6 will generate DDNS update requests when:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      A new lease is granted in response to a REQUEST
      </p></li><li class="listitem"><p>
      An existing lease is renewed but the FQDN associated with it has
      changed.
      </p></li><li class="listitem"><p>
      An existing lease is released in response to a RELEASE
      </p></li></ol></div><p>
      In the second case, lease renewal, two  DDNS requests will be issued: one
      request to remove entries for the previous FQDN and a second request to
      add entries for the new FQDN.  In the last case, a lease release, a
      single DDNS request to remove its entries will be made.
      </p><p>
      The decision making involved when granting a new lease the first case) is more
      involved. When a new lease is granted, kea-dhcp6 will generate a DDNS
      update request only if the REQUEST contains the FQDN option (code 39).
      By default kea-dhcp6 will respect the FQDN N and S flags specified by the client
      as shown in the following table:
      </p><div class="table"><a name="dhcp6-fqdn-flag-table"></a><p class="title"><b>Table 9.3. Default FQDN Flag Behavior</b></p><div class="table-contents"><table summary="Default FQDN Flag Behavior" border="1"><colgroup><col align="left" class="cflags"><col align="left" class="meaning"><col align="left" class="response"><col align="left" class="sflags"></colgroup><thead><tr><th align="left">Client Flags:N-S</th><th align="left">Client Intent</th><th align="left">Server Response</th><th align="left">Server Flags:N-S-O</th></tr></thead><tbody><tr><td align="left">0-0</td><td align="left">
                Client wants to do forward updates, server should do reverse updates
                </td><td align="left">Server generates reverse-only request</td><td align="left">1-0-0</td></tr><tr><td align="left">0-1</td><td align="left">Server should do both forward and reverse updates</td><td align="left">Server generates request to update both directions</td><td align="left">0-1-0</td></tr><tr><td align="left">1-0</td><td align="left">Client wants no updates done</td><td align="left">Server does not generate a request</td><td align="left">1-0-0</td></tr></tbody></table></div></div><br class="table-break"><p>
      The first row in the table above represents "client delegation". Here
      the DHCP client states that it intends to do the forward DNS updates and
      the server should do the reverse updates.  By default, kea-dhcp6 will honor
      the client's wishes and generate a DDNS request to D2 to update only
      reverse DNS data.  The parameter, <span class="command"><strong>override-client-update</strong></span>, can be used
      to instruct the server to override client delegation requests.  When
      this parameter is true, kea-dhcp6 will disregard requests for client
      delegation and generate a DDNS request to update both forward and
      reverse DNS data.  In this case, the N-S-O flags in the server's
      response to the client will be 0-1-1 respectively.
      </p><p>
      (Note that the flag combination N=1, S=1 is prohibited according to
      <a class="ulink" href="http://tools.ietf.org/html/rfc4702" target="_top">RFC 4702</a>. If such a
      combination is received from the client, the packet will be dropped by kea-dhcp6.)
      </p><p>
      To override client delegation, set the following values in the configuration:
      </p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"override-client-update": true</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The third row in the table above describes the case in which the client
      requests that no DNS updates be done. The parameter, <span class="command"><strong>override-no-update</strong></span>,
      can be used to instruct the server to disregard the client's wishes. When
      this parameter is true, kea-dhcp6 will generate DDNS update requests to
      kea-dhcp-ddns even if the client requests no updates be done.  The N-S-O
      flags in the server's response to the client will be 0-1-1.
      </p><p>
      To override client delegation, issue the following commands:
      </p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"override-no-update": true</code></strong>,
        ...
    },
    ...
}
</pre></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="dhcpv6-fqdn-name-generation"></a>9.2.21.3. kea-dhcp6 Name Generation for DDNS Update Requests</h4></div></div></div><p>Each NameChangeRequest must of course include the fully qualified
      domain name whose DNS entries are to be affected.  kea-dhcp6 can be
      configured to supply a portion or all of that name based upon what it
      receives from the client.</p><p>
       The default rules for constructing the FQDN that will be used for DNS
       entries are:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
        If the DHCPREQUEST contains the client FQDN option, the candidate name
        is taken from there.
      </p></li><li class="listitem"><p>
        If the candidate name is a partial (i.e. unqualified) name then add a
        configurable suffix to the name and use the result as the FQDN.
      </p></li><li class="listitem"><p>
        If the candidate name provided is empty, generate an FQDN using a
        configurable prefix and suffix.
      </p></li><li class="listitem"><p>
        If the client provided neither option, then no DNS action will be taken.
      </p></li></ol></div><p>
        These rules can amended by setting the
        <span class="command"><strong>replace-client-name</strong></span> parameter which provides the
        following modes of behavior:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <span class="command"><strong>never</strong></span> - Use the name the client sent.  If the client
        sent no name, do not generate one.  This is the default mode.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>always</strong></span> - Replace the name the client sent. If the
        client sent no name, generate one for the client.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>when-present</strong></span> - Replace the name the client sent.
        If the client sent no name, do not generate one.
      </p></li><li class="listitem"><p>
        <span class="command"><strong>when-not-present</strong></span> - Use the name the client sent.
        If the client sent no name, generate one for the client.
      </p></li></ul></div><p>
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    Note that formerly, this parameter was a boolean and permitted only values
    of <span class="command"><strong>true</strong></span> and <span class="command"><strong>false</strong></span>.  Boolean values
    have been deprecated and are no longer accepted.  If you are currently using
    booleans, you must replace them with the desired mode name. A value of
    <span class="command"><strong>true</strong></span> maps to <span class="command"><strong>"when-present"</strong></span>, while
    <span class="command"><strong>false</strong></span> maps to <span class="command"><strong>"never"</strong></span>.
    </div><p>

      For example, To instruct kea-dhcp6 to always generate the FQDN for a
      client, set the parameter <span class="command"><strong>replace-client-name</strong></span> to
      <span class="command"><strong>always</strong></span> as follows:
      </p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"replace-client-name": "always"</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The prefix used in the generation of an FQDN is specified by the
      <span class="command"><strong>generated-prefix</strong></span> parameter.  The default value is "myhost".  To alter
      its value, simply set it to the desired string:
      </p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"generated-prefix": "another.host"</code></strong>,
        ...
    },
    ...
}
</pre><p>
      The suffix used when generating an FQDN or when qualifying a
      partial name is specified by
      the <span class="command"><strong>qualifying-suffix</strong></span> parameter. This
      parameter has no default value, thus it is mandatory when
      DDNS updates are enabled.
      To set its value simply set it to the desired string:
      </p><pre class="screen">
"Dhcp6": {
    "dhcp-ddns": {
        <strong class="userinput"><code>"qualifying-suffix": "foo.example.org"</code></strong>,
        ...
    },
    ...
}
</pre></div><p>
      When qualifying a partial name, kea-dhcp6 will construct a name with the
      format:
      </p><p>
        [candidate-name].[qualifying-suffix].
      </p><p>
      where candidate-name is the partial name supplied in the REQUEST.
      For example, if FQDN domain name value was "some-computer" and
      qualifying-suffix "example.com", the generated FQDN would be:
      </p><p>
        some-computer.example.com.
      </p><p>
      When generating the entire name, kea-dhcp6 will construct name of the
      format:
      </p><p>
        [generated-prefix]-[address-text].[qualifying-suffix].
      </p><p>
      where address-text is simply the lease IP address converted to a
      hyphenated string.  For example, if lease address is 3001:1::70E,
      the qualifying suffix "example.com", and the default value is used for
      <span class="command"><strong>generated-prefix</strong></span>, the generated FQDN would be:
      </p><p>
        myhost-3001-1--70E.example.com.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp6-dhcp4o6-config"></a>9.2.22. DHCPv4-over-DHCPv6: DHCPv6 Side</h3></div></div></div><p>
      The support of DHCPv4-over-DHCPv6 transport is described in
      <a class="ulink" href="http://tools.ietf.org/html/rfc7341" target="_top">RFC 7341</a>
      and is implemented using cooperating DHCPv4 and DHCPv6 servers.
      This section is about the configuration of the DHCPv6 side
      (the DHCPv4 side is described in <a class="xref" href="#dhcp4-dhcp4o6-config" title="8.2.20. DHCPv4-over-DHCPv6: DHCPv4 Side">Section 8.2.20, “DHCPv4-over-DHCPv6: DHCPv4 Side”</a>).
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      DHCPv4-over-DHCPv6 support is experimental and the details of
      the inter-process communication can change: both the
      DHCPv4 and DHCPv6 sides should be running the same version of Kea.
      For instance the support of port relay (RFC 8357) introduced such
      such incompatible change.
      </div><p>
      There is only one specific parameter for the DHCPv6 side:
      <span class="command"><strong>dhcp4o6-port</strong></span> which specifies the first of the
      two consecutive ports of the UDP sockets used for the communication
      between the DHCPv6 and DHCPv4 servers (the DHCPv6 server is bound
      to ::1 on <span class="command"><strong>port</strong></span> and connected to ::1 on
      <span class="command"><strong>port</strong></span> + 1).
      </p><p>
      Two other configuration entries are in general required: unicast traffic
      support (see <a class="xref" href="#dhcp6-unicast" title="9.2.6. Unicast Traffic Support">Section 9.2.6, “Unicast Traffic Support”</a>) and DHCP 4o6 server
      address option (name "dhcp4o6-server-addr", code  88).
      </p><p>
      The following configuration was used during some tests:
</p><pre class="screen">
{

# DHCPv6 conf
"Dhcp6": {

    "interfaces-config": {
        "interfaces": [ "eno33554984/2001:db8:1:1::1" ]
    },

    "lease-database": {
        "type": "memfile",
        "name": "leases6"
    },

    "preferred-lifetime": 3000,
    "valid-lifetime": 4000,
    "renew-timer": 1000,
    "rebind-timer": 2000,

    "subnet6": [ {
        "subnet": "2001:db8:1:1::/64",
        "interface": "eno33554984",
        "pools": [ { "pool": "2001:db8:1:1::1:0/112" } ]
    } ],

    <strong class="userinput"><code>"dhcp4o6-port": 6767,

    "option-data": [ {
        "name": "dhcp4o6-server-addr",
        "code": 88,
        "space": "dhcp6",
        "csv-format": true,
        "data": "2001:db8:1:1::1"
    } ]
</code></strong>
},

"Logging": {
    "loggers": [ {
        "name": "kea-dhcp6",
        "output_options": [ {
            "output": "/tmp/kea-dhcp6.log"
        } ],
        "severity": "DEBUG",
        "debuglevel": 0
    } ]
}

}
</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      Relayed DHCPv4-QUERY DHCPv6 messages are not yet supported.
      </div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="host-reservation-v6"></a>9.3. Host Reservation in DHCPv6</h2></div></div></div><p>There are many cases where it is useful to provide a configuration on
    a per host basis. The most obvious one is to reserve specific, static IPv6
    address or/and prefix for exclusive use by a given client (host) ‐ returning
    client will get the same address or/and prefix every time and other clients will
    never get that address. Note that there may be cases when the
    new reservation has been made for the client for the address or prefix being
    currently in use by another client. We call this situation a "conflict". The
    conflicts get resolved automatically over time as described in the subsequent
    sections. Once conflict is resolved, the client will keep receiving the reserved
    configuration when it renews.</p><p>Another example when the host reservations are applicable is when a host
    has specific requirements, e.g. a printer that needs additional DHCP options
    or a cable modem needs specific parameters. Yet another possible use case for
    host reservation is to define unique names for hosts.</p><p>Hosts reservations are defined as parameters for each subnet. Each host
    can be identified by either DUID or its hardware/MAC address. See
    <a class="xref" href="#mac-in-dhcpv6" title="9.10. MAC/Hardware Addresses in DHCPv6">Section 9.10, “MAC/Hardware Addresses in DHCPv6”</a> for details. There is an optional
    <span class="command"><strong>reservations</strong></span> array in the
    <span class="command"><strong>subnet6</strong></span> structure. Each element in that array
    is a structure, that holds information about a single host. In
    particular, the structure has an identifier that
    uniquely identifies a host.  In the DHCPv6 context, such an identifier
    is usually a DUID, but can also be a hardware or MAC address.  Also,
    either one or more addresses or prefixes may be specified. It is
    possible to specify a hostname and DHCPv6 options for a given host.</p><p>The following example shows how to reserve addresses and prefixes
    for specific hosts:

</p><pre class="screen">
"subnet6": [
    {
        "subnet": "2001:db8:1::/48",
        "pools": [ { "pool": "2001:db8:1::/80" } ],
        "pd-pools": [
            {
                "prefix": "2001:db8:1:8000::",
                "prefix-len": 48,
                "delegated-len": 64
            }
        ],
        <strong class="userinput"><code>"reservations": [
            {
                "duid": "01:02:03:04:05:0A:0B:0C:0D:0E",
                "ip-addresses": [ "2001:db8:1::100" ]
            },
            {
                "hw-address": "00:01:02:03:04:05",
                "ip-addresses": [ "2001:db8:1::101", "2001:db8:1::102" ]
            },
            {
                "duid": "01:02:03:04:05:06:07:08:09:0A",
                "ip-addresses": [ "2001:db8:1::103" ],
                "prefixes": [ "2001:db8:2:abcd::/64" ],
                "hostname": "foo.example.com"
            }
        ]</code></strong>
    }
]
</pre><p>

    This example includes reservations for three different clients. The first reservation
    is made for the address 2001:db8:1::100 for a client using DUID
    01:02:03:04:05:0A:0B:0C:0D:0E. The second reservation is made for two addresses
    2001:db8:1::101 and 2001:db8:1::102 for a client using MAC address
    00:01:02:03:04:05. Lastly, address 2001:db8:1::103 and prefix 2001:db8:2:abcd::/64
    are reserved for a client using DUID 01:02:03:04:05:06:07:08:09:0A. The
    last reservation also assigns a hostname to this client.
    </p><p>Note that DHCPv6 allows for a single client to lease multiple addresses
    and multiple prefixes at the same time. Therefore <span class="command"><strong>ip-addresses</strong></span>
    and <span class="command"><strong>prefixes</strong></span> are plural and are actually arrays.
    When the client sends multiple IA options (IA_NA or IA_PD), each reserved
    address or prefix is assigned to an individual IA of the appropriate type. If
    the number of IAs of specific type is lower than the number of reservations
    of that type, the number of reserved addresses or prefixes assigned to the
    client is equal to the number of IA_NAs or IA_PDs sent by the client, i.e.
    some reserved addresses or prefixes are not assigned. However,
    they still remain reserved for this client and the server will not assign
    them to any other client. If the number of IAs of specific type sent by the
    client is greater than the number of reserved addresses or prefixes, the
    server will try to assign all reserved addresses or prefixes to the individual
    IAs and dynamically allocate addresses or prefixes to remaining IAs. If the
    server cannot assign a reserved address or prefix because it is in use,
    the server will select the next reserved address or prefix and try to assign it to
    the client. If the server subsequently finds that there are no more reservations
    that can be assigned to the client at the moment, the server will try to
    assign leases dynamically.
    </p><p>Making a reservation for a mobile host that may visit multiple subnets
    requires a separate host definition in each subnet it is expected to visit.
    It is not allowed to define multiple host definitions with the same hardware
    address in a single subnet. Multiple host definitions with the same hardware
    address are valid if each is in a different subnet.  The reservation for a given host
    should include only one identifier, either DUID or hardware address. Defining
    both for the same host is considered a configuration error, but as of 1.1.0,
    it is not rejected.
    </p><p>Adding host reservation incurs a performance penalty. In principle,
    when a server that does not support host reservation responds to a query,
    it needs to check whether there is a lease for a given address being
    considered for allocation or renewal. The server that also supports host
    reservation, has to perform additional checks: not only if the address is
    currently used (i.e. if there is a lease for it), but also whether the address
    could be used by someone else (i.e. if there is a reservation for it). That
    additional check incurs additional overhead.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation6-types"></a>9.3.1. Address/Prefix Reservation Types</h3></div></div></div><p>In a typical scenario there is an IPv6 subnet defined with a certain
      part of it dedicated for dynamic address allocation by the DHCPv6
      server. There may be an additional address space defined for prefix
      delegation. Those dynamic parts are referred to as dynamic pools, address
      and prefix pools or simply pools. In principle, the host reservation can
      reserve any address or prefix that belongs to the subnet. The reservations
      that specify an address that belongs to configured pools are called
      "in-pool reservations". In contrast, those that do not
      belong to dynamic pools are called "out-of-pool
      reservations". There is no formal difference in the reservation
      syntax and both reservation types are handled
      uniformly. However, upcoming releases may offer improved performance if
      there are only out-of-pool reservations as the server will be able to skip
      reservation checks when dealing with existing leases. Therefore, system
      administrators are encouraged to use out-of-pool reservations if
      possible.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation6-conflict"></a>9.3.2. Conflicts in DHCPv6 Reservations</h3></div></div></div><p>As reservations and lease information are stored separately,
      conflicts may arise. Consider the following series of events. The server
      has configured the dynamic pool of addresses from the range of 2001:db8::10
      to 2001:db8::20. Host A requests an address and gets 2001:db8::10. Now the
      system administrator decides to reserve address 2001:db8::10 for Host B.
      In general, reserving an address
      that is currently assigned to someone else is not recommended, but there
      are valid use cases where such an operation is warranted.</p><p>The server now has a conflict to resolve. Let's analyze the
      situation here. If Host B boots up and request an address, the server is
      not able to assign the reserved address 2001:db8::10. A naive approach
      would to be immediately remove the lease for Host A and create a new one
      for Host B. That would not solve the problem, though, because as soon as
      Host B get the address, it will detect that the address is already in use
      by someone else (Host A) and would send a Decline message. Therefore in this
      situation, the server has to temporarily assign a different address from the
      dynamic pool (not matching what has been reserved) to Host B.</p><p>When Host A renews its address, the server will discover that
      the address being renewed is now reserved for someone else (Host
      B). Therefore the server will remove the lease for 2001:db8::10, select
      a new address and create a new lease for it. It will send two
      addresses in its response: the old address with lifetime set to 0 to
      explicitly indicate that it is no longer valid and the new address with a
      non-zero lifetime. When Host B renews its temporarily assigned
      address, the server will detect that the existing lease does not match
      reservation, so it will release the current address Host B has and will
      create a new lease matching the reservation. Similar as before, the server
      will send two addresses: the temporarily assigned one with zeroed
      lifetimes, and the new one that matches reservation with proper lifetimes
      set.</p><p>This recovery will succeed, even if other hosts will attempt to get
      the reserved address. Had Host C requested address 2001:db8::10 after
      the reservation was made, the server will propose a different address.</p><p>This recovery mechanism allows the server to fully recover from a
      case where reservations conflict with existing leases. This procedure
      takes time and will roughly take as long as renew-timer value specified.
      The best way to avoid such recovery is to not define new reservations that
      conflict with existing leases. Another recommendation is to use
      out-of-pool reservations. If the reserved address does not belong to a
      pool, there is no way that other clients could get this address.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation6-hostname"></a>9.3.3. Reserving a Hostname</h3></div></div></div><p>When the reservation for the client includes the <span class="command"><strong>hostname</strong></span>,
      the server will assign this hostname to the client and send
      it back in the Client FQDN, if the client sent the FQDN option to the
      server. The reserved hostname always takes precedence over the hostname
       supplied by the client (via the FQDN option) or the autogenerated
      (from the IPv6 address) hostname.</p><p>The server qualifies the reserved hostname with the value
      of the <span class="command"><strong>qualifying-suffix</strong></span> parameter. For example, the
      following subnet configuration:
</p><pre class="screen">
"subnet6": [
    {
        "subnet": "2001:db8:1::/48",
        "pools": [ { "pool": "2001:db8:1::/80" } ],
        "reservations": [
            {
                "duid": "01:02:03:04:05:0A:0B:0C:0D:0E",
                "ip-addresses": [ "2001:db8:1::100" ]
                "hostname": "alice-laptop"
            }
        ]
    }
],
"dhcp-ddns": {
    "enable-updates": true,
    "qualifying-suffix": "example.isc.org."
}
</pre><p>
      will result in assigning the "alice-laptop.example.isc.org." hostname to the
      client using the DUID "01:02:03:04:05:0A:0B:0C:0D:0E". If the <span class="command"><strong>qualifying-suffix
      </strong></span> is not specified, the default (empty) value will be used, and
      in this case the value specified as a <span class="command"><strong>hostname</strong></span> will
      be treated as fully qualified name.  Thus, by leaving the
      <span class="command"><strong>qualifying-suffix</strong></span> empty it is possible to qualify
      hostnames for the different clients with different domain names:
</p><pre class="screen">
"subnet6": [
    {
        "subnet": "2001:db8:1::/48",
        "pools": [ { "pool": "2001:db8:1::/80" } ],
        "reservations": [
            {
                "duid": "01:02:03:04:05:0A:0B:0C:0D:0E",
                "ip-addresses": [ "2001:db8:1::100" ]
                "hostname": "mark-desktop.example.org."
            }
        ]
    }
],
"dhcp-ddns": {
    "enable-updates": true,
}
</pre><p>
      The above example results in the assignment of the "mark-desktop.example.org." hostname to the
      client using the DUID "01:02:03:04:05:0A:0B:0C:0D:0E".
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation6-options"></a>9.3.4. Including Specific DHCPv6 Options in Reservations</h3></div></div></div><p>Kea 1.1.0 introduced the ability to specify options on a
      per host basis. The options follow the same rules as any other
      options. These can be standard options (see <a class="xref" href="#dhcp6-std-options" title="9.2.10. Standard DHCPv6 Options">Section 9.2.10, “Standard DHCPv6 Options”</a>), custom options (see <a class="xref" href="#dhcp6-custom-options" title="9.2.12. Custom DHCPv6 Options">Section 9.2.12, “Custom DHCPv6 Options”</a>) or vendor specific options
      (see <a class="xref" href="#dhcp6-vendor-opts" title="9.2.13. DHCPv6 Vendor-Specific Options">Section 9.2.13, “DHCPv6 Vendor-Specific Options”</a>). The following
      example demonstrates how standard options can be defined.</p><pre class="screen">
"reservations": [
{
   "duid": "01:02:03:05:06:07:08",
   "ip-addresses": [ "2001:db8:1::2" ],
    <strong class="userinput"><code>"option-data": [
    {
        "option-data": [ {
            "name": "dns-servers",
            "data": "3000:1::234"
        },
        {
            "name": "nis-servers",
            "data": "3000:1::234"
        }
    } ]</code></strong>
} ]</pre><p>Vendor specific options can be reserved in a similar manner:</p><pre class="screen">
"reservations": [
{
    "duid": "aa:bb:cc:dd:ee:ff",
    "ip-addresses": [ "2001:db8::1" ],
    <strong class="userinput"><code>"option-data": [
    {
        "name": "vendor-opts",
        "data": 4491
    },
    {
        "name": "tftp-servers",
        "space": "vendor-4491",
        "data": "3000:1::234"
    } ]</code></strong>
} ]</pre><p>
 Options defined on host level have the highest priority. In other words,
 if there are options defined with the same type on global, subnet, class and
 host level, the host specific values will be used.
</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservation6-client-classes"></a>9.3.5. Reserving Client Classes in DHCPv6</h3></div></div></div><p>The <a class="xref" href="#classification-using-expressions" title="13.3. Using Expressions In Classification">Section 13.3, “Using Expressions In Classification”</a> explains how
      to configure the server to assign classes to a client based on the content
      of the options that this client sends to the server. Host reservations
      mechanisms also allow for the static assignment of classes to clients.
      The definitions of these classes are placed in the Kea
      configuration. The following configuration snippet shows how to specify
      that the client belongs to classes <span class="command"><strong>reserved-class1</strong></span>
      and <span class="command"><strong>reserved-class2</strong></span>. Those classes are associated with
      specific options being sent to the clients which belong to them.
      </p><pre class="screen">
{
    "client-classes": [
    {
       "name": "reserved-class1",
       "option-data": [
       {
           "name": "dns-servers",
           "data": "2001:db8:1::50"
       }
       ]
   },
   {
       "name": "reserved-class2",
       "option-data": [
       {
           "name": "nis-servers",
           "data": "2001:db8:1::100"
       }
       ]
    }
    ],
    "subnet6": [
    {   "pools": [ { "pool": "2001:db8:1::/64" } ],
        "subnet": "2001:db8:1::/48",
        "reservations": [
        {
            "duid": "01:02:03:04:05:06:07:08",
            <strong class="userinput"><code>
            "client-classes": [ "reserved-class1", "reserved-class2" ]
            </code></strong>
         } ]
     } ]
 }

</pre><p>Static class assignments, as shown above, can be used in conjunction
    with classification using expressions. The "KNOWN" builtin class is
    added to the packet and any class depending on it directly or indirectly
    and not only-if-required is evaluated.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you want to force the evaluation of a class expression after
     the host reservation lookup, for instance because of a dependency on
     "reserved-class1" from the previous example, you should add a
     "member('KNOWN')" in the expression.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservations6-mysql-pgsql-cql"></a>9.3.6. Storing Host Reservations in MySQL, PostgreSQL or Cassandra</h3></div></div></div><p>
        It is possible to store host reservations in MySQL, PostgreSQL or Cassandra. See
        <a class="xref" href="#hosts6-storage" title="9.2.3. Hosts Storage">Section 9.2.3, “Hosts Storage”</a> for information on how to configure Kea to use
        reservations stored in MySQL, PostgreSQL or Cassandra. Kea provides dedicated hook for
        managing reservations in a database, section <a class="xref" href="#host-cmds" title="14.4.4. host_cmds: Host Commands">Section 14.4.4, “host_cmds: Host Commands”</a> provide
        detailed information. The Kea wiki <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/HostReservationsHowTo" target="_top">http://kea.isc.org/wiki/HostReservationsHowTo</a></code>
        provides some examples how to conduct some common operations
        on host reservations.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In Kea maximum length of an option specified per host is
      arbitrarily set to 4096 bytes.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="reservations6-tuning"></a>9.3.7. Fine Tuning DHCPv6 Host Reservation</h3></div></div></div><p>The host reservation capability introduces additional restrictions for the
      allocation engine (the component of Kea that selects an address for a client)
      during lease selection and renewal. In particular, three
      major checks are necessary. First, when selecting a new lease, it is not
      sufficient for a candidate lease to not be used by another DHCP client. It
      also must not be reserved for another client. Second, when renewing a lease,
      additional check must be performed whether the address being renewed is not
      reserved for another client. Finally, when a host renews an address or a
      prefix, the server has to check whether there is a reservation for this host,
      so the existing (dynamically allocated) address should be revoked and the
      reserved one be used instead.</p><p>Some of those checks may be unnecessary in certain deployments and not
      performing them may improve performance. The Kea server provides the
      <span class="command"><strong>reservation-mode</strong></span> configuration parameter to select the
      types of reservations allowed for the particular subnet. Each reservation
      type has different constraints for the checks to be performed by the
      server when allocating or renewing a lease for the client.
      Allowed values are:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"> <span class="command"><strong>all</strong></span> - enables all host reservation
      types. This is the default value. This setting is the safest and the most
      flexible. It allows in-pool and out-of-pool reservations. As all checks
      are conducted, it is also the slowest.
      </li><li class="listitem"> <span class="command"><strong>out-of-pool</strong></span> - allows only out of
      pool host reservations.  With this setting in place, the server may assume
      that all host reservations are for addresses that do not belong to the
      dynamic pool. Therefore it can skip the reservation checks when dealing
      with in-pool addresses, thus improving performance. Do not use this mode
      if any of your reservations use in-pool address. Caution is advised when
      using this setting. Kea does not sanity check the reservations against
      <span class="command"><strong>reservation-mode</strong></span> and misconfiguration may cause problems.
      </li><li class="listitem">
      <span class="command"><strong>disabled</strong></span> - host reservation support is disabled. As there
      are no reservations, the server will skip all checks. Any reservations defined
      will be completely ignored. As the checks are skipped, the server may
      operate faster in this mode.
      </li></ul></div><p>
      </p><p>
        An example configuration that disables reservation looks like follows:
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
        "subnet": "2001:db8:1::/64",
        <strong class="userinput"><code>"reservation-mode": "disabled"</code></strong>,
        ...
        }
    ]
}
</pre><p>
      </p><p>Another aspect of the host reservations are different types of
      identifiers. Kea 1.1.0 supports two types of identifiers
      in DHCPv6: hw-address and duid, but more identifier types
      are likely to be added in the future. This is beneficial from a
      usability perspective. However, there is a drawback. For each incoming
      packet Kea has to to extract each identifier type and then query the
      database to see if there is a reservation done by this particular
      identifier. If nothing is found, the next identifier is extracted and next
      query is issued. This process continues until either a reservation is
      found or all identifier types have been checked. Over time with an increasing
      number of supported identifier types, Kea would become slower and
      slower.</p><p>To address this problem, a parameter called
      <span class="command"><strong>host-reservation-identifiers</strong></span> has been introduced. It
      takes a list of identifier types as a parameter. Kea will check only those
      identifier types enumerated in host-reservation-identifiers. From a
      performance perspective the number of identifier types should be kept to
      minimum, ideally limited to one. If your deployment uses several
      reservation types, please enumerate them from most to least frequently
      used as this increases the chances of Kea finding the reservation using the
      fewest number of queries. An example of host reservation identifiers looks
      as follows:

</p><pre class="screen">
<strong class="userinput"><code>"host-reservation-identifiers": [ "duid", "hw-address" ],</code></strong>
"subnet6": [
    {
        "subnet": "2001:db8:1::/64",
        ...
    }
]</pre><p>
</p><p>
If not specified, the default value is:
</p><pre class="screen">
<strong class="userinput"><code>"host-reservation-identifiers": [ "hw-address", "duid" ]</code></strong>
</pre><p>

</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shared-network6"></a>9.4. Shared networks in DHCPv6</h2></div></div></div><p>DHCP servers use subnet information in two ways. First, it is used
    to determine the point of attachment, or simply put, where the client is
    connected to the network. Second, the subnet information is used to group
    information pertaining to specific location in the network. This approach
    works well in general case, but the are scenarios where the boundaries are
    blurred. Sometimes it is useful to have more than one logical IP subnet
    being deployed on the same physical link. The need to understand
    that two or more subnets are used on the same link requires additional logic
    in the DHCP server. This capability has been added in Kea 1.3.0.  It is
    called "shared networks" in Kea and ISC DHCP projects. It is sometimes also
    called "shared subnets". In Microsoft's nomenclature it is called "multinet".
    </p><p>There are many use cases where the feature is useful. The most common
    example in the IPv4 case is when the server is running out of available
    addresses in a subnet. This is less common in IPv6, but the shared networks
    are still useful in IPv6. One of the use cases is an exhaustion of IPv6
    delegated prefixes within a subnet. Another IPv6 specific example
    is an experiment with addressing scheme. With the advent of IPv6 deployment
    and vast address space, many organizations split the address space into
    subnets, then deploy it and after a while discover that they want to split it
    differently. In the transition period they want both old and new addressing
    to be available. Thus the need for more than one subnet on the same physical
    link.</p><p>Finally, the case of cable networks is directly applicable in
    IPv6. There are two types of devices in cable networks: cable modems and the
    end user devices behind them. It is a common practice to use different
    subnet for cable modems to prevent users from tinkering with their cable
    modems. In this case, the distinction is based on the type of device, rather
    than coming out of running out address space.</p><p>A client connected to a shared network may be assigned a lease (address
    or prefix) from any of the pools defined within the subnets belonging to the
    shared network. Internally, the server selects one of the subnets belonging to the
    shared network and tries to allocate a lease from this subnet. If the
    server is unable to allocate a lease from the selected subnet (e.g. due
    to pools exhaustion) it will use another subnet from the same shared
    network and try to allocate a lease from this subnet etc. Therefore, in the
    typical case, the server will allocate all leases available in a given
    subnet before it starts allocating leases from other subnets belonging to
    the same shared network. However, in certain situations the client can be
    allocated a lease from the other subnets before the pools in the first
    subnet get exhausted, e.g. when the client provides a hint that belongs
    to another subnet or the client has reservations in a different than
    default subnet.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>It is strongly discouraged for the Kea deployments to assume that the
      server doesn't allocate leases from other subnets until it uses all
      the leases from the first subnet in the shared network. Apart from the
      fact that hints, host reservations and client classification affect subnet
      selection, it is also foreseen that we will enhance allocation strategies
      for shared networks in the future versions of Kea, so as the selection
      of subnets within a shared network is equally probable (unpredictable).</p></div><p>In order to define a shared network an additional configuration scope
    is introduced:
</p><pre class="screen">
{
"Dhcp6": {
    <strong class="userinput"><code>"shared-networks": [
        {
            // Name of the shared network. It may be an arbitrary string
            // and it must be unique among all shared networks.
            "name": "ipv6-lab-1",

            // Subnet selector can be specifed on the shared network level.
            // Subnets from this shared network will be selected for clients
            // communicating via relay agent having the specified IP address.
            "relay": {
                "ip-addresses": [ "2001:db8:2:34::1" ]
            },

            // This starts a list of subnets in this shared network.
            // There are two subnets in this example.
            "subnet6": [
                {
                    "subnet": "2001:db8::/48",
                    "pools": [ { "pool":  "2001:db8::1 - 2001:db8::ffff" } ]
                },
                {
                    "subnet": "3ffe:ffe::/64",
                    "pools": [ { "pool":  "3ffe:ffe::/64" } ]
                }
            ]
        } ]</code></strong>, // end of shared-networks

    // It is likely that in your network you'll have a mix of regular,
    // "plain" subnets and shared networks. It is perfectly valid to mix
    // them in the same config file.
    //
    // This is regular subnet. It's not part of any shared-network.
    "subnet6": [
        {
            "subnet": "2001:db9::/48",
            "pools": [ { "pool":  "2001:db9::/64" } ],
            "relay": {
                "ip-addresses": [ "2001:db8:1:2::1" ]
            }
        }
    ]

} // end of Dhcp6
}
</pre><p>
    </p><p>As you see in the example, it is possible to mix shared and regular
    ("plain") subnets. Each shared network must have a unique name. This is a
    similar concept to ID for subnets, but it offers more flexibility. This is used
    for logging, but also internally for identifying shared networks.</p><p>In principle it makes sense to define only shared networks that
    consist of two or more subnets. However, for testing purposes it is allowed
    to define a shared network with just one subnet or even an empty one.  This
    is not a recommended practice in production networks, as the shared network
    logic requires additional processing and thus lowers server's performance.
    To avoid unnecessary performance degradation the shared subnets should only
    be defined when required by the deployment.
    </p><p>Shared networks provide an ability to specify many parameters in
    the shared network scope that will apply to all subnets within it. If
    necessary, you can specify a parameter in the shared network scope and then
    override its value on the subnet scope. For example:
</p><pre class="screen">
"shared-networks": [
    {
        "name": "lab-network3",
        "relay": {
             "ip-addresses": [ "2001:db8:2:34::1" ]
        },

        // This applies to all subnets in this shared network, unless
        // values are overridden on subnet scope.
        <strong class="userinput"><code>"valid-lifetime": 600</code></strong>,

        // This option is made available to all subnets in this shared
        // network.
        <strong class="userinput"><code>"option-data": [ {
            "name": "dns-servers",
            "data": "2001:db8::8888"
        } ]</code></strong>,

        "subnet6": [
            {
                "subnet": "2001:db8:1::/48",
                "pools": [ { "pool":  "2001:db8:1::1 - 2001:db8:1::ffff" } ],

                // This particular subnet uses different values.
                <strong class="userinput"><code>"valid-lifetime": 1200,
                "option-data": [
                {
                    "name": "dns-servers",
                    "data": "2001:db8::1:2"
                },
                {
                    "name": "unicast",
                    "data": "2001:abcd::1"
                } ]</code></strong>
            },
            {
                 "subnet": "2001:db8:2::/48",
                 "pools": [ { "pool":  "2001:db8:2::1 - 2001:db8:2::ffff" } ],

                 // This subnet does not specify its own valid-lifetime value,
                 // so it is inherited from shared network scope.
                 <strong class="userinput"><code>"option-data": [
                 {
                     "name": "dns-servers",
                     "data": "2001:db8:cafe::1"
                 } ]</code></strong>
            }
        ],
    } ]</pre><p>

    In this example, there is a dns-servers option defined that is available to
    clients in both subnets in this shared network. Also, a valid lifetime is
    set to 10 minutes (600s). However, the first subnet overrides some of the values
    (valid lifetime is 20 minutes, different IP address for dns-servers), but
    also adds its own option (unicast address). Assuming a client asking for a
    server unicast and dns servers options is assigned a lease from this subnet,
    he will get a lease for 20 minutes and dns-servers and be allowed to use
    server unicast at address 2001:abcd::1. If the same client is assigned to
    the second subnet, he will get a 10 minutes long lease, dns-servers value of
    2001:db8:cafe::1 and no server unicast.
    </p><p>Some parameters must be the same in all subnets in the same shared
    network. This restriction applies to <span class="command"><strong>interface</strong></span> and
    <span class="command"><strong>rapid-commit</strong></span> settings. The most convenient way is to
    define them on shared network scope, but you may specify them for each
    subnet. However, care should be taken for each subnet to have the same
    value.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57794880"></a>9.4.1. Local and relayed traffic in shared networks</h3></div></div></div><p>It is possible to specify interface name in the shared network scope to
    tell the server that this specific shared network is reachable directly (not
    via relays) using local network interface. It is sufficient to specify
    it once in the shared network level. As all subnets in a shared network are
    expected to be used on the same physical link, it is a configuration error
    to attempt to make a shared network out of subnets that are reachable over
    different interfaces. It is allowed to specify interface parameter on each
    subnet, although its value must be the same for each subnet. Thus it's
    usually more convenient to specify it once on the shared network level.
</p><pre class="screen">
"shared-networks": [
    {
        "name": "office-floor-2",

        // This tells Kea that the whole shared networks is reachable over
        // local interface. This applies to all subnets in this network.
        <strong class="userinput"><code>"interface": "eth0"</code></strong>,

        "subnet6": [
            {
                "subnet": "2001:db8::/64",
                "pools": [ { "pool":  "2001:db8::1 - 2001:db8::ffff" } ],
                <strong class="userinput"><code>"interface": "eth0"</code></strong>
            },
            {
                 "subnet": "3ffe:abcd::/64",
                 "pools": [ { "pool":  "3ffe:abcd::1 - 3ffe:abcd::ffff" } ]

                 // Specifying a different interface name is configuration
                 // error:
                 // "interface": "eth1"
            }
        ],
    } ]
</pre><p>
</p><p>Somewhat similar to interface names, also relay IP addresses can be
specified for the whole shared network. However, depending on your relay
configuration, it may use different IP addresses depending on which subnet
is being used. Thus there is no requirement to use the same IP relay address
for each subnet. Here's an example:

</p><pre class="screen">
"shared-networks": [
    {
        "name": "kakapo",
        <strong class="userinput"><code>"relay": {
            "ip-addresses":  [ "2001:db8::abcd" ]
        }</code></strong>,
        "subnet6": [
            {
                "subnet": "2001:db8::/64",
                <strong class="userinput"><code>"relay": {
                    "ip-addresses": [ "2001:db8::1234" ]
                }</code></strong>,
                "pools": [ { "pool":  "2001:db8::1 - 2001:db8::ffff" } ]
            },
            {
                 "subnet": "3ffe:abcd::/64",
                 "pools": [ { "pool":  "3ffe:abcd::1 - 3ffe:abcd::ffff" } ],
                 <strong class="userinput"><code>"relay": {
                    "ip-addresses": [ "3ffe:abcd::cafe" ]
                 }</code></strong>
            }
        ]
    }
]</pre><p>
In this particular case the relay IP address specified on network level doesn't
have much sense, as it is overridden in both subnets, but it was left there
as an example of how one could be defined on network level. Note that the
relay agent IP address typically belongs to the subnet it relays packets from,
but this is not a strict requirement. Therefore Kea accepts any value here
as long as it is valid IPv6 address.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57802400"></a>9.4.2. Client classification in shared networks</h3></div></div></div><p>Sometimes it is desired to segregate clients into specific subnets
      based on some properties. This mechanism is called client classification
      and is described in <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>. Client classification
      can be applied to subnets belonging to shared networks in the same way
      as it is used for subnets specified outside of shared networks.
      It is important to understand how the server selects subnets for
      the clients when client classification is in use, to assure that the
      desired subnet is selected for a given client type.</p><p>If a subnet is associated with some classes, only the clients
      belonging to any of these classes can use this subnet. If there are no
      classes specified for a subnet, any client connected to a given shared
      network can use this subnet. A common mistake is to assume that the
      subnet including client classes is preferred over subnets without
      client classes. Consider the following example:

</p><pre class="screen">
{
    "client-classes": [
        {
            "name": "b-devices",
            "test": "option[1234].hex == 0x0002"
        }
    ],
    "shared-networks": [
        {
            "name": "galah",
            "relay": {
                "ip-address": [ "2001:db8:2:34::1" ]
            },
            "subnet6": [
                {
                    "subnet": "2001:db8:1::/64",
                    "pools": [ { "pool": "2001:db8:1::20 - 2001:db8:1::ff" } ],
                },
                {
                    "subnet": "2001:db8:3::/64",
                    "pools": [ { "pool": "2001:db8:3::20 - 2001:db8:3::ff" } ],
                    <strong class="userinput"><code>"client-class": "b-devices"</code></strong>
                }
            ]
        }
    ]
}
</pre><p>

        If the client belongs to "b-devices" class (because it includes option
        1234 with a value of 0x0002) it doesn't guarantee that the subnet 2001:db8:3::/64
        will be used (or preferred) for this client. The server can use any of
        the two subnets because the subnet 2001:db8:1::/64 is also allowed for
        this client. The client classification used in this case should be pereceived
        as a way to restrict access to certain subnets, rather than a way to express
        subnet preference. For example, if the client doesn't belong to the
        "b-devices" class it may only use the subnet 2001:db8:1::/64 and will
        never use the subnet 2001:db8:3::/64.
      </p><p>A typical use case for client classification is in the cable network,
      where cable modems should use one subnet and other devices should use
      another subnet within the same shared network. In this case it is required
      to apply classification on all subnets. The following example defines two
      classes of devices. The subnet selection is made based on option 1234 values.
</p><pre class="screen">
{
    "client-classes": [
        {

            "name": "a-devices",
            "test": "option[1234].hex == 0x0001"
        },
        {
            "name": "b-devices",
            "test": "option[1234].hex == 0x0002"
        }
    ],
    "shared-networks": [
        {
            "name": "galah",
            "relay": {
                "ip-addresses":  [ "2001:db8:2:34::1" ]
            },
            "subnet6": [
                {
                    "subnet": "2001:db8:1::/64",
                    "pools": [ { "pool": "2001:db8:1::20 - 2001:db8:1::ff" } ],
                    <strong class="userinput"><code>"client-class": "a-devices"</code></strong>
                },
                {
                    "subnet": "2001:db8:3::/64",
                    "pools": [ { "pool": "2001:db8:3::20 - 2001:db8:3::ff" } ],
                    <strong class="userinput"><code>"client-class": "b-devices"</code></strong>
                }
            ]
        }
    ]
}
</pre><p>
In this example each class has its own restriction. Only clients that belong to
class a-devices will be able to use subnet 2001:db8:1::/64 and only clients
belonging to b-devices will be able to use subnet 2001:db8:3::/64. Care should
be taken to not define too restrictive classification rules, as clients that are
unable to use any subnets will be refused service. Although, this may be
desired outcome if one desires to service only clients of known properties
(e.g. only VoIP phones allowed on a given link).</p><p>
      Note that it is possible to achieve similar effect as presented in this
      section without the use of shared networks. If the subnets are placed in
      the global subnets scope, rather than in the shared network, the server
      will still use classification rules to pick the right subnet for a given
      class of devices. The major benefit of placing subnets within the
      shared network is that common parameters for the logically grouped
      subnets can be specified once, in the shared network scope, e.g.
      "interface" or "relay" parameter. All subnets belonging to this shared
      network will inherit those parameters.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp57812720"></a>9.4.3. Host reservations in shared networks</h3></div></div></div><p>
  Subnets being part of a shared network allow host reservations, similar to
  regular subnets:
  </p><pre class="screen">
{
    "shared-networks": [
    {
        "name": "frog",
        "relay": {
            "ip-addresses": [ "2001:db8:2:34::1" ]
        },
        "subnet6": [
            {
                "subnet": "2001:db8:1::/64",
                "id": 100,
                "pools": [ { "2001:db8:1::1 - 2001:db8:1::64" } ],
                <strong class="userinput"><code>"reservations": [
                {
                    "duid": "00:03:00:01:11:22:33:44:55:66",
                    "ip-addresses": [ "2001:db8:1::28" ]
                }
                ]</code></strong>
            },
            {
                "subnet": "2001:db8:3::/64",
                "id": 101,
                "pools": [ { "pool": "2001:db8:3::1 - 2001:db8:3::64" } ],
                <strong class="userinput"><code>"reservations": [
                    {
                        "duid": "00:03:00:01:aa:bb:cc:dd:ee:ff",
                        "ip-addresses": [ "2001:db8:2::28" ]
                    }
                ]</code></strong>
            }
        ]
    }
    ]
}
  </pre><p>
</p><p>It is worth noting that Kea conducts additional checks when processing a
packet if shared networks are defined. First, instead of simply checking if
there's a reservation for a given client in his initially selected subnet, it
goes through all subnets in a shared network looking for a reservation. This is
one of the reasons why defining a shared network may impact performance. If
there is a reservation for a client in any subnet, that particular subnet will
be picked for the client. Although it's technically not an error, it is
considered a bad practice to define reservations for the same host in multiple
subnets belonging to the same shared network.</p><p>While not strictly mandatory, it is strongly recommended to use explicit
"id" values for subnets if you plan to use database storage for host
reservations. If ID is not specified, the values for it be autogenerated,
i.e. it will assign increasing integer values starting from 1. Thus, the
autogenerated IDs are not stable across configuration changes.
</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-serverid"></a>9.5. Server Identifier in DHCPv6</h2></div></div></div><p>The DHCPv6 protocol uses a "server identifier" (also known
      as a DUID) for clients to be able to discriminate between several
      servers present on the same link.
      <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>
      defines three DUID types: DUID-LLT, DUID-EN and DUID-LL.
      <a class="ulink" href="http://tools.ietf.org/html/rfc6355" target="_top">RFC 6355</a>
      also defines DUID-UUID. Future specifications may introduce new
      DUID types.</p><p>The Kea DHCPv6 server generates a server identifier once, upon
      the first startup, and stores it in a file. This identifier isn't
      modified across restarts of the server and so is a stable identifier.</p><p>Kea follows recommendation from
      <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>
      to use DUID-LLT as the default server identifier. However, we have
      received reports that some deployments require different DUID
      types, and there is a need to administratively select both DUID
      type and/or its contents.</p><p>The server identifier can be configured using parameters
      within the <span class="command"><strong>server-id</strong></span> map element in the global
      scope of the Kea configuration file. The following example
      demonstrates how to select DUID-EN as a server identifier:

</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "EN"
    },
    ...
}
</pre><p>

      </p><p>Currently supported values for <span class="command"><strong>type</strong></span>
      parameter are: "LLT", "EN" and "LL", for DUID-LLT, DUID-EN and
      DUID-LL respectively.</p><p>When a new DUID type is selected the server will generate its
      value and replace any existing DUID in the file. The server will then
      use the new server identifier in all future interactions with the
      clients.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If the new server identifier is created after some clients
      have obtained their leases, the clients using the old identifier will not
      be able to renew the leases: the server will ignore messages
      containing the old server identifier. Clients will continue sending
      Renew until they transition to the rebinding state. In this state they
      will start sending Rebind messages to multicast address without
      a server identifier. The server will respond to the Rebind messages
      with a new server identifier and the clients will associate the
      new server identifier with their leases. Although the clients will
      be able to keep their leases and will eventually learn the new server
      identifier, this will be at the cost of increased number of renewals
      and multicast traffic due to a need to rebind. Therefore it is
      recommended that modification of the server identifier type
      and value is avoided if the server has already assigned leases and these
      leases are still valid.</p></div><p>There are cases when an administrator needs to explicitly
      specify a DUID value rather than allow the server to generate it.
      The following example demonstrates how to explicitly set all
      components of a DUID-LLT.

</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "LLT",
        "htype": 8,
        "identifier": "A65DC7410F05",
        "time": 2518920166
    },
    ...
}
</pre><p>

      where:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>htype</strong></span> is a 16-bit unsigned value
        specifying hardware type,</li><li class="listitem"><span class="command"><strong>identifier</strong></span> is a link layer
        address, specified as a string of hexadecimal digits,</li><li class="listitem"><span class="command"><strong>time</strong></span> is a 32-bit unsigned
        time value.</li></ul></div><p>
      </p><p>The hexadecimal representation of the DUID generated as a result
      of the configuration specified above will be:
</p><pre class="screen">
 00:01:00:08:96:23:AB:E6:A6:5D:C7:41:0F:05
|type |htype|   time    |   identifier    |
</pre><p>
      </p><p>It is allowed to use special value of 0 for "htype" and "time",
      which indicates that the server should use ANY value for these
      components. If the server already uses a DUID-LLT it will use the
      values from this DUID. If the server uses a DUID of a different type
      or doesn't use any DUID yet, it will generate these values.
      Similarly, if the "identifier" is assigned an empty string, the
      value of the identifier will be generated. Omitting any of these
      parameters is equivalent to setting them to those special values.
      </p><p>For example, the following configuration:
</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "LLT",
        "htype": 0,
        "identifier": "",
        "time": 2518920166
    },
    ...
}
</pre><p>

      indicates that the server should use ANY link layer address and
      hardware type. If the server is already using DUID-LLT it will
      use the link layer address and hardware type from the existing DUID.
      If the server is not using any DUID yet, it will use link layer
      address and hardware type from one of the available network
      interfaces. The server will use an explicit value of time. If it
      is different than a time value present in the currently used
      DUID, that value will be replaced, effectively causing
      modification of the current server identifier.
      </p><p>
        The following example demonstrates an explicit configuration of
        a DUID-EN:

</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "EN",
        "enterprise-id": 2495,
        "identifier": "87ABEF7A5BB545"
    },
    ...
}
</pre><p>

      where:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>enterprise-id</strong></span> is a 32-bit
        unsigned value holding enterprise number,</li><li class="listitem"><span class="command"><strong>identifier</strong></span> is a variable
        length identifier within DUID-EN.</li></ul></div><p>
      </p><p>
        The hexadecimal representation of the DUID-EN created according to
        the configuration above is:
</p><pre class="screen">
 00:02:00:00:09:BF:87:AB:EF:7A:5B:B5:45
|type |  ent-id   |     identifier     |
</pre><p>
      </p><p>As in the case of the DUID-LLT, special values can be used for the
      configuration of the DUID-EN. If <span class="command"><strong>enterprise-id</strong></span> is 0, the server
      will use a value from the existing DUID-EN. If the server is not using
      any DUID or the existing DUID has a different type, the ISC enterprise
      id will be used. When an empty string is used for <span class="command"><strong>identifier</strong></span>, the
      identifier from the existing DUID-EN will be used. If the server is
      not using any DUID-EN the new 6-bytes long identifier will be generated.
      </p><p>DUID-LL is configured in the same way as DUID-LLT with an exception
      that the <span class="command"><strong>time</strong></span> parameter has no effect for DUID-LL,
      because this DUID type only comprises a hardware type and link layer
      address. The following example demonstrates how to configure DUID-LL:

</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "LL",
        "htype": 8,
        "identifier": "A65DC7410F05"
    },
    ...
}
</pre><p>

      </p><p>
      which will result in the following server identifier:

</p><pre class="screen">
 00:03:00:08:A6:5D:C7:41:0F:05
|type |htype|   identifier    |
</pre><p>
      </p><p>The server stores the generated server identifier in the following
      location: [kea-install-dir]/var/kea/kea-dhcp6-serverid.
      </p><p>In some uncommon deployments where no stable storage is
      available, the server should be configured not to try to
      store the server identifier. This choice is controlled
      by the value of <span class="command"><strong>persist</strong></span> boolean parameter:
</p><pre class="screen">
"Dhcp6": {
    "server-id": {
        "type": "EN",
        "enterprise-id": 2495,
        "identifier": "87ABEF7A5BB545",
        "persist": false
    },
    ...
}
</pre><p>
      </p><p>The default value of the "persist" parameter is
      <span class="command"><strong>true</strong></span> which configures the server to store the
      server identifier on a disk.</p><p>In the example above, the server is configured to not store
      the generated server identifier on a disk. But, if the server
      identifier is not modified in the configuration the same value
      will be used after server restart, because entire server
      identifier is explicitly specified in the configuration.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stateless-dhcp6"></a>9.6. Stateless DHCPv6 (Information-Request Message)</h2></div></div></div><p>Typically DHCPv6 is used to assign both addresses and options. These
      assignments (leases) have state that changes over time, hence
      their name, stateful. DHCPv6 also supports a stateless mode,
      where clients request configuration options only. This mode is
      considered lightweight from the server perspective as it does not require
      any state tracking; hence its name.</p><p>The Kea server supports stateless mode. Clients can send
      Information-Request messages and the server will send back
      answers with the requested options (providing the options are
      available in the server configuration).  The server will attempt to
      use per-subnet options first. If that fails - for whatever reason - it
      will then try to provide options defined in the global scope.</p><p>Stateless and stateful mode can be used together. No special
      configuration directives are required to handle this. Simply use the
      configuration for stateful clients and the stateless clients will get
      just options they requested.</p><p>This usage of global options allows for an interesting case.
      It is possible to run a server that provides just options and no
      addresses or prefixes. If the options have the same value in each
      subnet, the configuration can define required options in the global
      scope and skip subnet definitions altogether. Here's a simple example of
      such a configuration:
</p><pre class="screen">
"Dhcp6": {
    "interfaces-config": {
        "interfaces": [ "ethX" ]
    },
    <strong class="userinput"><code>"option-data": [ {
        "name": "dns-servers",
        "data": "2001:db8::1, 2001:db8::2"
    } ]</code></strong>,
    "lease-database": { "type": "memfile" }
 }
</pre><p>
      This very simple configuration will provide DNS server information
      to all clients in the network, regardless of their location. Note the
      specification of the memfile lease database: this is needed as
      Kea requires a lease database to be specified
      even if it is not used.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-rfc7550"></a>9.7. Support for RFC 7550</h2></div></div></div><p>The <a class="ulink" href="http://tools.ietf.org/html/rfc7550" target="_top">RFC 7550</a>
      introduced some changes to the DHCPv6 protocol to resolve a few issues
      with the coexistence of multiple stateful options in the messages sent
      between the clients and servers.</p><p>The typical example is when the client, such as a requesting
      router, requests an allocation of both addresses and prefixes when
      it performs the 4-way (SARR) exchange with the server. If the
      server is not configured to allocate any prefixes but it can allocate
      some addresses, it will respond with the IA_NA(s) containing allocated
      addresses and the IA_PD(s) containing the NoPrefixAvail status code. If
      the client can operate without prefixes it may transition to the
      'bound' state when it sends Renew/Rebind messages to the server,
      according to the T1 and T2 times, to extend the lifetimes of the
      allocated addresses. If the client is still interested in obtaining
      prefixes from the server it may also include an IA_PD in the Renew/Rebind
      to request allocation of the prefixes. If the server still cannot
      allocate the prefixes, it will respond with the IA_PD(s) containing
      NoPrefixAvail status code. However, if the server can now allocate
      the prefixes it will do so, and send them in the IA_PD(s) to the client.
      Allocation of leases during the Renew/Rebind was not supported in the
      <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>
      and <a class="ulink" href="http://tools.ietf.org/html/rfc3633" target="_top">RFC 3633</a>,
      and has been introduced in
      <a class="ulink" href="http://tools.ietf.org/html/rfc7550" target="_top">RFC 7550</a>.
      Kea supports this new behavior and it doesn't provide any configuration
      mechanisms to disable it.
      </p><p>
        The following are the other behaviors specified in the
        <a class="ulink" href="http://tools.ietf.org/html/rfc7550" target="_top">RFC 7550</a>
        supported by the Kea DHCPv6 server:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Set T1/T2 timers to the same value for all
          stateful (IA_NA and IA_PD) options to facilitate renewal of all
          client's leases at the same time (in a single message exchange),
          </li><li class="listitem">NoAddrsAvail and NoPrefixAvail status codes
          are placed in the IA_NA and IA_PD options in the Advertise message,
          rather than as the top level options.</li></ul></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-relay-override"></a>9.8. Using Specific Relay Agent for a Subnet</h2></div></div></div><p>
        The relay has to have an interface connected to the link on which
        the clients are being configured. Typically the relay has a global IPv6
        address configured on the interface that belongs to the subnet from which
        the server will assign addresses. In the typical case, the
        server is able to use the IPv6 address inserted by the relay (in the link-addr
        field in RELAY-FORW message) to select the appropriate subnet.
      </p><p>
        However, that is not always the case. The relay
        address may not match the subnet in certain deployments. This
        usually means that there is more than one subnet allocated for a given
        link. The two most common examples where this is the case are long lasting
        network renumbering (where both old and new address space is still being
        used) and a cable network. In a cable network both cable modems and the
        devices behind them are physically connected to the same link, yet
        they use distinct addressing. In such case, the DHCPv6 server needs
        additional information (like the value of interface-id option or IPv6
        address inserted in the link-addr field in RELAY-FORW message) to
        properly select an appropriate subnet.
      </p><p>
        The following example assumes that there is a subnet 2001:db8:1::/64
        that is accessible via a relay that uses 3000::1 as its IPv6 address.
        The server will be able to select this subnet for any incoming packets
        that came from a relay with an address in 2001:db8:1::/64 subnet.
        It will also select that subnet for a relay with address 3000::1.
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::1-2001:db8:1::ffff"
                 }
             ],
             <strong class="userinput"><code>"relay": {
                 "ip-addresses": [ "3000::1" ]
             }</code></strong>
        }
    ]
}
</pre><p>
      </p><p>If "relay" is specified, the "ip-addresses" parameter within
      it is mandatory.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      As of Kea 1.4, the "ip-address" parameter in "relay" has been deprecated
      in favor of "ip-addresses" which supports specifying a list of addresses.
      Configuration parsing, will honor the singular form for now but users are
      encouraged to migrate.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-client-class-relay"></a>9.9. Segregating IPv6 Clients in a Cable Network</h2></div></div></div><p>
          In certain cases, it is useful to mix relay address information,
          introduced in <a class="xref" href="#dhcp6-relay-override" title="9.8. Using Specific Relay Agent for a Subnet">Section 9.8, “Using Specific Relay Agent for a Subnet”</a> with client
          classification, explained in <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a>.
          One specific example is a cable network, where typically modems
          get addresses from a different subnet than all devices connected
          behind them.
        </p><p>
          Let's assume that there is one CMTS (Cable Modem Termination System)
          with one CM MAC (a physical link that modems are connected to).
          We want the modems to get addresses from the 3000::/64 subnet,
          while everything connected behind modems should get addresses from
          another subnet (2001:db8:1::/64). The CMTS that acts as a relay
          an uses address 3000::1. The following configuration can serve
          that configuration:
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [
        {
            "subnet": "3000::/64",
            "pools": [
                { "pool": "3000::2 - 3000::ffff" }
            ],
            <strong class="userinput"><code>"client-class": "VENDOR_CLASS_docsis3.0",
            "relay": {
                "ip-addresses": [ "3000::1" ]
            }</code></strong>
        },

        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::1-2001:db8:1::ffff"
                 }
             ],
             <strong class="userinput"><code>"relay": {
                 "ip-addresses": [ "3000::1" ]
             }</code></strong>
        }
    ]
}
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mac-in-dhcpv6"></a>9.10. MAC/Hardware Addresses in DHCPv6</h2></div></div></div><p>MAC/hardware addresses are available in DHCPv4 messages
      from the clients and administrators
      frequently use that information to perform certain tasks, like per host
      configuration, address reservation for specific MAC addresses and other.
      Unfortunately, the DHCPv6 protocol does not provide any completely reliable way
      to retrieve that information. To mitigate that issue a number of mechanisms
      have been implemented in Kea that attempt to gather it. Each
      of those mechanisms works in certain cases, but may fail in other cases.
      Whether the mechanism works or not in the particular deployment is
      somewhat dependent on the network topology and the technologies used.</p><p>Kea allows configuration of which of the supported methods should be
      used and in what order. This configuration may be considered a fine tuning
      of the DHCP deployment. In a typical deployment the default
      value of <span class="command"><strong>"any"</strong></span> is sufficient and there is no
      need to select specific methods. Changing the value of this parameter
      is the most useful in cases when an administrator wants to disable
      certain method, e.g. if the administrator trusts the network infrastructure
      more than the information provided by the clients themselves, the
      administrator may prefer information provided by the relays over that
      provided by the clients.
      </p><p>
      The configuration is controlled by the <span class="command"><strong>mac-sources</strong></span>
      parameter as follows:
        </p><pre class="screen">
"Dhcp6": {
    <strong class="userinput"><code>"mac-sources": [ "method1", "method2", "method3", ... ]</code></strong>,

    "subnet6": [ ... ],

    ...
}
</pre><p>

    When not specified, a special value of "any" is used, which
    instructs the server to attempt to use all the methods in sequence and use
    value returned by the first one that succeeds. If specified, it
    has to have at least one value.</p><p>Supported methods are:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>any</strong></span> - Not an actual method, just a keyword that
        instructs Kea to try all other methods and use the first one that succeeds.
        This is the default operation if no <span class="command"><strong>mac-sources</strong></span> are defined.
        </li><li class="listitem"><span class="command"><strong>raw</strong></span> - In principle, a DHCPv6 server could use raw
        sockets to receive incoming traffic and extract MAC/hardware address
        information. This is currently not implemented for DHCPv6 and this value has
        no effect.
        </li><li class="listitem"><span class="command"><strong>duid</strong></span> - DHCPv6 uses DUID identifiers instead of
        MAC addresses. There are currently four DUID types defined, with two of them
        (DUID-LLT, which is the default one and DUID-LL) convey MAC address information.
        Although <a class="ulink" href="" target="_top">RFC 3315</a> forbids
        it, it is possible to parse those DUIDs and extract
        necessary information from them. This method is not completely reliable, as
        clients may use other DUID types, namely DUID-EN or DUID-UUID.
        </li><li class="listitem"><span class="command"><strong>ipv6-link-local</strong></span> - Another possible acquisition
        method comes from the source IPv6 address. In typical usage, clients are
        sending their packets from IPv6 link-local addresses. There is a good chance
        that those addresses are based on EUI-64, which contains MAC address. This
        method is not completely reliable, as clients may use other link-local address
        types.  In particular, privacy extensions, defined in
        <a class="ulink" href="http://tools.ietf.org/html/rfc4941" target="_top">RFC 4941</a>, do not use
        MAC addresses.  Also note that successful extraction requires that the
        address's u-bit must be set to 1 and its g-bit set to 0, indicating that it
        is an interface identifier as per
        <a class="ulink" href="http://tools.ietf.org/html/rfc2373#section-2.5.1" target="_top">
        RFC 2373, section 2.5.1</a>.
        </li><li class="listitem"><span class="command"><strong>client-link-addr-option</strong></span> - One extension defined
        to alleviate missing MAC issues is client link-layer address option, defined
        in <a class="ulink" href="http://tools.ietf.org/html/rfc6939" target="_top">RFC 6939</a>. This is
        an option that is inserted by a relay and contains information about client's
        MAC address. This method requires a relay agent that supports the option and
        is configured to insert it. This method is useless for directly connected
        clients. This parameter can also be specified as <span class="command"><strong>rfc6939</strong></span>,
        which is an alias for <span class="command"><strong>client-link-addr-option</strong></span>.
        </li><li class="listitem"><span class="command"><strong>remote-id</strong></span> -
        <a class="ulink" href="http://tools.ietf.org/html/rfc4649" target="_top">RFC 4649</a>
        defines a remote-id option that is inserted by a relay agent. Depending
        on the relay agent configuration, the inserted option may convey the client's
        MAC address information. This parameter can also be specified as
        <span class="command"><strong>rfc4649</strong></span>, which is an alias for <span class="command"><strong>remote-id</strong></span>.
        </li><li class="listitem"><span class="command"><strong>subscriber-id</strong></span> - Another option
        that is somewhat similar to the previous one is subscriber-id,
        defined in <a class="ulink" href="http://tools.ietf.org/html/rfc4580" target="_top">RFC
        4580</a>. It is, too, inserted by a relay agent that is
        configured to insert it. This parameter can also be specified
        as <span class="command"><strong>rfc4580</strong></span>, which is an alias for
        <span class="command"><strong>subscriber-id</strong></span>. This method is currently not
        implemented.
        </li><li class="listitem"><span class="command"><strong>docsis-cmts</strong></span> - Yet another possible source of MAC
        address information are the DOCSIS options inserted by a CMTS that acts
        as a DHCPv6 relay agent in cable networks. This method attempts to extract
        MAC address information from suboption 1026 (cm mac) of the vendor specific option
        with vendor-id=4491. This vendor option is extracted from the relay-forward message,
        not the original client's message.
        </li><li class="listitem"><span class="command"><strong>docsis-modem</strong></span> - Yet another possible source of MAC
        address information are the DOCSIS options inserted by the cable modem itself.
        This method attempts to extract MAC address information from suboption 36 (device id)
        of the vendor specific option with vendor-id=4491. This vendor option is extracted from
        the original client's message, not from any relay options.
        </li></ul></div><p>
  </p><p>Empty mac-sources is not allowed. If you do not want to specify it,
  either simply omit mac-sources definition or specify it with the "any" value
  which is the default.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-decline"></a>9.11. Duplicate Addresses (DECLINE Support)</h2></div></div></div><p>The DHCPv6 server is configured with a certain pool of
      addresses that it is expected to hand out to the DHCPv6 clients.
      It is assumed that the server is authoritative and has complete
      jurisdiction over those addresses. However, due to various
      reasons, such as misconfiguration or a faulty client implementation
      that retains its address beyond the valid lifetime, there may be
      devices connected that use those addresses without the server's
      approval or knowledge.</p><p>Such an unwelcome event can be detected
      by legitimate clients (using Duplicate Address Detection) and
      reported to the DHCPv6 server using a DECLINE message. The server
      will do a sanity check (if the client declining an address really
      was supposed to use it), then will conduct a clean up operation
      and confirm it by sending back a REPLY message. Any DNS entries
      related to that address will be removed, the fact will be logged
      and hooks will be triggered. After that is done, the address
      will be marked as declined (which indicates that it is used by
      an unknown entity and thus not available for assignment to
      anyone) and a probation time will be set on it. Unless otherwise
      configured, the probation period lasts 24 hours. After that
      period, the server will recover the lease (i.e. put it back into
      the available state) and the address will be available for assignment
      again. It should be noted that if the underlying issue of a
      misconfigured device is not resolved, the duplicate address
      scenario will repeat. On the other hand, it provides an
      opportunity to recover from such an event automatically, without
      any sysadmin intervention.</p><p>To configure the decline probation period to a value other
      than the default, the following syntax can be used:
</p><pre class="screen">
  "Dhcp6": {
    <strong class="userinput"><code>"decline-probation-period": 3600</code></strong>,
    "subnet6": [ ... ],
    ...
}
</pre><p>
      The parameter is expressed in seconds, so the example above will instruct
      the server to recycle declined leases after an hour.</p><p>There are several statistics and hook points associated with the
      Decline handling procedure. The lease6_decline hook is triggered after the
      incoming Decline message has been sanitized and the server is about to decline
      the lease. The declined-addresses statistic is increased after the
      hook returns (both global and subnet specific variants). (See
      <a class="xref" href="#dhcp4-stats" title="8.8. Statistics in the DHCPv4 Server">Section 8.8, “Statistics in the DHCPv4 Server”</a> and <a class="xref" href="#hooks-libraries" title="Chapter 14. Hooks Libraries">Chapter 14, <i>Hooks Libraries</i></a> for more details
      on DHCPv4 statistics and Kea hook points.)</p><p>Once the probation time elapses, the declined lease is recovered
      using the standard expired lease reclamation procedure, with several
      additional steps. In particular, both declined-addresses statistics
      (global and subnet specific) are decreased. At the same time,
      reclaimed-declined-addresses statistics (again in two variants, global and
      subnet specific) are increased.</p><p>Note about statistics: The server does not decrease the
      assigned-addresses statistics when a DECLINE message is received and
      processed successfully. While technically a declined address is no longer
      assigned, the primary usage of the assigned-addresses statistic is to
      monitor pool utilization. Most people would forget to include
      declined-addresses in the calculation, and simply do
      assigned-addresses/total-addresses. This would have a bias towards
      under-representing pool utilization. As this has a potential for major
      issues, we decided not to decrease assigned addresses immediately after
      receiving Decline, but to do it later when we recover the address back to
      the available pool.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-stats"></a>9.12. Statistics in the DHCPv6 Server</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This section describes DHCPv6-specific statistics. For a general
        overview and usage of statistics, see <a class="xref" href="#stats" title="Chapter 15. Statistics">Chapter 15, <i>Statistics</i></a>.</p></div><p>
        The DHCPv6 server supports the following statistics:
      </p><div class="table"><a name="dhcp6-statistics"></a><p class="title"><b>Table 9.4. DHCPv6 Statistics</b></p><div class="table-contents"><table summary="DHCPv6 Statistics" border="1"><colgroup><col align="center" class="statistic"><col align="center" class="type"><col align="left" class="description"></colgroup><thead><tr><th align="center">Statistic</th><th align="center">Data Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center">pkt6-received</td><td align="center">integer</td><td align="left">Number of DHCPv6 packets received. This includes all packets:
              valid, bogus, corrupted, rejected etc. This statistic is expected
              to grow rapidly.</td></tr><tr><td align="center">pkt6-receive-drop</td><td align="center">integer</td><td align="left">Number of incoming packets that were dropped. The exact reason
              for dropping packets is logged, but the most common reasons may
              be: an unacceptable or not supported packet type, direct responses
              are forbidden, the server-id sent by the client does not match the
              server's server-id or the packet is malformed.</td></tr><tr><td align="center">pkt6-parse-failed</td><td align="center">integer</td><td align="left">Number of incoming packets that could not be parsed.
              A non-zero value of this statistic indicates that the server
              received a malformed or truncated packet. This may indicate problems
              in your network, faulty clients, faulty relay agents or a bug in the
              server.</td></tr><tr><td align="center">pkt6-solicit-received</td><td align="center">integer</td><td align="left">
                Number of SOLICIT packets received. This statistic is expected
                to grow.  Its increase means that clients that just booted
                started their configuration process and their initial packets
                reached your server.
              </td></tr><tr><td align="center">pkt6-advertise-received</td><td align="center">integer</td><td align="left">
                Number of ADVERTISE packets received. Advertise packets are sent
                by the server and the server is never expected to receive them. A non-zero
                value of this statistic indicates an error occurring in the network.
                One likely cause would be a misbehaving relay agent that incorrectly
                forwards ADVERTISE messages towards the server rather back to the
                clients.
              </td></tr><tr><td align="center">pkt6-request-received</td><td align="center">integer</td><td align="left">Number of REQUEST packets received. This statistic
                is expected to grow. Its increase means that clients that just booted
                received the server's response (ADVERTISE), accepted it and are now
                requesting an address (REQUEST).
              </td></tr><tr><td align="center">pkt6-reply-received</td><td align="center">integer</td><td align="left">Number of REPLY packets received. This statistic is
              expected to remain zero at all times, as REPLY packets are sent by
              the server and the server is never expected to receive
              them. A non-zero value indicates an error. One likely cause would be
              a misbehaving relay agent that incorrectly forwards REPLY messages
              towards the server, rather back to the clients.
              </td></tr><tr><td align="center">pkt6-renew-received</td><td align="center">integer</td><td align="left">Number of RENEW packets received. This statistic
                is expected to grow. Its increase means that clients received their
                addresses and prefixes and are trying to renew them.
              </td></tr><tr><td align="center">pkt6-rebind-received</td><td align="center">integer</td><td align="left">Number of REBIND packets received. A non-zero value
              indicates that clients didn't receive responses to their RENEW messages
              (regular lease renewal mechanism) and are attempting to find any server
              that is able to take over their leases. It may mean that some server's
              REPLY messages never reached the clients.
              </td></tr><tr><td align="center">pkt6-release-received</td><td align="center">integer</td><td align="left">Number of RELEASE packets received. This statistic is expected
              to grow when a device is being shut down in the network. It
              indicates that the address or prefix assigned is reported as no longer
              needed. Note that many devices, especially wireless, do not send RELEASE
              packets either because of design choice or due to the client moving out
              of range.
              </td></tr><tr><td align="center">pkt6-decline-received</td><td align="center">integer</td><td align="left">
              Number of DECLINE packets received. This statistic is expected to
              remain close to zero. Its increase means that a client leased an
              address, but discovered that the address is currently used by an
              unknown device in your network. If this statistic is growing, it
              may indicate a misconfigured server or devices that have statically
              assigned conflicting addresses.
            </td></tr><tr><td align="center">pkt6-infrequest-received</td><td align="center">integer</td><td align="left">
                Number of INFORMATION-REQUEST packets received. This statistic
                is expected to grow if there are devices that are using
                stateless DHCPv6. INFORMATION-REQUEST messages are used by
                clients that request stateless configuration, i.e. options
                and parameters other than addresses or prefixes.
              </td></tr><tr><td align="center">pkt6-dhcpv4-query-received</td><td align="center">integer</td><td align="left">
                Number of DHCPv4-QUERY packets received. This
                statistic is expected to grow if there are devices
                that are using DHCPv4-over-DHCPv6. DHCPv4-QUERY
                messages are used by DHCPv4 clients on an IPv6 only
                line which encapsulates the requests over DHCPv6.
              </td></tr><tr><td align="center">pkt6-dhcpv4-response-received</td><td align="center">integer</td><td align="left">
                Number of DHCPv4-RESPONSE packets received. This
                statistic is expected to remain zero at all times, as
                DHCPv4-RESPONSE packets are sent by the server and the
                server is never expected to receive them. A non-zero
                value indicates an error.  One likely cause would be a
                misbehaving relay agent that incorrectly forwards
                DHCPv4-RESPONSE message towards the server rather
                back to the clients.
              </td></tr><tr><td align="center">pkt6-unknown-received</td><td align="center">integer</td><td align="left">Number of packets received of an unknown type. A non-zero
              value of this statistic indicates that the server received a
              packet that it wasn't able to recognize: either it had an unsupported
              type or was possibly malformed.</td></tr><tr><td align="center">pkt6-sent</td><td align="center">integer</td><td align="left">Number of DHCPv6 packets sent. This statistic is expected
              to grow every time the server transmits a packet. In general, it
              should roughly match pkt6-received, as most incoming packets cause
              the server to respond. There are exceptions (e.g. server receiving a
              REQUEST with server-id matching other server), so do not worry, if
              it is lesser than pkt6-received.</td></tr><tr><td align="center">pkt6-advertise-sent</td><td align="center">integer</td><td align="left">Number of ADVERTISE packets sent. This statistic is
              expected to grow in most cases after a SOLICIT is processed. There
              are certain uncommon, but valid cases where incoming SOLICIT is
              dropped, but in general this statistic is expected to be close to
              pkt6-solicit-received.</td></tr><tr><td align="center">pkt6-reply-sent</td><td align="center">integer</td><td align="left">Number of REPLY packets sent. This statistic is expected to
              grow in most cases after a SOLICIT (with rapid-commit), REQUEST,
              RENEW, REBIND, RELEASE, DECLINE or INFORMATION-REQUEST is
              processed. There are certain cases where there is no response.
              </td></tr><tr><td align="center">pkt6-dhcpv4-response-sent</td><td align="center">integer</td><td align="left">Number of DHCPv4-RESPONSE packets sent. This
              statistic is expected to grow in most cases after a
              DHCPv4-QUERY is processed. There are certain cases where
              there is no response.
              </td></tr><tr><td align="center">subnet[id].total-nas</td><td align="center">integer</td><td align="left">
            This statistic shows the total number of NA addresses available for
            DHCPv6 management for a given subnet. In other words, this is the sum
            of all addresses in all configured pools. This statistic changes only
            during configuration changes. Note that it does not take into account any
            addresses that may be reserved due to host reservation. The
            <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
            statistic is exposed for each subnet separately and is
            reset during a reconfiguration event.
            </td></tr><tr><td align="center">subnet[id].assigned-nas</td><td align="center">integer</td><td align="left">
            This statistic shows the number of NA addresses in a given subnet that
            are assigned. This statistic increases every time a new lease is allocated
            (as a result of receiving a REQUEST message) and is decreased every time a
            lease is released (a RELEASE message is received) or expires. The
            <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
            statistic is exposed for each subnet separately and is
            reset during a reconfiguration event.
            </td></tr><tr><td align="center">subnet[id].total-pds</td><td align="center">integer</td><td align="left">
            This statistic shows the total number of PD prefixes available for
            DHCPv6 management for a given subnet. In other words, this is the sum
            of all prefixes in all configured pools. This statistic changes only
            during configuration changes. Note it does not take into account any
            prefixes that may be reserved due to host reservation. The
            <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
            statistic is exposed for each subnet separately and is
            reset during a reconfiguration event.
            </td></tr><tr><td align="center">subnet[id].assigned-pds</td><td align="center">integer</td><td align="left">
            This statistic shows the number of PD prefixes in a given subnet that
            are assigned. This statistic increases every time a new lease is allocated
            (as a result of receiving a REQUEST message) and is decreased every time a
            lease is released (a RELEASE message is received) or expires. The
            <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This statistic
            is exposed for each subnet separately and is reset during a
            reconfiguration event.
            </td></tr><tr><td align="center">reclaimed-leases</td><td align="center">integer</td><td align="left"> This statistic is the number of expired leases that have been
              reclaimed since server startup. It is incremented each time an expired
              lease is reclaimed (it counts both NA and PD reclamations) and is reset
              when the server is reconfigured.
              </td></tr><tr><td align="center">subnet[id].reclaimed-leases</td><td align="center">integer</td><td align="left">This statistic is the number of expired leases associated with
              a given subnet (<span class="emphasis"><em>"id"</em></span> is the subnet-id) that have
              been reclaimed since server startup. It is incremented each time an expired
              lease is reclaimed (it counts both NA and PD reclamations) and is reset
              when the server is reconfigured.
              </td></tr><tr><td align="center">declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv6 addresses that are
              currently declined and so counts the number of leases
              currently unavailable. Once a lease is recovered, this
              statistic will be decreased. Ideally, this statistic should be
              zero. If this statistic is non-zero (or worse, increasing),
              the network administrator should investigate if there is
              a misbehaving device in the network. This is a global statistic
              that covers all subnets.
            </td></tr><tr><td align="center">subnet[id].declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv6 addresses that are
              currently declined in a given subnet. This statistic counts the
              number of leases currently unavailable. Once a lease is
              recovered, this statistic will be decreased. Ideally, this
              statistic should be zero. If this statistic is
              non-zero (or worse, increasing), a network administrator should
              investigate if there is a misbehaving device in the network. The
              <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
              statistic is exposed for each subnet separately.
            </td></tr><tr><td align="center">reclaimed-declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv6 addresses that were
              declined, but have now been recovered. Unlike
              declined-addresses, this statistic never decreases. It can be used
              as a long term indicator of how many actual valid Declines were
              processed and recovered from. This is a global statistic that
              covers all subnets.
            </td></tr><tr><td align="center">subnet[id].reclaimed-declined-addresses</td><td align="center">integer</td><td align="left">
              This statistic shows the number of IPv6 addresses that were
              declined, but have now been recovered. Unlike
              declined-addresses, this statistic never decreases. It can be used
              as a long term indicator of how many actual valid Declines were
              processed and recovered from. The
              <span class="emphasis"><em>id</em></span> is the subnet-id of a given subnet. This
              statistic is exposed for each subnet separately.
            </td></tr></tbody></table></div></div><br class="table-break"></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-ctrl-channel"></a>9.13. Management API for the DHCPv6 Server</h2></div></div></div><p>
        The management API allows the issuing of specific
        management commands, such as statistics retrieval, reconfiguration or shutdown.
        For more details, see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>. Currently the only
        supported communication channel type is UNIX stream socket. By default there
        are no sockets open. To instruct Kea to open a socket, the following entry
        in the configuration file can be used:
</p><pre class="screen">
"Dhcp6": {
    "control-socket": {
        "socket-type": "unix",
        "socket-name": <strong class="userinput"><code>"/path/to/the/unix/socket"</code></strong>
    },

    "subnet6": [
        ...
    ],
    ...
}
</pre><p>
      </p><p>
        The length of the path specified by the <span class="command"><strong>socket-name</strong></span>
        parameter is restricted by the maximum length for the unix socket name
        on your operating system, i.e. the size of the <span class="command"><strong>sun_path</strong></span>
        field in the <span class="command"><strong>sockaddr_un</strong></span> structure, decreased by 1.
        This value varies on different operating systems between 91 and 107
        characters. Typical values are 107 on Linux and 103 on FreeBSD.
      </p><p>
        Communication over control channel is conducted using JSON structures.
        See the Control Channel section in the Kea Developer's Guide for more details.
      </p><p>The DHCPv6 server supports the following operational commands:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">build-report</li><li class="listitem">config-get</li><li class="listitem">config-reload</li><li class="listitem">config-set</li><li class="listitem">config-test</li><li class="listitem">config-write</li><li class="listitem">dhcp-disable</li><li class="listitem">dhcp-enable</li><li class="listitem">leases-reclaim</li><li class="listitem">list-commands</li><li class="listitem">shutdown</li><li class="listitem">version-get</li></ul></div><p>
         as described in <a class="xref" href="#commands-common" title="16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers">Section 16.3, “Commands Supported by Both the DHCPv4 and DHCPv6 Servers”</a>.  In addition,
         it supports the following statistics related commands:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">statistic-get</li><li class="listitem">statistic-reset</li><li class="listitem">statistic-remove</li><li class="listitem">statistic-get-all</li><li class="listitem">statistic-reset-all</li><li class="listitem">statistic-remove-all</li></ul></div><p>
        as described here <a class="xref" href="#command-stats" title="15.3. Commands for Manipulating Statistics">Section 15.3, “Commands for Manipulating Statistics”</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-user-contexts"></a>9.14. User contexts in IPv6</h2></div></div></div><p>
          Kea allows loading hook libraries that sometimes could benefit from
          additional parameters. If such a parameter is specific to the whole
          library, it is typically defined as a parameter for the hook library.
          However, sometimes there is a need to specify parameters that are
          different for each pool.
        </p><p>
          User contexts can store arbitrary data as long as it is valid JSON
          syntax and its top level element is a map (i.e. the data must be
          enclosed in curly brackets). Some hook libraries may expect specific
          formatting, though.  Please consult specific hook library
          documentation for details.
        </p><p>
          User contexts can be specified on either global scope,
          shared network, subnet, pool, client class, option data or
          definition level, and host reservation. One other useful
          usage is the ability to store comments or descriptions.
        </p><p>
          Let's consider a lightweight 4over6 deployment as an example. It is an
          IPv6 transition technology that allows mapping IPv6 prefix into full
          or parts of IPv4 addresses. In DHCP context, these are certain
          parameters that are supposed to be delivered to clients in form of
          additional options. Values of those options are correlated to
          delegated prefixes, so it is reasonable to keep those parameters
          together with the PD pool. On the other hand, lightweight 4over6 is
          not a commonly used feature, so it is not a part of the base Kea
          code. The solution to this problem is to use user context. For each PD
          pool that is expected to be used for lightweight 4over6, user context
          with extra parameters is defined. Those extra parameters will be used
          by hook library that would be loaded only when dynamic calculation of
          the lightweight 4over6 option is actually needed. An example
          configuration looks as follows:
          </p><pre class="screen">
"Dhcp6": {
    "subnet6": [ {
        "pd-pools": [
        {
            "prefix":  "2001:db8::",
            "prefix-len": 56,
            "delegated-len": 64,

            // This is a pool specific context.
            <strong class="userinput"><code>"user-context": {
                "threshold-percent": 85,
                "v4-network": "192.168.0.0/16",
                "v4-overflow": "10.0.0.0/16",
                "lw4over6-sharing-ratio": 64,
                "lw4over6-v4-pool": "192.0.2.0/24",
                "lw4over6-sysports-exclude": true,
                "lw4over6-bind-prefix-len": 56
            }</code></strong>
        } ],
        "subnet": "2001:db8::/32",

        // This is a subnet specific context. You can put any type of
        // information here as long as it is a valid JSON.
        <strong class="userinput"><code>"user-context": {
            "comment": "Those v4-v6 migration technologies are tricky.",
            "experimental": true,
            "billing-department": 42,
            "contact-points": [ "Alice", "Bob" ]
        }</code></strong>
    } ],
    ...
}</pre><p>
        </p><p>
          Kea does not interpret or use the content of the user context:
          it just stores it, making it available to the hook
          libraries. It is up to each hook library to extract the information
          and make use of it.
          The parser translates a "comment" entry into a user-context
          with the entry, this allows to attach a comment inside the
          configuration itself.
        </p><p>
          For more background information, see <a class="xref" href="#user-context" title="14.5. User contexts">Section 14.5, “User contexts”</a>.
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-std"></a>9.15. Supported DHCPv6 Standards</h2></div></div></div><p>The following standards are currently
      supported:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="emphasis"><em>Dynamic Host Configuration Protocol for IPv6</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a>:
            Supported messages are SOLICIT,
            ADVERTISE, REQUEST, RELEASE, RENEW, REBIND, INFORMATION-REQUEST,
            CONFIRM and REPLY.</li><li class="listitem"><span class="emphasis"><em>IPv6 Prefix Options for
            Dynamic Host Configuration Protocol (DHCP) version 6</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc3633" target="_top">RFC 3633</a>:
            Supported options are IA_PD and
            IA_PREFIX. Also supported is the status code NoPrefixAvail.</li><li class="listitem"><span class="emphasis"><em>DNS Configuration options for Dynamic Host
            Configuration Protocol for IPv6 (DHCPv6)</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc3646" target="_top">RFC 3646</a>:
            Supported option is DNS_SERVERS.</li><li class="listitem"><span class="emphasis"><em>The Dynamic Host Configuration Protocol for IPv6 (DHCPv6)
            Relay Agent Remote-ID Option</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc4649" target="_top">RFC 4649</a>:
            REMOTE-ID option is supported.</li><li class="listitem"><span class="emphasis"><em>The Dynamic Host Configuration Protocol for IPv6 (DHCPv6) Client
            Fully Qualified Domain Name (FQDN) Option</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc4704" target="_top">RFC 4704</a>:
            Supported option is CLIENT_FQDN.</li><li class="listitem"><span class="emphasis"><em>Dynamic Host Configuration Protocol for IPv6 (DHCPv6)
            Option for Dual-Stack Lite</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc6334" target="_top">RFC 6334</a>:
            the AFTR-Name DHCPv6 Option is supported.</li><li class="listitem"><span class="emphasis"><em>Relay-Supplied DHCP Options</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc6422" target="_top">RFC 6422</a>:
            Full functionality is supported: OPTION_RSOO, ability of the server
            to echo back the options, checks whether an option is RSOO-enabled,
            ability to mark additional options as RSOO-enabled.</li><li class="listitem"><span class="emphasis"><em>Prefix Exclude Option for DHCPv6-based Prefix
            Delegation</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc6603" target="_top">RFC
            6603</a>: Prefix Exclude option is supported.</li><li class="listitem"><span class="emphasis"><em>Client Link-Layer Address Option in
            DHCPv6</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc6939" target="_top">RFC
            6939</a>: Supported option is client link-layer
            address option.</li><li class="listitem"><span class="emphasis"><em>Issues and Recommendations with Multiple
            Stateful DHCPv6 Options</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc7550" target="_top">RFC
            7550</a>: All recommendations related to the DHCPv6 server
            operation are supported.</li><li class="listitem"><span class="emphasis"><em>DHCPv6 Options for Configuration of Softwire
            Address and Port-Mapped Clients</em></span>,
            <a class="ulink" href="http://tools.ietf.org/html/rfc7598" target="_top">RFC
            7598</a>: All options specified in this specification are
            supported by the DHCPv6 server.</li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-limit"></a>9.16. DHCPv6 Server Limitations</h2></div></div></div><p> These are the current limitations of the DHCPv6 server
      software. Most of them are reflections of the early stage of
      development and should be treated as <span class="quote">“<span class="quote">not implemented
      yet</span>”</span>, rather than actual limitations.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            The server will allocate, renew or rebind a maximum of one lease
            for a particular IA option (IA_NA or IA_PD) sent by a client.
            <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC 3315</a> and
            <a class="ulink" href="http://tools.ietf.org/html/rfc3633" target="_top">RFC 3633</a> allow
            for multiple addresses or prefixes to be allocated for a single IA.
          </li><li class="listitem">Temporary addresses are not supported.</li><li class="listitem">
            Client reconfiguration (RECONFIGURE) is not yet supported.
          </li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp6-srv-examples"></a>9.17. Kea DHCPv6 server examples</h2></div></div></div><p>
        A collection of simple to use examples for DHCPv6 component of Kea is
        available with the sources. It is located in doc/examples/kea6
        directory. At the time of writing this text there were 18 examples,
        but the number is growing slowly with each release.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="lease-expiration"></a>Chapter 10. Lease Expiration in DHCPv4 and DHCPv6</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#lease-reclamation">10.1. Lease Reclamation</a></span></dt><dt><span class="section"><a href="#lease-reclaim-config">10.2. Configuring Lease Reclamation</a></span></dt><dt><span class="section"><a href="#lease-affinity">10.3. Configuring Lease Affinity</a></span></dt><dt><span class="section"><a href="#lease-reclamation-defaults">10.4. Default Configuration Values for Leases Reclamation</a></span></dt><dt><span class="section"><a href="#leases-reclamation-using-command">10.5. Reclaiming Expired Leases with Command</a></span></dt></dl></div><p>The primary role of the DHCP server is to assign addresses and/or
  delegate prefixes to DHCP clients. These addresses and prefixes are
  often referred to as "leases". Leases are typically assigned to clients
  for a finite amount of time, known as the "valid lifetime". DHCP clients who
  wish to continue using their assigned leases, will periodically renew them
  by sending the appropriate message to the DHCP server. The DHCP server records
  the time when these leases are renewed and calculates new expiration times
  for them.
  </p><p>If the client does not renew a lease before its valid lifetime
  elapses, the lease is considered expired. There are many situations
  when the client may cease lease renewals.  A common scenario is when
  the machine running the client shuts down for an extended period of
  time.</p><p> The process through which the DHCP server makes expired leases
  available for reassignment is referred to as "lease reclamation" and expired
  leases returned to availability through this process are referred to as
  "reclaimed".
  The DHCP server attempts to reclaim an expired lease as soon as it detects
  that it has expired. One way in which the server detects expiration occurs
  when it is trying to allocate a lease to a client and finds this
  lease already present in the database but expired.  Another way
  is by periodically querying the lease
  database for them.  Regardless of how an expired lease is detected, before
  it may assigned to a client, it must be reclaimed.
  </p><p>
  This chapter explains how to configure the server to periodically query
  for the expired leases and how to minimize the impact of the periodic lease
  reclamation process on the server's responsiveness. Finally, it explains
  "lease affinity", which provides the means to assign the same lease to a
  returning client after its lease has expired.
  </p><p>Although, all configuration examples in this section are provided
  for the DHCPv4 server, the same parameters may be used for the
  DHCPv6 server configuration.
  </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lease-reclamation"></a>10.1. Lease Reclamation</h2></div></div></div><p>Lease reclamation is the process through which an expired lease
    becomes available for assignment to the same or different client.
    This process involves the following steps for each reclaimed lease:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">Invoke callouts for the <span class="command"><strong>lease4_expire</strong></span> or
        <span class="command"><strong>lease6_expire</strong></span> hook points if hook libraries
        supporting those callouts are currently loaded.</li><li class="listitem">Update DNS, i.e. remove any DNS entries associated with
        the expired lease.</li><li class="listitem">Update lease information in the lease database to
        indicate that the lease is now available for re-assignment.</li><li class="listitem">Update counters on the server, which includes
        increasing the number of reclaimed leases and decreasing the
        number of assigned addresses or delegated prefixes.</li></ul></div><p>Please refer to <a class="xref" href="#dhcp-ddns-server" title="Chapter 11. The DHCP-DDNS Server">Chapter 11, <i>The DHCP-DDNS Server</i></a> to see
    how to configure DNS updates in Kea, and to
    <a class="xref" href="#hooks-libraries" title="Chapter 14. Hooks Libraries">Chapter 14, <i>Hooks Libraries</i></a> for information about using
    hooks libraries.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lease-reclaim-config"></a>10.2. Configuring Lease Reclamation</h2></div></div></div><p>Kea can be configured to periodically detect and reclaim expired
    leases. During this process the lease entries in the database are
    modified or removed. While this is happening the server will not process incoming DHCP
    messages to avoid issues with concurrent access to database information.
    As a result, the server will be unresponsive while lease reclamation
    is performed and DHCP queries will accumulate; responses will be
    sent once the leases reclamation cycle is complete.</p><p>In deployments where response time is critical, administrators may
    wish to minimize the interruptions in service caused by lease reclamation.
    Toward this end, Kea provides configuration parameters to control: the
    frequency of lease reclamation cycles, the maximum number of leases
    processed in a single reclamation cycle, and the maximum amount of time a
    single reclamation cycle is allowed to run before being interrupted. The
    following examples demonstrate how these parameters can be used:

</p><pre class="screen">
"Dhcp4": {
    ...

    "expired-leases-processing": {
        "reclaim-timer-wait-time": 5,
        "max-reclaim-leases": 0,
        "max-reclaim-time": 0,
        "flush-reclaimed-timer-wait-time": 0,
    },

    ...
}
</pre><p>
    </p><p>The first parameter is expressed in seconds and specifies an
    interval between the two consecutive lease reclamation cycles. This
    is explained by the following diagram.

</p><pre class="screen">

|  c1  |            | c2 |            |c3|            | c4 |
|&lt;----&gt;|&lt;----------&gt;|&lt;--&gt;|&lt;----------&gt;|&lt;&gt;|&lt;----------&gt;|&lt;--&gt;|
----------------------------------------------------------------&gt;
|      |     5s     |    |     5s     |  |     5s     |    | time

</pre><p>

    </p><p>This diagram shows four lease reclamation cycles (c1 through c4) of variable duration.
    Note that the duration of the reclamation cycle depends on the number
    of expired leases detected and processed in the particular cycle. This
    duration is also usually significantly shorter than the interval between
    the cycles.
    </p><p>According to the <span class="command"><strong>reclaim-timer-wait-time</strong></span> the
    server keeps fixed intervals of five seconds between the end of one cycle
    and the start of the next cycle. This guarantees the presence of
    5s long periods during which the server remains responsive to DHCP
    queries and does not perform lease reclamation. The
    <span class="command"><strong>max-reclaim-leases</strong></span> and
    <span class="command"><strong>max-reclaim-time</strong></span> are set to 0, which sets
    no restriction on the maximum number of leases reclaimed
    in the particular cycle, or on the maximum duration of each cycle.
    </p><p>In deployments with high lease pool utilization, relatively
    short valid lifetimes, and frequently disconnecting clients which
    allow leases to expire, the number of expired leases requiring reclamation
    at any given time may rise significantly. In this case it is often
    desirable to apply restrictions on the maximum duration of a reclamation
    cycle or the maximum number of leases reclaimed in a cycle. The following
    configuration demonstrates how this can be done:

</p><pre class="screen">
"Dhcp4": {
    ...

    "expired-leases-processing": {
        "reclaim-timer-wait-time": 3,
        "max-reclaim-leases": 100,
        "max-reclaim-time": 50,
        "unwarned-reclaim-cycles": 10,
    },

    ...
}

</pre><p>

    </p><p>The <span class="command"><strong>max-reclaim-leases</strong></span> parameter limits the number
    of leases reclaimed in a single cycle to 100. The
    <span class="command"><strong>max-reclaim-time</strong></span> limits the maximum duration of each
    cycle to 50ms. The lease reclamation cycle will be interrupted if either
    of these limitations is reached. The reclamation of all unreclaimed
    leases will be attempted in subsequent cycles.</p><p>The following diagram illustrates the behavior of the system in the
    presence of many expired leases, when the limits are applied for the
    reclamation cycles.

</p><pre class="screen">

| c1 |                | c2 |                | c3 |                | c4 |
|&lt;--&gt;|&lt;--------------&gt;|&lt;--&gt;|&lt;--------------&gt;|&lt;--&gt;|&lt;--------------&gt;|&lt;--&gt;|&lt;--
------------------------------------------------------------------------------&gt;
|50ms|       3s       |50ms|       3s       |50ms|       3s       |50ms|  time

</pre><p>

    </p><p>The diagram demonstrates the case when each reclamation cycle would take
    more than 50ms, and thus is interrupted according to the value of the
    <span class="command"><strong>max-reclaim-time</strong></span>. This results in equal durations of
    all reclamation cycles over time. Note that in this example the limitation
    of maximum 100 leases is not reached. This may be the case when database
    transactions are slow or callouts in the hook libraries attached to
    the server are slow.  Regardless, the choosing values for either the
    maximum number of leases or a maximum cycle time strongly depends on the
    particular deployment, lease database backend being used, and any hooks
    libraries etc.  Administrators may need to experiment to tune the system
    to suit the dynamics of their deployment.</p><p>It is important to realize that with the use of these limits, there
    is a risk that expired leases will accumulate faster than the server can
    reclaim them.  This should not be the problem if the server is dealing
    with a temporary burst of expirations, because it should be able to
    eventually deal with them over time. However, if leases expire at a high
    rate for a longer period of time, the unreclaimed leases will pile up in
    the database. In order to notify the administrator that the current
    configuration does not satisfy the needs for reclamation of expired
    leases, the server issues a warning message in the log if it was unable
    to reclaim all leases within the last couple of reclamation cycles. The
    number of cycles after which such warning is issued is specified with the
    <span class="command"><strong>unwarned-reclaim-cycles</strong></span> configuration parameter.
    </p><p>Setting the <span class="command"><strong>reclaim-timer-wait-time</strong></span> to 0 disables
    periodic reclamation of the expired leases.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lease-affinity"></a>10.3. Configuring Lease Affinity</h2></div></div></div><p>Suppose that a laptop goes to a sleep mode after a period of user
    inactivity.  While the laptop is in sleep mode, its DHCP client will not
    renew leases obtained from the server and these leases will eventually
    expire.  When the laptop wakes up, it is often desirable for it to continue
    using its previous assigned IP addresses. In order to facilitate this,
    the server needs to correlate returning clients with their expired leases
    When the client returns, the server will first check for those leases and
    re-assign them if they have not been assigned to another client.  The ability
    of the server to re-assign the same lease to a returning client is
    referred to as "lease affinity".
    </p><p>When lease affinity is enabled, the server will still
    reclaim leases according to the parameters described in
    <a class="xref" href="#lease-reclaim-config" title="10.2. Configuring Lease Reclamation">Section 10.2, “Configuring Lease Reclamation”</a>, but the reclaimed leases
    will be held in the database (rather than removed) for the specified
    amount of time. When the client returns, the server will first check
    if there are any reclaimed leases associated with this client and
    re-assign them if possible. However, it is important to note that
    any reclaimed lease may be assigned to another client if that client
    specifically asks for it. Therefore, the lease affinity does not
    guarantee that the reclaimed lease will be available for the client
    who used it before; it merely increases the chances for the client to
    be assigned the same lease. If the lease pool is small (this mostly applies
    to DHCPv4 for which address space is small), there is an increased
    likelihood that the expired lease will be assigned to another client.
    </p><p>Consider the following configuration:

</p><pre class="screen">
"Dhcp4": {
    ...

    "expired-leases-processing": {
        "reclaim-timer-wait-time": 3,
        "hold-reclaimed-time": 1800,
        "flush-reclaimed-timer-wait-time": 5
    },

    ...
}
</pre><p>

    </p><p>The <span class="command"><strong>hold-reclaim-time</strong></span> specifies how many seconds
    after an expiration a reclaimed lease should be held in the database
    for re-assignment to the same client. In the example given above,
    reclaimed leases will be held for 30 minutes (1800s) after their
    expiration. During this time, the server will likely be able to
    re-assign the same lease to the returning client, unless another client
    requests this lease and the server assigns it.</p><p>The server must periodically remove reclaimed leases for which the
    time indicated by <span class="command"><strong>hold-reclaim-time</strong></span> has elapsed. The
    <span class="command"><strong>flush-reclaimed-timer-wait-time</strong></span> controls how
    often the server removes such leases. In the example provided
    above, the server will initiate removal of such leases 5 seconds after
    the previous removal attempt was completed. Setting this value to 0
    disables lease affinity, in which case leases will be removed from the
    lease database when they are reclaimed.  If lease affinity is enabled, it
    is recommended that <span class="command"><strong>hold-reclaim-time</strong></span> be set to a value significantly
    higher than the <span class="command"><strong>reclaim-timer-wait-time</strong></span>, as timely
    removal of expired-reclaimed leases is less critical while the removal
    process may impact server responsiveness.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="lease-reclamation-defaults"></a>10.4. Default Configuration Values for Leases Reclamation</h2></div></div></div><p>The following list presents all configuration parameters
    pertaining to processing expired leases with their default values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>reclaim-timer-wait-time</strong></span> = 10 [seconds]</li><li class="listitem"><span class="command"><strong>flush-reclaimed-timer-wait-time</strong></span> = 25 [seconds]</li><li class="listitem"><span class="command"><strong>hold-reclaimed-time</strong></span> = 3600 [seconds]</li><li class="listitem"><span class="command"><strong>max-reclaim-leases</strong></span> = 100 </li><li class="listitem"><span class="command"><strong>max-reclaim-time</strong></span> = 250 [milliseconds]</li><li class="listitem"><span class="command"><strong>unwarned-reclaim-cycles</strong></span> = 5</li></ul></div><p>The default value for any parameter is used when this parameter not
    explicitly specified in the configuration. Also, the
    <span class="command"><strong>expired-leases-processing</strong></span> map may be omitted entirely
    in the configuration, in which case the default values are used for all
    parameters listed above.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="leases-reclamation-using-command"></a>10.5. Reclaiming Expired Leases with Command</h2></div></div></div><p>The <span class="emphasis"><em>leases-reclaim</em></span> command can be used to trigger
    leases reclamation at any time. Please consult the
    <a class="xref" href="#command-leases-reclaim" title="16.3.6. leases-reclaim">Section 16.3.6, “leases-reclaim”</a> for the details about using this
    command.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="dhcp-ddns-server"></a>Chapter 11. The DHCP-DDNS Server</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#dhcp-ddns-overview">11.1. Overview</a></span></dt><dd><dl><dt><span class="section"><a href="#dhcp-ddns-dns-server-selection">11.1.1. DNS Server selection</a></span></dt><dt><span class="section"><a href="#dhcp-ddns-conflict-resolution">11.1.2. Conflict Resolution</a></span></dt><dt><span class="section"><a href="#dhcp-ddns-dual-stack">11.1.3. Dual Stack Environments</a></span></dt></dl></dd><dt><span class="section"><a href="#dhcp-ddns-server-start-stop">11.2. Starting and Stopping the DHCP-DDNS Server</a></span></dt><dt><span class="section"><a href="#d2-configuration">11.3. Configuring the DHCP-DDNS Server</a></span></dt><dd><dl><dt><span class="section"><a href="#d2-server-parameter-config">11.3.1. Global Server Parameters</a></span></dt><dt><span class="section"><a href="#d2-tsig-key-list-config">11.3.2. TSIG Key List</a></span></dt><dt><span class="section"><a href="#d2-forward-ddns-config">11.3.3. Forward DDNS</a></span></dt><dt><span class="section"><a href="#d2-reverse-ddns-config">11.3.4. Reverse DDNS</a></span></dt><dt><span class="section"><a href="#d2-user-contexts">11.3.5. User context in DDNS</a></span></dt><dt><span class="section"><a href="#d2-example-config">11.3.6. Example DHCP-DDNS Server Configuration</a></span></dt></dl></dd><dt><span class="section"><a href="#idp58287904">11.4. DHCP-DDNS Server Limitations</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp-ddns-overview"></a>11.1. Overview</h2></div></div></div><p>
      The DHCP-DDNS Server (kea-dhcp-ddns, known informally as D2) conducts
      the client side of the DDNS protocol (defined in  <a class="ulink" href="http://tools.ietf.org/html/rfc2136" target="_top">RFC 2136</a>)
      on behalf of the DHCPv4 and DHCPv6 servers (kea-dhcp4 and kea-dhcp6
      respectively). The DHCP servers construct DDNS update requests, known
      as NameChangeRequests (NCRs), based upon DHCP lease change events and
      then post these to D2. D2 attempts to match each such request to the
      appropriate DNS server(s) and carry out the necessary conversation with
      those servers to update the DNS data.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp-ddns-dns-server-selection"></a>11.1.1. DNS Server selection</h3></div></div></div><p>
      In order to match a request to the appropriate DNS servers, D2 must have a
      catalog of servers from which to select. In fact, D2 has two such catalogs,
      one for forward DNS and one for reverse DNS; these catalogs are referred
      to as DDNS Domain Lists.  Each list consists of one or more named DDNS
      Domains. Further, each DDNS Domain has a list of one or more DNS
      servers that publish the DNS data for that domain.
      </p><p>
      When conducting forward domain matching, D2 will compare the FQDN in
      the request against the name of each forward DDNS Domain. The domain
      whose name matches the longest portion of the FQDN is considered the
      best match.  For example, if the FQDN is "myhost.sample.example.com.",
      and there are two forward domains in the catalog: "sample.example.com."
      and "example.com.", the former is regarded as the best match.  In some
      cases, it may not be possible to find a suitable match. Given the same two
      forward domains there would be no match for the FQDN, "bogus.net", so the
      request would be rejected.   Finally, if there are no forward DDNS Domains
      defined, D2 will simply disregard the forward update portion of requests.
      </p><p>
      When conducting reverse domain matching, D2 constructs a reverse
      FQDN from the lease address in the request and compare that against
      the name of each reverse DDNS Domain. Again, the domain whose name matches
      the longest portion of the FQDN is considered the best match. For instance,
      if the lease address is "172.16.1.40" and there are two reverse domains in
      the catalog: "1.16.172.in-addr.arpa." and "16.172.in-addr.arpa", the
      former is the best match.  As with forward matching, it is possible to not
      find a suitable match.  Given the same two domains, there would be no
      match for the lease address, "192.168.1.50", and the request would be
      rejected. Finally, if there are no reverse DDNS Domains defined, D2 will
      simply disregard the reverse update portion of requests.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp-ddns-conflict-resolution"></a>11.1.2. Conflict Resolution</h3></div></div></div><p>
        D2 implements the conflict resolution strategy prescribed by
        <a class="ulink" href="http://tools.ietf.org/html/rfc4703" target="_top">RFC 4703</a>.
        Conflict resolution is intended to prevent different clients from
        mapping to the same FQDN at the same time.  To make this possible, the
        RFC requires that forward DNS entries for a given FQDN must be
        accompanied by a DHCID resource record (RR).  This record contains a
        client identifier that uniquely identifies the client to whom the name
        belongs. Furthermore, any DNS updater who wishes to update or remove
        existing forward entries for an FQDN may only do so if their client
        matches that of the DHCID RR.
        </p><p>
        In other words, the DHCID RR maps an FQDN to the client to whom it
        belongs and thereafter only changes to that mapping should only be
        done by or at the behest of that client.
        </p><p>
        Currently, conflict detection is always performed.  Future releases may
        offer alternative behavior.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="dhcp-ddns-dual-stack"></a>11.1.3. Dual Stack Environments</h3></div></div></div><p>
        <a class="ulink" href="http://tools.ietf.org/html/rfc4703#section-5.2" target="_top">RFC 4703,
        sec. 5.2,</a> describes issues that may arise with dual stack
        clients. These are clients that wish to have have both IPv4 and IPv6
        mappings for the same FQDN.  In order for this work properly, such
        clients are required to embed ther IPv6 DUID within their IPv4 client
        identifier option as described in
        <a class="ulink" href="http://tools.ietf.org/html/rfc4361" target="_top">RFC 4703</a>.
        In this way, DNS upates for both IPv4 and IPv6 can be managed under
        the same DHCID RR. Support for this does not yet exist in Kea but is
        called for in the ticket, http://kea.isc.org/ticket/4519, which we
        hope to include in a future release.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dhcp-ddns-server-start-stop"></a>11.2. Starting and Stopping the DHCP-DDNS Server</h2></div></div></div><p>
      <span class="command"><strong>kea-dhcp-ddns</strong></span> is the Kea DHCP-DDNS server
      and, due to the nature of DDNS, it is run alongside either the
      DHCPv4 or DHCPv6 components (or both).  Like other parts of
      Kea, it is a separate binary that can be run on its own or through
      <span class="command"><strong>keactrl</strong></span> (see <a class="xref" href="#keactrl" title="Chapter 6. Managing Kea with keactrl">Chapter 6, <i>Managing Kea with keactrl</i></a>). In
      normal operation, controlling <span class="command"><strong>kea-dhcp-ddns</strong></span>
      with <span class="command"><strong>keactrl</strong></span> is recommended. However, it is also
      possible to run the DHCP-DDNS server directly. It accepts the
      following command-line switches:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>-c <em class="replaceable"><code>file</code></em></strong></span> -
            specifies the configuration file. This is the only mandatory
            switch.</li><li class="listitem">
            <span class="command"><strong>-d</strong></span> - specifies whether the server
            logging should be switched to debug/verbose mode. In verbose mode,
            the logging severity and debuglevel specified in the configuration
            file are ignored and "debug" severity and the maximum debuglevel
            (99) are assumed. The flag is convenient, for temporarily
            switching the server into maximum verbosity, e.g. when
            debugging.</li><li class="listitem">
              <span class="command"><strong>-v</strong></span> - prints out Kea version and exits.
            </li><li class="listitem">
              <span class="command"><strong>-W</strong></span> - prints out the Kea configuration report
              and exits. The report is a copy of the
              <code class="filename">config.report</code> file produced by
              <strong class="userinput"><code>./configure</code></strong>: it is embedded in the
              executable binary.
            </li><li class="listitem">
            <span class="command"><strong>-t <em class="replaceable"><code>file</code></em></strong></span>
            specifies the configuration file to be tested. Kea-dhcp-ddns
            will attempt to load it, and will conduct sanity checks.
            Note that certain checks are possible only while running
            the actual server. The actual status is reported with exit
            code (0 = configuration looks ok, 1 = error encountered).
            Kea will print out log messages to standard output and error
            to standard error when testing configuration.</li></ul></div><p>
            The <code class="filename">config.report</code> may also be accessed more
            directly.  The following command may be used to extract this
            information.  The binary <strong class="userinput"><code>path</code></strong> may be found
            in the install directory or in the <code class="filename">.libs</code>
            subdirectory in the source tree. For example
            <code class="filename">kea/src/bin/d2/.libs/kea-dhcp-ddns</code>.
</p><pre class="screen">
strings <strong class="userinput"><code>path</code></strong>/kea-dhcp-ddns | sed -n 's/;;;; //p'
</pre><p>
      </p><p>
      Upon start up the module will load its configuration and begin listening
      for NCRs based on that configuration.
      </p><p>
        During startup the server will attempt to create a PID file of the
        form: [localstatedir]/[conf name].kea-dhcp-ddns.pid
        where:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>localstatedir</strong></span>: The value as passed into the
            build configure script. It defaults to "/usr/local/var".  Note
            that this value may be overridden at run time by setting the environment
            variable KEA_PIDFILE_DIR.  This is intended primarily for testing purposes.
            </li><li class="listitem"><span class="command"><strong>conf name</strong></span>: The configuration file name
            used to start the server, minus all preceding path and file extension.
            For example, given a pathname of "/usr/local/etc/kea/myconf.txt", the
            portion used would be "myconf".
            </li></ul></div><p>
        If the file already exists and contains the PID of a live process,
        the server will issue a DHCP_DDNS_ALREADY_RUNNING log message and exit. It
        is possible, though unlikely, that the file is a remnant of a system crash
        and the process to which the PID belongs is unrelated to Kea.  In such a
        case it would be necessary to manually delete the PID file.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d2-configuration"></a>11.3. Configuring the DHCP-DDNS Server</h2></div></div></div><p>
        Before starting <span class="command"><strong>kea-dhcp-ddns</strong></span> module for the
        first time, a configuration file needs to be created. The following default
        configuration is a template that can be customized to your requirements.
</p><pre class="screen">
<strong class="userinput"><code>"DhcpDdns": {
    "ip-address": "127.0.0.1",
    "port": 53001,
    "dns-server-timeout": 100,
    "ncr-protocol": "UDP",
    "ncr-format": "JSON",
    "tsig-keys": [ ],
    "forward-ddns": {
        "ddns-domains": [ ]
    },
    "reverse-ddns": {
        "ddns-domains": [ ]
    }
}</code></strong>
</pre><p>
      </p><p>
      The configuration can be divided as follows, each of which is described
      in its own section:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
        <span class="emphasis"><em>Global Server Parameters</em></span> - values which control connectivity and global server behavior
            </li><li class="listitem">
              <span class="emphasis"><em>TSIG Key Info</em></span> - defines the TSIG keys used for secure traffic with DNS servers
            </li><li class="listitem">
              <span class="emphasis"><em>Forward DDNS</em></span> - defines the catalog of Forward DDNS Domains
            </li><li class="listitem">
              <span class="emphasis"><em>Reverse DDNS</em></span> - defines the catalog of Forward DDNS Domains
            </li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-server-parameter-config"></a>11.3.1. Global Server Parameters</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <span class="command"><strong>ip-address</strong></span> - IP address on which D2
      listens for requests. The default is the local loopback interface at
      address 127.0.0.1. You may specify either an IPv4 or IPv6 address.
      </li><li class="listitem">
      <span class="command"><strong>port</strong></span> - Port on which D2 listens for requests.  The default value
      is 53001.
      </li><li class="listitem">
      <span class="command"><strong>dns-server-timeout</strong></span> - The maximum amount
      of time in milliseconds, that D2 will wait for a response from a
      DNS server to a single DNS update message.
      </li><li class="listitem">
      <span class="command"><strong>ncr-protocol</strong></span> - Socket protocol to use when sending requests to D2.
      Currently only UDP is supported.  TCP may be available in a future release.
      </li><li class="listitem">
      <span class="command"><strong>ncr-format</strong></span> - Packet format to use when sending requests to D2.
      Currently only JSON format is supported.  Other formats may be available
      in future releases.
      </li></ul></div><p>
        D2 must listen for change requests on a known address and port.  By
        default it listens at 127.0.0.1 on port 53001. The following example
        illustrates how to change D2's global parameters so it will listen
        at 192.168.1.10 port 900:
</p><pre class="screen">
"DhcpDdns": {
    <strong class="userinput"><code>"ip-address": "192.168.1.10",
    "port": 900,</code></strong>
    ...
    }
}</pre><p>
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
            It is possible for a malicious attacker to send bogus
            NameChangeRequests to the DHCP-DDNS server.  Addresses
            other than the IPv4 or IPv6 loopback addresses (127.0.0.1
            or ::1) should only be used for testing purposes, but
            note that local users may still communicate with the
            DHCP-DDNS server.  A future version of Kea will implement
            authentication to guard against such attacks.
          </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
If the ip-address and port are changed, it will be necessary to change the
corresponding values in the DHCP servers' "dhcp-ddns" configuration section.
</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-tsig-key-list-config"></a>11.3.2. TSIG Key List</h3></div></div></div><p>
        A DDNS protocol exchange can be conducted with or without TSIG
        (defined in <a class="ulink" href="http://tools.ietf/org/html/rfc2845" target="_top">RFC
        2845</a>). This configuration section allows the administrator
        to define the set of TSIG keys that may be used in such
        exchanges.</p><p>To use TSIG when updating entries in a DNS Domain,
        a key must be defined in the TSIG Key List and referenced by
        name in that domain's configuration entry.  When D2 matches a
        change request to a domain, it checks whether the domain has
        a TSIG key associated with it.  If so, D2 will use that key to
        sign DNS update messages sent to and verify responses received
        from the domain's DNS server(s). For each TSIG key required by
        the DNS servers that D2 will be working with there must be a
        corresponding TSIG key in the TSIG Key list.</p><p>
        As one might gather from the name, the tsig-key section of the
        D2 configuration lists the TSIG keys.  Each entry describes a
        TSIG key used by one or more DNS servers to authenticate requests
        and sign responses.  Every entry in the list has three parameters:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>name</strong></span> -
              a unique text label used to identify this key within the
              list.  This value is used to specify which key (if any) should be
              used when updating a specific domain. So long as it is unique its
              content is arbitrary, although for clarity and ease of maintenance
              it is recommended that it match the name used on the DNS server(s).
              It cannot be blank.
            </li><li class="listitem">
              <span class="command"><strong>algorithm</strong></span> -
              specifies which hashing algorithm should be used with this
              key.  This value must specify the same algorithm used for the
              key on the DNS server(s). The supported algorithms are listed below:
              <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><span class="command"><strong>HMAC-MD5</strong></span></li><li class="listitem"><span class="command"><strong>HMAC-SHA1</strong></span></li><li class="listitem"><span class="command"><strong>HMAC-SHA224</strong></span></li><li class="listitem"><span class="command"><strong>HMAC-SHA256</strong></span></li><li class="listitem"><span class="command"><strong>HMAC-SHA384</strong></span></li><li class="listitem"><span class="command"><strong>HMAC-SHA512</strong></span></li></ul></div>
              This value is not case sensitive.
            </li><li class="listitem">
              <span class="command"><strong>digest-bits</strong></span> -
              is used to specify the minimum truncated length in bits.
              The default value 0 means truncation is forbidden, non-zero
              values must be an integral number of octets, be greater
              than 80 and the half of the full length. Note in BIND9
              this parameter is appended after a dash to the algorithm
              name.
            </li><li class="listitem">
              <span class="command"><strong>secret</strong></span> -
              is used to specify the shared secret key code for this key.  This value is
              case sensitive and must exactly match the value specified on the DNS server(s).
              It is a base64-encoded text value.
            </li></ul></div><p>
        </p><p>
        As an example, suppose that a domain D2 will be updating is
        maintained by a BIND9 DNS server which requires dynamic updates
        to be secured with TSIG.  Suppose further that the entry for
        the TSIG key in BIND9's named.conf file looks like this:
</p><pre class="screen">
   :
   key "key.four.example.com." {
       algorithm hmac-sha224;
       secret "bZEG7Ow8OgAUPfLWV3aAUQ==";
   };
   :
</pre><p>
        By default, the TSIG Key list is empty:
</p><pre class="screen">
"DhcpDdns": {
   <strong class="userinput"><code>"tsig-keys": [ ]</code></strong>,
   ...
}
</pre><p>

        We must extend the list with a new key:
</p><pre class="screen">
"DhcpDdns": {
    "tsig-keys": [
    <strong class="userinput"><code>    {
            "name": "key.four.example.com.",
            "algorithm": "HMAC-SHA224",
            "secret": "bZEG7Ow8OgAUPfLWV3aAUQ=="
        }</code></strong>
    ],
    ...
}
</pre><p>
        </p><p>These steps would be repeated for each TSIG key needed.  Note that
        the same TSIG key can be used with more than one domain.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-forward-ddns-config"></a>11.3.3. Forward DDNS</h3></div></div></div><p>
        The Forward DDNS section is used to configure D2's forward update
        behavior. Currently it contains a single parameter, the catalog of
        forward DDNS Domains, which is a list of structures.
</p><pre class="screen">
"DhcpDdns": {
    <strong class="userinput"><code>"forward-ddns": {
        "ddns-domains": [ ]
    }</code></strong>,
    ...
}
</pre><p>

        By default, this list is empty, which will cause the server to ignore
        the forward update portions of requests.
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="add-forward-ddns-domain"></a>11.3.3.1. Adding Forward DDNS Domains</h4></div></div></div><p>
          A forward DDNS Domain maps a forward DNS zone to a set of
          DNS servers which maintain the forward DNS data (i.e. name to
          address mapping) for that zone.  You will need one forward DDNS
          Domain for each zone you wish to service.  It may very well
          be that some or all of your zones are maintained by the same
          servers. You will still need one DDNS Domain per zone. Remember
          that matching a request to the appropriate server(s) is done
          by zone and a DDNS Domain only defines a single zone.
          </p><p>
          This section describes how to add Forward DDNS Domains. Repeat these
          steps for each Forward DDNS Domain desired.  Each Forward DDNS Domain
          has the following parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>name</strong></span> -
              The fully qualified domain name (or zone) that this DDNS Domain
              can update.  This is value used to compare against the request
              FQDN during forward matching.  It must be unique within the
              catalog.
              </li><li class="listitem">
              <span class="command"><strong>key-name</strong></span> -
              If TSIG is used with this domain's servers, this
              value should be the name of the key from within the TSIG Key List
              to use.  If the value is blank (the default), TSIG will not be
              used in DDNS conversations with this domain's servers.
              </li><li class="listitem">
              <span class="command"><strong>dns-servers</strong></span> -
              A list of one or more DNS servers which can conduct the server
              side of the DDNS protocol for this domain.  The servers
              are used in a first to last preference. In other words, when D2
              begins to process a request for this domain it will pick the
              first server in this list and attempt to communicate with it.
              If that attempt fails, it will move to next one in the list and
              so on until the it achieves success or the list is exhausted.
              </li></ul></div><p>
        To create a new forward DDNS Domain, one must add a new domain
        element and set its parameters:
</p><pre class="screen">
"DhcpDdns": {
    "forward-ddns": {
        "ddns-domains": [
            <strong class="userinput"><code>{
                "name": "other.example.com.",
                "key-name": "",
                "dns-servers": [
                ]
            }</code></strong>
        ]
    }
}
</pre><p>

        It is permissible to add a domain without any servers. If that domain
        should be matched to a request, however, the request will fail.  In
        order to make the domain useful though, we must add at least one DNS
        server to it.
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="add-forward-dns-servers"></a>11.3.3.1.1. Adding Forward DNS Servers</h5></div></div></div><p>
          This section describes how to add DNS servers to a Forward DDNS Domain.
          Repeat them for as many servers as desired for a each domain.
          </p><p>
          Forward DNS Server entries represent actual DNS servers which
          support the server side of the DDNS protocol. Each Forward DNS Server
          has the following parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>hostname</strong></span> -
              The resolvable host name of the DNS server. This value is not
              yet implemented.
              </li><li class="listitem">
              <span class="command"><strong>ip-address</strong></span> -
              The IP address at which the server listens for DDNS requests.
              This may be either an IPv4 or an IPv6 address.
              </li><li class="listitem">
              <span class="command"><strong>port</strong></span> -
              The port on which the server listens for DDNS requests. It
              defaults to the standard DNS service port of 53.
              </li></ul></div><p>
          To create a new forward DNS Server, one must add a new server
          element to the domain and fill in its parameters.  If for
        example the service is running at "172.88.99.10", then set it as
        follows:
</p><pre class="screen">
"DhcpDdns": {
    "forward-ddns": {
        "ddns-domains": [
            {
                "name": "other.example.com.",
                "key-name": "",
                "dns-servers": [
                    <strong class="userinput"><code>{
                        "hostname": "",
                        "ip-address": "172.88.99.10",
                        "port": 53
                    }</code></strong>
                ]
            }
        ]
    }
}
</pre><p>
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        As stated earlier, "hostname" is not yet supported so, the parameter
        "ip-address" must be set to the address of the DNS server.
    </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-reverse-ddns-config"></a>11.3.4. Reverse DDNS</h3></div></div></div><p>
        The Reverse DDNS section is used to configure D2's reverse update
        behavior, and the concepts are the same as for the forward DDNS
        section. Currently it contains a single parameter, the catalog of
        reverse DDNS Domains, which is a list of structures.
</p><pre class="screen">
"DhcpDdns": {
    <strong class="userinput"><code>"reverse-ddns": {
        "ddns-domains": [ ]
    }</code></strong>
    ...
}
</pre><p>
        By default, this list is empty, which will cause the server to ignore
        the reverse update portions of requests.
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="add-reverse-ddns-domain"></a>11.3.4.1. Adding Reverse DDNS Domains</h4></div></div></div><p>
          A reverse DDNS Domain maps a reverse DNS zone to a set of DNS
          servers which maintain the reverse DNS data (address to name
          mapping) for that zone.  You will need one reverse DDNS Domain
          for each zone you wish to service.  It may very well be that
          some or all of your zones are maintained by the same servers;
          even then, you will still need one DDNS Domain entry for each
          zone. Remember that matching a request to the appropriate
          server(s) is done by zone and a DDNS Domain only defines a
          single zone.
          </p><p>
          This section describes how to add Reverse DDNS Domains. Repeat these
          steps for each Reverse DDNS Domain desired.  Each Reverse DDNS Domain
          has the following parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>name</strong></span> -
              The fully qualified reverse zone that this DDNS Domain
              can update.  This is the value used during reverse matching
              which will compare it with a reversed version of the request's
              lease address. The zone name should follow the appropriate
              standards: for example, to to support the IPv4 subnet 172.16.1,
              the name should be. "1.16.172.in-addr.arpa.".  Similarly,
              to support an IPv6 subnet of 2001:db8:1, the name should be
              "1.0.0.0.8.B.D.0.1.0.0.2.ip6.arpa."
              Whatever the name, it must be unique within the catalog.
              </li><li class="listitem">
              <span class="command"><strong>key-name</strong></span> -
              If TSIG should be used with this domain's servers, then this
              value should be the name of that key from the TSIG Key List.
              If the value is blank (the default), TSIG will not be
              used in DDNS conversations with this domain's servers.  Currently
              this value is not used as TSIG has not been implemented.
              </li><li class="listitem">
              <span class="command"><strong>dns-servers</strong></span> -
              a list of one or more DNS servers which can conduct the server
              side of the DDNS protocol for this domain.  Currently the servers
              are used in a first to last preference. In other words, when D2
              begins to process a request for this domain it will pick the
              first server in this list and attempt to communicate with it.
              If that attempt fails, it will move to next one in the list and
              so on until the it achieves success or the list is exhausted.
              </li></ul></div><p>
        To create a new reverse DDNS Domain, one must add a new domain element
        and set its parameters. For example, to support subnet 2001:db8:1::,
        the following configuration could be used:
</p><pre class="screen">
"DhcpDdns": {
    "reverse-ddns": {
        "ddns-domains": [
            <strong class="userinput"><code>{
                "name": "1.0.0.0.8.B.D.0.1.0.0.2.ip6.arpa.",
                "key-name": "",
                "dns-servers": [
                ]
            }</code></strong>
        ]
    }
}
</pre><p>

        It is permissible to add a domain without any servers. If that domain
        should be matched to a request, however, the request will fail.  In
        order to make the domain useful though, we must add at least one DNS
        server to it.
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="add-reverse-dns-servers"></a>11.3.4.1.1. Adding Reverse DNS Servers</h5></div></div></div><p>
          This section describes how to add DNS servers to a Reverse DDNS Domain.
          Repeat them for as many servers as desired for each domain.
          </p><p>
          Reverse DNS Server entries represents a actual DNS servers which
          support the server side of the DDNS protocol. Each Reverse DNS Server
          has the following parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>hostname</strong></span> -
              The resolvable host name of the DNS server. This value is
              currently ignored.
              </li><li class="listitem">
              <span class="command"><strong>ip-address</strong></span> -
              The IP address at which the server listens for DDNS requests.
              </li><li class="listitem">
              <span class="command"><strong>port</strong></span> -
              The port on which the server listens for DDNS requests. It
              defaults to the standard DNS service port of 53.
              </li></ul></div><p>
          To create a new reverse DNS Server, one must first add a new server
          element to the domain and fill in its parameters.  If for
        example the service is running at "172.88.99.10", then set it as
        follows:
</p><pre class="screen">
"DhcpDdns": {
    "reverse-ddns": {
        "ddns-domains": [
            {
                "name": "1.0.0.0.8.B.D.0.1.0.0.2.ip6.arpa.",
                "key-name": "",
                "dns-servers": [
                    <strong class="userinput"><code>{
                        "hostname": "",
                        "ip-address": "172.88.99.10",
                        "port": 53
                    }</code></strong>
                ]
            }
        ]
    }
}
</pre><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    As stated earlier, "hostname" is not yet supported so, the parameter
    "ip-address" must be set to the address of the DNS server.
    </p></div></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-user-contexts"></a>11.3.5. User context in DDNS</h3></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>User contexts were designed for hook libraries which
          are not yet supported for DHCP-DDNS server configuration.</p></div><p>
          User contexts can store arbitrary data as long as it is valid JSON
          syntax and its top level element is a map (i.e. the data must be
          enclosed in curly brackets).
        </p><p>
          User contexts can be specified on either global scope, ddns
          domain, dns server, tsig key and loggers. One other useful
          usage is the ability to store comments or descriptions: the
          parser translates a "comment" entry into a user-context with
          the entry, this allows to attach a comment inside the
          configuration itself.
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d2-example-config"></a>11.3.6. Example DHCP-DDNS Server Configuration</h3></div></div></div><p>
        This section provides an example DHCP-DDNS server configuration based
        on a small example network.  Let's suppose our example network has
        three domains, each with their own subnet.

        </p><div class="table"><a name="idp58244192"></a><p class="title"><b>Table 11.1. Our example network</b></p><div class="table-contents"><table summary="Our example network" border="1"><colgroup><col align="left" class="domain"><col align="left" class="subnet"><col align="left" class="fservers"><col align="left" class="rservers"></colgroup><thead><tr><th align="left">Domain</th><th align="left">Subnet</th><th align="left">Forward DNS Servers</th><th align="left">Reverse DNS Servers</th></tr></thead><tbody><tr><td align="left">four.example.com</td><td align="left">192.0.2.0/24</td><td align="left">172.16.1.5, 172.16.2.5</td><td align="left">172.16.1.5, 172.16.2.5</td></tr><tr><td align="left">six.example.com</td><td align="left">2001:db8:1::/64</td><td align="left">3001:1::50</td><td align="left">3001:1::51</td></tr><tr><td align="left">example.com</td><td align="left">192.0.0.0/16</td><td align="left">172.16.2.5</td><td align="left">172.16.2.5</td></tr></tbody></table></div></div><p><br class="table-break">
        </p><p>
        We need to construct three forward DDNS Domains:
        </p><div class="table"><a name="idp58258912"></a><p class="title"><b>Table 11.2. Forward DDNS Domains Needed</b></p><div class="table-contents"><table summary="Forward DDNS Domains Needed" border="1"><colgroup><col align="left" class="num"><col align="left" class="name"><col align="left" class="servers"></colgroup><thead><tr><th align="left">#</th><th align="left">DDNS Domain Name</th><th align="left">DNS Servers</th></tr></thead><tbody><tr><td align="left">1.</td><td align="left">four.example.com.</td><td align="left">172.16.1.5, 172.16.2.5</td></tr><tr><td align="left">2.</td><td align="left">six.example.com.</td><td align="left">3001:1::50</td></tr><tr><td align="left">3.</td><td align="left">example.com.</td><td align="left">172.16.2.5</td></tr></tbody></table></div></div><p><br class="table-break">
        As discussed earlier, FQDN to domain matching is based on the longest
        match. The FQDN, "myhost.four.example.com.", will match the first
        domain ("four.example.com") while "admin.example.com." will match the
        third domain ("example.com"). The
        FQDN, "other.example.net." will fail to match any domain and would
        be rejected.
        </p><p>
        The following example configuration specified the Forward DDNS Domains.
</p><pre class="screen"><strong class="userinput"><code>
"DhcpDdns": {
    "comment": "example configuration: forward part",
    "forward-ddns": {
        "ddns-domains": [
            {
                "name": "four.example.com.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "172.16.1.5" },
                    { "ip-address": "172.16.2.5" }
                ]
            },
            {
                "name": "six.example.com.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "2001:db8::1" }
                ]
            },
            {
                "name": "example.com.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "172.16.2.5" }
                ],
                "user-context": { "backup": false }
            },

        ]
    }
}</code></strong>
</pre><p>

        </p><p>
        Similarly, we need to construct the three reverse DDNS Domains:
        </p><div class="table"><a name="idp58273360"></a><p class="title"><b>Table 11.3. Reverse DDNS Domains Needed</b></p><div class="table-contents"><table summary="Reverse DDNS Domains Needed" border="1"><colgroup><col align="left" class="num"><col align="left" class="DDNS Domain name"><col align="left" class="DDNS Domain DNS Servers"></colgroup><thead><tr><th align="left">#</th><th align="left">DDNS Domain Name</th><th align="left">DNS Servers</th></tr></thead><tbody><tr><td align="left">1.</td><td align="left">2.0.192.in-addr.arpa.</td><td align="left">172.16.1.5, 172.16.2.5</td></tr><tr><td align="left">2.</td><td align="left">1.0.0.0.8.d.b.0.1.0.0.2.ip6.arpa.</td><td align="left">3001:1::50</td></tr><tr><td align="left">3.</td><td align="left">0.182.in-addr.arpa.</td><td align="left">172.16.2.5</td></tr></tbody></table></div></div><p><br class="table-break">
        An address of "192.0.2.150" will match the first domain,
        "2001:db8:1::10" will match the second domain, and "192.0.50.77"
        the third domain.
        </p><p>
        These Reverse DDNS Domains are specified as follows:

</p><pre class="screen"><strong class="userinput"><code>
"DhcpDdns": {
    "comment": "example configuration: reverse part",
    "reverse-ddns": {
        "ddns-domains": [
            {
                "name": "2.0.192.in-addr.arpa.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "172.16.1.5" },
                    { "ip-address": "172.16.2.5" }
                ]
            }
            {
                "name": "1.0.0.0.8.B.D.0.1.0.0.2.ip6.arpa.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "2001:db8::1" }
                ]
            }
            {
                "name": "0.192.in-addr.arpa.",
                "key-name": "",
                "dns-servers": [
                    { "ip-address": "172.16.2.5" }
                ]
            }
        ]
    }
}</code></strong>
</pre><p>

        </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58287904"></a>11.4. DHCP-DDNS Server Limitations</h2></div></div></div><p>The following are the current limitations of the DHCP-DDNS Server.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            Requests received from the DHCP servers are placed in a
            queue until they are processed.  Currently all queued requests
            are lost when the server shuts down.
          </li></ul></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="kea-lfc"></a>Chapter 12. The LFC process</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#kea-lfc-overview">12.1. Overview</a></span></dt><dt><span class="section"><a href="#kea-lfc-usage">12.2. Command Line Options</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kea-lfc-overview"></a>12.1. Overview</h2></div></div></div><p><span class="command"><strong>kea-lfc</strong></span> is a service process that removes
      redundant information from the files used to provide persistent storage
      for the memfile data base backend. This service is written to run as a
      stand alone process.  
      </p><p>While <span class="command"><strong>kea-lfc</strong></span> can be started externally, there is
      usually no need to do this.  <span class="command"><strong>kea-lfc</strong></span> is run on a periodic
      basis by the Kea DHCP servers.
      </p><p>The process operates on a set of files, using them for input and output
      of the lease entries and to indicate where it is in the process in case of an
      interruption.  Currently the caller must supply names for all of the files, in
      the future this requirement may be relaxed with the process getting the names
      from either the configuration file or from defaults.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="kea-lfc-usage"></a>12.2. Command Line Options</h2></div></div></div><p><span class="command"><strong>kea-lfc</strong></span> is run as follows:
</p><pre class="screen">
kea-lfc [-4 | -6] -c config-file -p pid-file -x previous-file -i copy-file -o output-file -f finish-file
</pre><p>
      </p><p>The argument <span class="command"><strong>-4</strong></span> or <span class="command"><strong>-6</strong></span> selects the protocol
      version of the lease files.
      </p><p>The <span class="command"><strong>-c</strong></span> argument specifies the configuration file.  This is
      required, but not currently used by the process.
      </p><p>The <span class="command"><strong>-p</strong></span> argument specifies the PID file. When the
      <span class="command"><strong>kea-lfc</strong></span> process starts it attempts to determine if another
      instance of the process is already running by examining the pid file.  If one
      is already running the new process is terminated.  If one isn't running it writes
      its pid into the pid file.
      </p><p>The other filenames specify where the <span class="command"><strong>kea-lfc</strong></span> process
      should look for input, write its output and use for bookkeeping.

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
            <span class="command"><strong>previous</strong></span> —
            When <span class="command"><strong>kea-lfc</strong></span> starts this
            is the result of any previous run of <span class="command"><strong>kea-lfc</strong></span>.
            When <span class="command"><strong>kea-lfc</strong></span> finishes it is the result of this run.
            If <span class="command"><strong>kea-lfc</strong></span> is interrupted before completing,
            this file may not exist.
          </li><li class="listitem">
            <span class="command"><strong>input</strong></span> —
            Before the DHCP server invokes <span class="command"><strong>kea-lfc</strong></span> it will
            move the current lease file here and then call <span class="command"><strong>kea-lfc</strong></span>
            with this file.
          </li><li class="listitem">
            <span class="command"><strong>output</strong></span> —
            The temporary file <span class="command"><strong>kea-lfc</strong></span> should use to write the leases.
            Upon completion of writing this file, it will be moved to the finish file
           (see below).
          </li><li class="listitem">
            <span class="command"><strong>finish</strong></span> —
            Another temporary file <span class="command"><strong>kea-lfc</strong></span> uses for bookkeeping.  When
            <span class="command"><strong>kea-lfc</strong></span> completes writing the outputfile it moves it to this
            file name.  After <span class="command"><strong>kea-lfc</strong></span> finishes deleting the other files
            (previous and input) it moves this file to previous lease file.  By moving the
            files in this fashion the <span class="command"><strong>kea-lfc</strong></span> and the DHCP server
            processes can determine the correct file to use even if one of the
            processes was interrupted before completing its task.
          </li></ul></div><p>
      </p><p>There are several additional arguments mostly for debugging purposes.
      <span class="command"><strong>-d</strong></span> Sets the logging level to debug. <span class="command"><strong>-v</strong></span> and
      <span class="command"><strong>-V</strong></span> print out version stamps with <span class="command"><strong>-V</strong></span> providing
      a longer form.  <span class="command"><strong>-h</strong></span> prints out the usage string.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="classify"></a>Chapter 13. Client Classification</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idp58319600">13.1. Client Classification Overview</a></span></dt><dt><span class="section"><a href="#classification-using-vendor">13.2. Builtin Client Classes</a></span></dt><dt><span class="section"><a href="#classification-using-expressions">13.3. Using Expressions In Classification</a></span></dt><dd><dl><dt><span class="section"><a href="#idp58483488">13.3.1. Logical operators</a></span></dt><dt><span class="section"><a href="#idp58484640">13.3.2. Substring</a></span></dt><dt><span class="section"><a href="#idp58486976">13.3.3. Concat</a></span></dt><dt><span class="section"><a href="#idp58488448">13.3.4. Ifelse</a></span></dt></dl></dd><dt><span class="section"><a href="#classification-configuring">13.4. Configuring Classes</a></span></dt><dt><span class="section"><a href="#classification-using-host-reservations">13.5. Using Static Host Reservations In Classification</a></span></dt><dt><span class="section"><a href="#classification-subnets">13.6. Configuring Subnets With Class Information</a></span></dt><dt><span class="section"><a href="#classification-pools">13.7. Configuring Pools With Class Information</a></span></dt><dt><span class="section"><a href="#idp58518848">13.8. Using Classes</a></span></dt><dt><span class="section"><a href="#idp58520912">13.9. Classes and Hooks</a></span></dt><dt><span class="section"><a href="#idp58524544">13.10. Debugging Expressions</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58319600"></a>13.1. Client Classification Overview</h2></div></div></div><p>
      In certain cases it is useful to differentiate between different
      types of clients and treat them accordingly. Common reasons include:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      The clients represent different pieces of topology, e.g. a cable
      modem is different to the clients behind that modem.
      </p></li><li class="listitem"><p>
      The clients have different behavior, e.g. a smart phone behaves
      differently to a laptop.
      </p></li><li class="listitem"><p>
      The clients require different values for some options, e.g. a docsis3.0
      cable modem requires different settings to docsis2.0 cable modem.
      </p></li></ul></div><p>
      </p><p>
      Conversely, different clients can be grouped into a client class to get a
      common option.
      </p><p>
      An incoming packet can be associated with a client class in
      serveral ways:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      Implicitly, using a vendor class option or another builtin condition.
      </p></li><li class="listitem"><p>
      Using an expression which evaluates to true.
      </p></li><li class="listitem"><p>
      Using static host reservations, a shared network, a subnet, etc.
      </p></li><li class="listitem"><p>
      Using a hook.
      </p></li></ul></div><p>
      </p><p>
      It is envisaged that client classification will be used for
      changing the behavior of almost any part of the DHCP message
      processing. In the current release of the software however,
      there are only five mechanisms that take advantage of
      client classification: subnet selection, pool selection,
      definition of DHCPv4 private (codes 224-254) and code 43
      options, assignment of different options and, for DHCPv4 cable
      modems, the setting of specific options for use with the TFTP
      server address and the boot file field.
      </p><p>
      The process of doing classification is conducted in several steps:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      The ALL class is associated with the incoming packet.
      </p></li><li class="listitem"><p>
      Vendor class options are processed.
      </p></li><li class="listitem"><p>
      Classes with matching expressions and not marked for later ("on
      request" or depending on the KNOWN builtin class) evaluation are
      processed in the order they are defined in the configuration:
      the boolean expression is evaluated and when it returns true
      ("match") the incoming packet is associated to the class.
      </p></li><li class="listitem"><p>
      If a private or code 43 DHCPv4 option is received, decoding it
      following its client class or global (or for option 43 last
      resort) definition.
      </p></li><li class="listitem"><p>
      Choose a subnet, possibly based on the class information when
      some subnets are guarded. More precisely: when choosing a subnet,
      the server will iterate over all of the subnets that are
      feasible given the information found in the packet (client
      address, relay address etc). It will use the first subnet it
      finds that either doesn't have a class associated with it or
      that has a class which matches one of the packet's classes.
      </p></li><li class="listitem"><p>
      Host reservations are looked for. If an identifier from the incoming
      packet matches a host reservation in the subnet or shared network,
      the packet is associated with the KNOWN builtin class and all classes
      of the host reservation.
      </p></li><li class="listitem"><p>
      Classes with matching expressions using directly or indirectly
      the KNOWN builtin class and not marked for later ("on request")
      evaluation are processed in the order they are defined in the
      configuration: the boolean expression is evaluated and when it
      returns true ("match") the incoming packet is associated to the
      class.
      </p></li><li class="listitem"><p>
      If needed, addresses and prefixes from pools are assigned,
      possibly based on the class information when some pools are
      reserved to class members.
      </p></li><li class="listitem"><p>
      Evaluate classes marked as "required" in the order in which they
      are listed as required: first shared network, then the subnet
      and to finally pools assigned resources belong too.
      </p></li><li class="listitem"><p>
      Assign options, again possibly based on the class information
      in order classes were associated with the incoming packet.
      For DHCPv4 private and code 43 options this includes class local
      option definitions.
      </p></li></ol></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      Beginning with Kea 1.4.0 release,  client classes follow the order
      in which they are specified in the configuration
      (vs. alphabetical order in previous releases). Required classes
      follow the order in which they are required.
      </p></div><p>
      When determining which options to include in the response, the
      server will examine the union of options from all of the
      assigned classes. In case when two or more classes include the
      same option, the value from the first class examined will be
      used, and classes are examined in the order they were associated
      so ALL is always the first class and matching required classes
      are last.
      </p><p>
      As an example, imagine that an incoming packet matches two
      classes.  Class "foo" defines values for an NTP server (option
      42 in DHCPv4) and an SMTP server (option 69 in DHCPv4) while
      class "bar" defines values for an NTP server and a POP3 server
      (option 70 in DHCPv4).  The server will examine the three
      options NTP, SMTP and POP3 and return any of them that the
      client requested.  As the NTP server was defined twice the
      server will choose only one of the values for the reply: the
      class from which the value is obtained is unspecified.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        Care should be taken with client classification as it is easy for
        clients that do not meet class criteria to be denied any service altogether.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-using-vendor"></a>13.2. Builtin Client Classes</h2></div></div></div><p>
      Some classes are builtin so do not need to be defined. The main
      example uses Vendor Class information: The server checks whether
      an incoming DHCPv4 packet includes the vendor class identifier
      option (60) or an incoming DHCPv6 packet includes the vendor
      class option (16). If it does, the content of that option is
      prepended with "VENDOR_CLASS_" and the result is
      interpreted as a class. For example, modern cable modems will
      send this option with value "docsis3.0" and so the
      packet will belong to class "VENDOR_CLASS_docsis3.0".
      </p><p>Other examples are: the  ALL class which all incoming packets
      belong to, and the KNOWN class assigned when host reservations exist
      for the particular client. By convention, builtin classes' names
      begin with all capital letters.
      </p><p>Currently recognized builtin class names are ALL and KNOWN
      and prefixes VENDOR_CLASS_, AFTER_ and EXTERNAL_. The AFTER_ prefix
      is a provision for a not yet written hook, the EXTERNAL_ prefix
      can be freely used: builtin classes are implicitly defined so
      never raise warnings if they do not appear in the configuration.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-using-expressions"></a>13.3. Using Expressions In Classification</h2></div></div></div><p>
      The expression portion of classification contains operators and
      values.  All values are currently strings and operators take a
      string or strings and return another string. When all the
      operations have completed the result should be a value of
      "true" or "false".  The packet belongs to
      the class (and the class name is added to the list of classes)
      if the result is "true". Expressions are written in
      standard format and can be nested.
      </p><p>
      Expressions are pre-processed during the parsing of the
      configuration file and converted to an internal
      representation. This allows certain types of errors to be caught
      and logged during parsing.  Examples of these errors include an
      incorrect number or types of arguments to an operator.  The
      evaluation code will also check for this class of error and
      generally throw an exception, though this should not occur in a
      normally functioning system.
      </p><p>
      Other issues, for example the starting position of a substring being
      outside of the substring or an option not existing in the packet, result
      in the operator returning an empty string.
      </p><p>
      Expressions are a work in progress and the supported operators and
      values are limited. The expectation is that additional operators and values
      will be added over time, however the basic mechanisms will
      remain the same.
      </p><p>
      Dependencies between classes are checked too: for instance forward
      dependencies are rejected when the configuration is parsed:
      an expression can only depend on already defined classes (including
      builtin classes) and which are evaluated in a previous or the
      same evaluation phase. This does not apply to the KNOWN class.
      </p><p>
        </p><div class="table"><a name="classification-values-list"></a><p class="title"><b>Table 13.1. List of Classification Values</b></p><div class="table-contents"><table summary="List of Classification Values" border="1"><colgroup><col class="name"><col class="example"><col class="description"></colgroup><thead><tr><th>Name</th><th>Example expression</th><th>Example value</th><th>Description</th></tr></thead><tbody><tr><td>String literal</td><td>'example'</td><td>'example'</td><td>A string</td></tr><tr><td>Hexadecimal string literal</td><td>0x5a7d</td><td>'Z}'</td><td>A hexadecimal string</td></tr><tr><td>IP address literal</td><td>10.0.0.1</td><td>0x0a000001</td><td>An IP address</td></tr><tr><td>Integer literal</td><td>123</td><td>'123'</td><td>A 32 bit unsigned integer value</td></tr><tr></tr><tr><td>Binary content of the option</td><td>option[123].hex</td><td>'(content of the option)'</td><td>The value of the option with given code from the
              packet as hex</td></tr><tr><td>Option existence</td><td>option[123].exists</td><td>'true'</td><td>If the option with given code is present in the
              packet "true" else "false"</td></tr><tr><td>Client class membership</td><td>member('foobar')</td><td>'true'</td><td>If the packet belongs to the given client class
              "true" else "false"</td></tr><tr><td>Known client</td><td>known</td><td>member('KNOWN')</td><td>If there is a host reservation for the client
              "true" else "false"</td></tr><tr><td>Unknown client</td><td>unknown</td><td>not member('KNOWN')</td><td>If there is a hostreservation for the client
              "false" else "true"</td></tr><tr><td>DHCPv4 relay agent sub-option</td><td>relay4[123].hex</td><td>'(content of the RAI sub-option)'</td><td>The value of sub-option with given code from the
              DHCPv4 Relay Agent Information option (option 82)</td></tr><tr><td>DHCPv6 Relay Options</td><td>relay6[nest].option[code].hex</td><td>(value of the option)</td><td>The value of the option with code "code" from the
              relay encapsulation "nest"</td></tr><tr><td>DHCPv6 Relay Peer Address</td><td>relay6[nest].peeraddr</td><td>2001:DB8::1</td><td>The value of the peer address field from the
              relay encapsulation "nest"</td></tr><tr><td>DHCPv6 Relay Link Address</td><td>relay6[nest].linkaddr</td><td>2001:DB8::1</td><td>The value of the link address field from the
              relay encapsulation "nest"</td></tr><tr><td>Interface name of packet</td><td>pkt.iface</td><td>eth0</td><td>The name of the incoming interface of a DHCP packet.</td></tr><tr><td>Source address of packet</td><td>pkt.src</td><td>10.1.2.3</td><td>The IP source address of a DHCP packet.</td></tr><tr><td>Destination address of packet</td><td>pkt.dst</td><td>10.1.2.3</td><td>The IP destination address of a DHCP packet.</td></tr><tr><td>Length of packet</td><td>pkt.len</td><td>513</td><td>The length of a DHCP packet (UDP header field), expressed
              as a 32 bit unsigned integer.</td></tr><tr><td>Hardware address in DHCPv4 packet</td><td>pkt4.mac</td><td>0x010203040506</td><td>The value of the chaddr field of the DHCPv4 packet, hlen (0 to 16) bytes</td></tr><tr><td>Hardware length in DHCPv4 packet</td><td>pkt4.hlen</td><td>6</td><td>The value of the hlen field of the DHCPv4 packet padded to 4 bytes</td></tr><tr><td>Hardware type in DHCPv4 packet</td><td>pkt4.htype</td><td>6</td><td>The value of the htype field of the DHCPv4 packet padded to 4 bytes</td></tr><tr><td>ciaddr field in DHCPv4 packet</td><td>pkt4.ciaddr</td><td>192.0.2.1</td><td>The value of the ciaddr field of the DHCPv4 packet (IPv4 address, 4 bytes)</td></tr><tr><td>giaddr field in DHCPv4 packet</td><td>pkt4.giaddr</td><td>192.0.2.1</td><td>The value of the giaddr field of the DHCPv4 packet (IPv4 address, 4 bytes)</td></tr><tr><td>yiaddr field in DHCPv4 packet</td><td>pkt4.yiaddr</td><td>192.0.2.1</td><td>The value of the yiaddr field of the DHCPv4 packet (IPv4 address, 4 bytes)</td></tr><tr><td>siaddr field in DHCPv4 packet</td><td>pkt4.siaddr</td><td>192.0.2.1</td><td>The value of the siaddr field of the DHCPv4 packet (IPv4 address, 4 bytes)</td></tr><tr><td>Message Type in DHCPv4 packet</td><td>pkt4.msgtype</td><td>1</td><td>The value of the message type field in the DHCPv4
              packet (expressed as a 32 bit unsigned integer).</td></tr><tr><td>Transaction ID (xid) in DHCPv4 packet</td><td>pkt4.transid</td><td>12345</td><td>The value of the transaction id in the DHCPv4
              packet (expressed as a 32 bit unsigned integer).</td></tr><tr><td>Message Type in DHCPv6 packet</td><td>pkt6.msgtype</td><td>1</td><td>The value of the message type field in the DHCPv6
              packet (expressed as a 32 bit unsigned integer).</td></tr><tr><td>Transaction ID in DHCPv6 packet</td><td>pkt6.transid</td><td>12345</td><td>The value of the transaction id in the DHCPv6
              packet (expressed as a 32 bit unsigned integer).</td></tr><tr><td>Vendor option existence (any vendor)</td><td>vendor[*].exists</td><td>true</td><td>Returns whether a vendor option from any vendor
              is present ('true') or absent ('false').</td></tr><tr><td>Vendor option existence (specific vendor)</td><td>vendor[4491].exists</td><td>true</td><td>Returns whether a vendor option from specified
              vendor (determined by its enterprise-id)
              is present ('true') or absent ('false').</td></tr><tr><td>Enterprise-id from vendor option</td><td>vendor.enterprise</td><td>4491</td><td>If the vendor option is present, it returns the
              value of the enterprise-id field padded to 4
              bytes. Returns "" otherwise.</td></tr><tr><td>Vendor sub-option existence</td><td>vendor[4491].option[1].exists</td><td>true</td><td>Returns 'true' if there is vendor option with
              specified enterprise-id and given sub-option is present.
              Returns 'false' otherwise.</td></tr><tr><td>Vendor sub-option content</td><td>vendor[4491].option[1].hex</td><td>docsis3.0</td><td>Returns content of the specified sub-option of
              a vendor option with specified enterprise id. Returns
              '' if no such option or sub-option is present.
              </td></tr><tr><td>Vendor class option existence (any vendor)</td><td>vendor-class[*].exists</td><td>true</td><td>Returns whether a vendor class option from any vendor
              is present ('true') or absent ('false').</td></tr><tr><td>Vendor class option existence (specific vendor)</td><td>vendor-class[4491].exists</td><td>true</td><td>Returns whether a vendor class option from specified
              vendor (determined by its enterprise-id)
              is present ('true') or absent ('false').</td></tr><tr><td>Enterprise-id from vendor class option</td><td>vendor-class.enterprise</td><td>4491</td><td>If the vendor option is present, it returns the
              value of the enterprise-id field padded to 4
              bytes. Returns "" otherwise.</td></tr><tr><td>First data chunk from vendor class option</td><td>vendor-class[4491].data</td><td>docsis3.0</td><td>Returns content of the first data chunk from
              the vendor class option with specified enterprise-id.
              Returns "" if missing.</td></tr><tr><td>Specific data chunk from vendor class option</td><td>vendor-class[4491].data[3]</td><td>docsis3.0</td><td>Returns content of the specified data chunk of
              a vendor class option with specified enterprise id. Returns
              '' if no such option or data chunk is present.
              </td></tr></tbody></table></div></div><p><br class="table-break">
        Notes:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      Hexadecimal strings are converted into a string as expected.  The starting "0X" or
      "0x" is removed and if the string is an odd number of characters a
      "0" is prepended to it.
      </p></li><li class="listitem"><p>
      IP addresses are converted into strings of length 4 or 16. IPv4, IPv6,
      and IPv4 embedded IPv6 (e.g., IPv4 mapped IPv6) addresses are supported.
      </p></li><li class="listitem"><p>
      Integers in an expression are converted to 32 bit unsigned integers and
      are represented as four-byte strings. For example 123 is represented as
      0x0000007b. All expressions that return numeric values use 32-bit
      unsigned integers, even if the field in the packet is smaller.  In general
      it is easier to use decimal notation to represent integers, but it is also
      possible to use hex notation. When using hex notation to represent an
      integer care should be taken to make sure the value is represented as 32
      bits, e.g. use 0x00000001 instead of 0x1 or 0x01. Also, make
      sure the value is specified in network order, e.g. 1 is
      represented as 0x00000001.
      </p></li><li class="listitem"><p>
      "option[code].hex" extracts the value of the option with the code "code"
      from the incoming packet. If the packet doesn't contain the option, it
      returns the empty string. The string is presented as a byte string of
      the option payload without the type code or length fields.
      </p></li><li class="listitem"><p>
      "option[code].exists" checks if an option with the code "code" is present
      in the incoming packet. It can be used with empty options.
      </p></li><li class="listitem"><p>
      "member('foobar')" checks if the packet belongs to the client
      class "foobar". To avoid dependency loops the configuration file
      parser checks if client classes were already defined or are
      built-in, i.e., beginning by "VENDOR_CLASS_",
      "AFTER__" (for the to come "after" hook) and
      "EXTERNAL_" or equal to "ALL", "KNOWN",
      etc.
      </p><p>"known" and "unknown" are short hands for "member('KNOWN')" and
      "not member('KNOWN')". Note the evaluation of any expression using
      directly or indirectly the "KNOWN" class is deferred
      after the host reservation lookup (i.e. when the "KNOWN"
      belonging is determined).
      </p></li><li class="listitem"><p>
      "relay4[code].hex" attempts to extract the value of the sub-option
      "code" from the option inserted as the DHCPv4 Relay Agent Information
      (82) option. If the packet doesn't contain a RAI option, or the RAI
      option doesn't contain the requested sub-option, the expression returns
      an empty string. The string is presented as a byte string of the
      option payload without the type code or length fields. This
      expression is allowed in DHCPv4 only.
      </p></li><li class="listitem"><p>
      "relay4" shares the same representation types as "option", for
      instance "relay4[code].exists" is supported.
      </p></li><li class="listitem"><p>
      "relay6[nest]" allows access to the encapsulations used by any DHCPv6
      relays that forwarded the packet.  The "nest" level specifies the relay
      from which to extract the information, with a value of 0 indicating
      the relay closest to the DHCPv6 server. Negative values allow to
      specify relays counted from the DHCPv6 client, -1 indicating the
      relay closest to the client. In general negative "nest" level is
      the same as the number of relays + "nest" level.
      If the requested encapsulation doesn't exist an empty string ""
      is returned.  This expression is allowed in DHCPv6 only.
      </p></li><li class="listitem"><p>
      "relay6[nest].option[code]" shares the same representation types as
      "option", for instance "relay6[nest].option[code].exists" is supported.
      </p></li><li class="listitem"><p>
       Expressions starting with "pkt4" can be used only in DHCPv4.
       They allows access to DHCPv4 message fields.
      </p></li><li class="listitem"><p>
      "pkt6" refers to information from the client request.  To access any
      information from an intermediate relay use "relay6".  "pkt6.msgtype"
      and "pkt6.transid" output a 4 byte binary string for the message type
      or transaction id.  For example the message type SOLICIT will be
      "0x00000001" or simply 1 as in "pkt6.msgtype == 1".
      </p></li><li class="listitem"><p>
      Vendor option means Vendor-Identifying Vendor-specific Information
      option in DHCPv4 (code 125, see
      <a class="ulink" href="http://tools.ietf.org/html/rfc3925#section-4" target="_top">Section 4 of RFC 3925</a>) and
      Vendor-specific Information Option in DHCPv6 (code 17, defined in
      <a class="ulink" href="https://tools.ietf.org/html/rfc3315#section-22.17" target="_top">Section 22.17 of
      RFC 3315</a>). Vendor class option means Vendor-Identifying Vendor
      Class Option in DHCPv4 (code 124, see
      <a class="ulink" href="http://tools.ietf.org/html/rfc3925#section-3" target="_top">Section 3 of RFC 3925</a>) in DHCPv4 and
      Class Option in DHCPv6 (code 16, see
      <a class="ulink" href="https://tools.ietf.org/html/rfc3315#section-22.16" target="_top">Section 22.16 of RFC 3315</a>).
      Vendor options may
      have sub-options that are referenced by their codes. Vendor class
      options do not have sub-options, but rather data chunks, which are
      referenced by index value. Index 0 means the first data chunk, Index 1
      is for the second data chunk (if present), etc.
      </p></li><li class="listitem"><p>
      In the vendor and vendor-class constructs Asterisk (*) or 0 can be
      used to specify a wildcard enterprise-id value, i.e. it will match any
      enterprise-id value.
      </p></li><li class="listitem"><p>Vendor Class Identifier (option 60 in DHCPv4) can be
      accessed using option[60] expression.</p></li><li class="listitem"><p>
      <a class="ulink" href="http://tools.ietf.org/html/rfc3925" target="_top">RFC3925</a> and
      <a class="ulink" href="http://tools.ietf.org/html/rfc3315" target="_top">RFC3315</a>
      allow for multiple instances of vendor options
      to appear in a single message. The client classification code currently
      examines the first instance if more than one appear. For vendor.enterprise
      and vendor-class.enterprise expressions, the value from the first instance
      is returned. Please submit a feature request on Kea website if you need
      support for multiple instances.
      </p></li></ul></div><p>
        </p><div class="table"><a name="classification-expressions-list"></a><p class="title"><b>Table 13.2. List of Classification Expressions</b></p><div class="table-contents"><table summary="List of Classification Expressions" border="1"><colgroup><col class="name"><col class="example"><col class="description"></colgroup><thead><tr><th>Name</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>Equal</td><td>'foo' == 'bar'</td><td>Compare the two values and return "true" or "false"</td></tr><tr><td>Not</td><td>not ('foo' == 'bar')</td><td>Logical negation</td></tr><tr><td>And</td><td>('foo' == 'bar') and ('bar' == 'foo')</td><td>Logical and</td></tr><tr><td>Or</td><td>('foo' == 'bar') or ('bar' == 'foo')</td><td>Logical or</td></tr><tr><td>Substring</td><td>substring('foobar',0,3)</td><td>Return the requested substring</td></tr><tr><td>Concat</td><td>concat('foo','bar')</td><td>Return the
concatenation of the strings</td></tr><tr><td>Ifelse</td><td>ifelse('foo' == 'bar','us','them')</td><td>Return the branch value according to the condition</td></tr></tbody></table></div></div><p><br class="table-break">
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58483488"></a>13.3.1. Logical operators</h3></div></div></div>
        The Not, And and Or logical operators are the common operators. Not
        has the highest precedence and Or the lowest. And and Or are (left)
        associative, parentheses around a logical expression can be used
        to enforce a specific grouping, for instance in "A and (B or C)"
        (without parentheses "A and B or C" means "(A and B) or C").
      </div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58484640"></a>13.3.2. Substring</h3></div></div></div>
        The substring operator "substring(value, start, length)" accepts both positive and
        negative values for the starting position and the length.  For "start", a value of
        0 is the first byte in the string while -1 is the last byte.  If the starting
        point is outside of the original string an empty string is returned.  "length"
        is the number of bytes to extract.  A negative number means to count towards
        the beginning of the string but doesn't include the byte pointed to by "start".
        The special value "all" means to return all bytes from start to the end of the
        string.  If length is longer than the remaining portion of the string then
        the entire remaining portion is returned.  Some examples may be helpful:

          <pre class="screen">
        substring('foobar', 0, 6) == 'foobar'
        substring('foobar', 3, 3) == 'bar'
        substring('foobar', 3, all) == 'bar'
        substring('foobar', 1, 4) == 'ooba'
        substring('foobar', -5, 4) == 'ooba'
        substring('foobar', -1, -3) == 'oba'
        substring('foobar', 4, -2) == 'ob'
        substring('foobar', 10, 2) == ''
          </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58486976"></a>13.3.3. Concat</h3></div></div></div>
        The concat function "concat(string1, string2)" returns the
        concatenation of its two arguments. For instance:
          <pre class="screen">
        concat('foo', 'bar') == 'foobar'
          </pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58488448"></a>13.3.4. Ifelse</h3></div></div></div>
         The ifelse function "ifelse(cond, iftrue, ifelse)" returns the
         "iftrue" or "ifelse" branch value following the boolean
         condition "cond". For instance:
           <pre class="screen">
         ifelse(option[230].exists, option[230].hex, 'none')
           </pre></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    The expression for each class is executed on each packet received.
    If the expressions are overly complex, the time taken to execute
    them may impact the performance of the server. If you need
    complex or time consuming expressions you should write a <a class="link" href="#hooks-libraries" title="Chapter 14. Hooks Libraries">hook</a> to perform the necessary work.
  </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-configuring"></a>13.4. Configuring Classes</h2></div></div></div><p>
      A class contains five items: a name, a test expression, option data,
      option definition and only-if-required flag.
      The name must exist and must be unique amongst all classes. The test
      expression, option data and definition, and only-if-required flag are
      optional.
      </p><p>
      The test expression is a string containing the logical expression used to
      determine membership in the class.  The entire expression is in double
      quotes.
      </p><p>
      The option data is a list which defines any options that should be assigned
      to members of this class.
      </p><p>
      The option definition is for DHCPv4 option 43 (<a class="xref" href="#dhcp4-vendor-opts" title="8.2.11. DHCPv4 Vendor Specific Options">Section 8.2.11, “DHCPv4 Vendor Specific Options”</a> and DHCPv4 private options
      (<a class="xref" href="#dhcp4-private-opts" title="8.2.10. DHCPv4 Private Options">Section 8.2.10, “DHCPv4 Private Options”</a>).
      </p><p>
      Usually the test expression is evaluated before subnet selection
      but in some cases it is useful to evaluate it later when the
      subnet, shared-network or pools are known but output option
      processing not yet done. The only-if-required flag, false by default,
      allows to perform the evaluation of the test expression only
      when it was required, i.e. in a require-client-classes list of the
      selected subnet, shared-network or pool.
      </p><p>
      The require-client-classes list which is valid for shared-network,
      subnet and pool scope specifies the classes which are evaluated
      in the second pass before output option processing.
      The list is built in the reversed precedence order of option
      data, i.e. an option data in a subnet takes precedence on one
      in a shared-network but required class in a subnet is added
      after one in a shared-network.
      The mechanism is related to the only-if-required flag but it is
      not mandatory that the flag was set to true.
      </p><p>
      In the following example the class named "Client_foo" is defined.
      It is comprised of all clients whose client ids (option 61) start with the
      string "foo". Members of this class will be given 192.0.2.1 and
      192.0.2.2 as their domain name servers.

        </p><pre class="screen">
"Dhcp4": {
    "client-classes": [<strong class="userinput"><code>
        {
            "name": "Client_foo",
            "test": "substring(option[61].hex,0,3) == 'foo'",
            "option-data": [
                {
                    "name": "domain-name-servers",
                    "code": 6,
                    "space": "dhcp4",
                    "csv-format": true,
                    "data": "192.0.2.1, 192.0.2.2"
                }
            ]
        },
        ...
    ],</code></strong>
    ...
}</pre><p>
      </p><p>
      This example shows a client class being defined for use by the DHCPv6 server.
      In it the class named "Client_enterprise" is defined.  It is comprised
      of all clients who's client identifiers start with the given hex string (which
      would indicate a DUID based on an enterprise id of 0xAABBCCDD). Members of this
      class will be given an 2001:db8:0::1 and 2001:db8:2::1 as their domain name servers.
        </p><pre class="screen">
"Dhcp6": {
    "client-classes": [<strong class="userinput"><code>
        {
            "name": "Client_enterprise",
            "test": "substring(option[1].hex,0,6) == 0x0002AABBCCDD'",
            "option-data": [
                {
                    "name": "dns-servers",
                    "code": 23,
                    "space": "dhcp6",
                    "csv-format": true,
                    "data": "2001:db8:0::1, 2001:db8:2::1"
                }
            ]
        },
        ...
    ],</code></strong>
    ...
}</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-using-host-reservations"></a>13.5. Using Static Host Reservations In Classification</h2></div></div></div><p>Classes can be statically assigned to the clients using techniques described
    in <a class="xref" href="#reservation4-client-classes" title="8.3.6. Reserving Client Classes in DHCPv4">Section 8.3.6, “Reserving Client Classes in DHCPv4”</a> and
    <a class="xref" href="#reservation6-client-classes" title="9.3.5. Reserving Client Classes in DHCPv6">Section 9.3.5, “Reserving Client Classes in DHCPv6”</a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-subnets"></a>13.6. Configuring Subnets With Class Information</h2></div></div></div><p>
        In certain cases it beneficial to restrict access to certain subnets
        only to clients that belong to a given class, using the "client-class"
        keyword when defining the subnet.
      </p><p>
        Let's assume that the server is connected to a network segment that uses
        the 192.0.2.0/24 prefix. The Administrator of that network has decided
        that addresses from range 192.0.2.10 to 192.0.2.20 are going to be
        managed by the DHCP4 server. Only clients belonging to client class
        Client_foo  are allowed to use this subnet. Such a
        configuration can be achieved in the following way:
        </p><pre class="screen">
"Dhcp4": {
    "client-classes": [
        {
            "name": "Client_foo",
            "test": "substring(option[61].hex,0,3) == 'foo'",
            "option-data": [
                {
                    "name": "domain-name-servers",
                    "code": 6,
                    "space": "dhcp4",
                    "csv-format": true,
                    "data": "192.0.2.1, 192.0.2.2"
                }
            ]
        },
        ...
    ],<strong class="userinput"><code>
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [ { "pool": "192.0.2.10 - 192.0.2.20" } ],
            "client-class": "Client_foo"
        },
        ...
    ],</code></strong>,
    ...
}</pre><p>
      </p><p>
        The following example shows restricting access to a DHCPv6 subnet.  This
        configuration will restrict use of the addresses 2001:db8:1::1 to
        2001:db8:1::FFFF to members of the "Client_enterprise" class.

        </p><pre class="screen">
"Dhcp6": {
    "client-classes": [
        {
            "name": "Client_enterprise",
            "test": "substring(option[1].hex,0,6) == 0x0002AABBCCDD'",
            "option-data": [
                {
                    "name": "dns-servers",
                    "code": 23,
                    "space": "dhcp6",
                    "csv-format": true,
                    "data": "2001:db8:0::1, 2001:db8:2::1"
                }
            ]
        },
        ...
    ], <strong class="userinput"><code>
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [ { "pool": "2001:db8:1::-2001:db8:1::ffff" } ],
            "client-class": "Client_enterprise"
        }
    ],</code></strong>
    ...
}</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="classification-pools"></a>13.7. Configuring Pools With Class Information</h2></div></div></div><p>
       Similar to subnets in certain cases access to certain address or
       prefix pools must be restricted to only clients that belong to a
       given class, using the "client-class" when defining the pool.
     </p><p>
       Let's assume that the server is connected to a network segment that uses
       the 192.0.2.0/24 prefix. The Administrator of that network has decided
       that addresses from range 192.0.2.10 to 192.0.2.20 are going to be
       managed by the DHCP4 server. Only clients belonging to client class
       Client_foo are allowed to use this pool. Such a
       configuration can be achieved in the following way:
       </p><pre class="screen">
"Dhcp4": {
    "client-classes": [
        {
            "name": "Client_foo",
            "test": "substring(option[61].hex,0,3) == 'foo'",
            "option-data": [
                {
                    "name": "domain-name-servers",
                    "code": 6,
                    "space": "dhcp4",
                    "csv-format": true,
                    "data": "192.0.2.1, 192.0.2.2"
                }
            ]
        },
        ...
    ],<strong class="userinput"><code>
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [
                {
                    "pool": "192.0.2.10 - 192.0.2.20",
                    "client-class": "Client_foo"
                }
            ]
        },
        ...
    ],</code></strong>,

}</pre><p>
      </p><p>
       The following example shows restricting access to an address pool.
       This configuration will restrict use of the addresses 2001:db8:1::1
       to 2001:db8:1::FFFF to members of the "Client_enterprise" class.
       </p><pre class="screen">
"Dhcp6": {
    "client-classes": [
        {
            "name": "Client_enterprise_",
            "test": "substring(option[1].hex,0,6) == 0x0002AABBCCDD'",
            "option-data": [
                {
                    "name": "dns-servers",
                    "code": 23,
                    "space": "dhcp6",
                    "csv-format": true,
                    "data": "2001:db8:0::1, 2001:db8:2::1"
                }
            ]
        },
        ...
    ],
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            <strong class="userinput"><code>
            "pools": [
                {
                    "pool": "2001:db8:1::-2001:db8:1::ffff",
                    "client-class": "Client_foo"
                }
            ]</code></strong>
        },
        ...
    ],
    ...
}</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58518848"></a>13.8. Using Classes</h2></div></div></div><p>
      Currently classes can be used for two functions.  They can supply options
      to the members of the class and they can be used to choose a subnet from which an
      address will be assigned to the class member.
      </p><p>
      When supplying options, options defined as part of the class definition
      are considered "class globals".  They will override any global options that
      may be defined and in turn will be overridden by any options defined for an
      individual subnet.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58520912"></a>13.9. Classes and Hooks</h2></div></div></div><p>
      You may use a hook to classify your packets. This may be useful if the
      expression would either be complex or time consuming and be easier or
      better to write as code.  Once the hook has added the proper class name
      to the packet the rest of the classification system will work as normal
      in choosing a subnet and selecting options.  For a description of
      hooks see <a class="xref" href="#hooks-libraries" title="Chapter 14. Hooks Libraries">Chapter 14, <i>Hooks Libraries</i></a>, for a description on
      configuring classes see <a class="xref" href="#classification-configuring" title="13.4. Configuring Classes">Section 13.4, “Configuring Classes”</a>
      and <a class="xref" href="#classification-subnets" title="13.6. Configuring Subnets With Class Information">Section 13.6, “Configuring Subnets With Class Information”</a>.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58524544"></a>13.10. Debugging Expressions</h2></div></div></div><p>
     While you are constructing your classification expressions you may
     find it useful to enable logging see <a class="xref" href="#logging" title="Chapter 18. Logging">Chapter 18, <i>Logging</i></a> for
     a more complete description of the logging facility.
     </p><p>
     To enable the debug statements in the classification system you will
     need to set the severity to "DEBUG" and the debug level to at least 55.
     The specific loggers are "kea-dhcp4.eval" and "kea-dhcp6.eval".
     </p><p>
     In order to understand the logging statements one must understand a
     bit about how expressions are evaluated, for a more complete description
     refer to the design document at <code class="uri"><a class="uri" href="http://kea.isc.org/wiki/KeaDesigns" target="_top">http://kea.isc.org/wiki/KeaDesigns</a></code>.
     In brief there are two structures used during the evaluation of an expression:
     a list of tokens which represent the expressions and a value stack which
     represents the values being manipulated.
     </p><p>
     The list of tokens is created when the configuration file is processed with
     most expressions and values being converted to a token.  The list is organized
     in reverse Polish notation.  During execution, the list will be traversed
     in order.  As each token is executed it will be able to pop values
     from the top of the stack and eventually push its result on the top of the
     stack.  Imagine the following expression:
       </p><pre class="screen">
       "test": "substring(option[61].hex,0,3) == 'foo'",
       </pre><p>
     This will result in the following tokens:
       </p><pre class="screen">
       option, number (0), number (3), substring, text ('foo'), equals
       </pre><p>
     In this example the first three tokens will simply push values onto the
     stack.  The substring token will then remove those three values and
     compute a result that it places on the stack.  The text option also
     places a value on the stack and finally the equals token removes the
     two tokens on the stack and places its result on the stack.
     </p><p>
     When debug logging is enabled, each time a token is evaluated it will
     emit a log message indicating the values of any objects that were popped
     off of the value stack and any objects that were pushed onto the value
     stack.
     </p><p>
     The values will be displayed as either text if the command is known
     to use text values or hexadecimal if the command either uses binary values or
     can manipulate either text or binary values.  For expressions that
     pop multiple values off the stack, the values will be displayed in
     the order they were popped.  For most expressions this won't matter
     but for the concat expression the values are displayed in reverse
     order from how they are written in the expression.
     </p><p>
     Let us assume that the following test has been entered into the configuration.
     This example skips most of the configuration to concentrate on the test.
       </p><pre class="screen">
       "test": "substring(option[61].hex,0,3) == 'foo'",
       </pre><p>
     The logging might then resemble this:
       </p><pre class="screen">
       2016-05-19 13:35:04.163 DEBUG [kea.eval/44478] EVAL_DEBUG_OPTION Pushing option 61 with value 0x666F6F626172
       2016-05-19 13:35:04.164 DEBUG [kea.eval/44478] EVAL_DEBUG_STRING Pushing text string '0'
       2016-05-19 13:35:04.165 DEBUG [kea.eval/44478] EVAL_DEBUG_STRING Pushing text string '3'
       2016-05-19 13:35:04.166 DEBUG [kea.eval/44478] EVAL_DEBUG_SUBSTRING Popping length 3, start 0, string 0x666F6F626172 pushing result 0x666F6F
       2016-05-19 13:35:04.167 DEBUG [kea.eval/44478] EVAL_DEBUG_STRING Pushing text string 'foo'
       2016-05-19 13:35:04.168 DEBUG [kea.eval/44478] EVAL_DEBUG_EQUAL Popping 0x666F6F and 0x666F6F pushing result 'true'
       </pre><p>
     </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
     The debug logging may be quite verbose if you have a number of expressions
     to evaluate.  It is intended as an aid in helping you create and debug
     your expressions.  You should plan to disable debug logging when you have your
     expressions working correctly.  You also may wish to include only one set of
     expressions at a time in the configuration file while debugging them in order
     to limit the log statements.  For example when adding a new set of expressions
     you might find it more convenient to create a configuration file that only
     includes the new expressions until you have them working correctly and then
     add the new set to the main configuration file.
     </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="hooks-libraries"></a>Chapter 14. Hooks Libraries</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#hooks-libraries-introduction">14.1. Introduction</a></span></dt><dt><span class="section"><a href="#idp58545072">14.2. Installing Hook packages</a></span></dt><dt><span class="section"><a href="#idp58545328">14.3. Configuring Hooks Libraries</a></span></dt><dt><span class="section"><a href="#idp58576272">14.4. Available Hooks Libraries</a></span></dt><dd><dl><dt><span class="section"><a href="#idp58614576">14.4.1. user_chk: Checking User Access</a></span></dt><dt><span class="section"><a href="#idp58631760">14.4.2. legal_log: Forensic Logging Hooks</a></span></dt><dt><span class="section"><a href="#flex-id">14.4.3. flex_id: Flexible Identifiers for Host Reservations</a></span></dt><dt><span class="section"><a href="#host-cmds">14.4.4. host_cmds: Host Commands</a></span></dt><dt><span class="section"><a href="#lease-cmds">14.4.5. lease_cmds: Lease Commands</a></span></dt><dt><span class="section"><a href="#subnet-cmds">14.4.6. subnet_cmds: Subnet Commands</a></span></dt><dt><span class="section"><a href="#high-availability-library">14.4.7. ha: High Availability</a></span></dt><dt><span class="section"><a href="#hooks-radius">14.4.8. radius: RADIUS server support</a></span></dt><dt><span class="section"><a href="#hooks-host-cache">14.4.9. host_cache: Caching Host Reservations</a></span></dt><dt><span class="section"><a href="#hooks-stat-cmds">14.4.10. stat_cmds: Supplemental Statistics Commands</a></span></dt></dl></dd><dt><span class="section"><a href="#user-context">14.5. User contexts</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="hooks-libraries-introduction"></a>14.1. Introduction</h2></div></div></div><p>
      Although Kea offers a lot of flexibility, there may be cases where
      its behavior needs customization.  To accommodate this possibility,
      Kea includes the idea of "Hooks".  This feature lets Kea load one
      or more dynamically-linked libraries (known as "hooks libraries")
      and, at various points in its processing ("hook points"), call
      functions in them.  Those functions perform whatever custom
      processing is required.
      </p><p>
        The hooks concept also allows keeping the core Kea code reasonably small
        by moving features that some, but not all users find useful to external
        libraries. People who don't need specific functionality simply don't
        load the libraries.
      </p><p>
      Hooks libraries are attached to individual Kea processes, not to
      Kea as a whole.  This means (for example) that it is possible
      to associate one set of libraries with the DHCP4 server and a
      different set to the DHCP6 server.
      </p><p>
      Another point to note is that it is possible for a process to
      load multiple libraries.  When processing reaches a hook point,
      Kea calls the hooks library functions attached to it.  If multiple
      libraries have attached a function to a given hook point, Kea calls
      all of them, in the order in which the libraries are specified in
      the configuration file. The order may be important: consult the
      documentation of the libraries to see if this is the case.
      </p><p>
      The next section describes how to configure hooks libraries. If you
      are interested in writing your own hooks library, information can be
      found in the <a class="ulink" href="https://jenkins.isc.org/job/Kea_doc/doxygen" target="_top">Kea
      Developer's Guide</a>.
      </p><p>
        Note that some libraries are available under different licenses.
      </p><p>
        Note that some libraries may require additional dependencies and/or
        compilation switches to be enabled, e.g. Radius library introduced in
        Kea 1.4 requires FreeRadius-client library to be present. If
        --with-free-radius option is not specified, the Radius library will not
        be built.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58545072"></a>14.2. Installing Hook packages</h2></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The installation procedure has changed in 1.4.0. Kea 1.3.0 and
        earlier needed special switches passed to configure script to detect the
        hook libraries. Please see this KB article: <code class="uri"><a class="uri" href="https://kb.isc.org/article/AA-01587" target="_top">https://kb.isc.org/article/AA-01587</a></code>
        .</p></div><p>Some hook packages are included in the base Kea sources. There is no
      need to do anything special to compile or install them, they are covered
      by the usual building and installation procedure. ISC also provides several
      additional hooks in form of various packages. All of those packages follow
      the same installation procedure that is similar to base Kea, but has
      several additional steps. For your convenience, the whole procedure is
      described here. Please refer to <a class="xref" href="#installation" title="Chapter 3. Installation">Chapter 3, <i>Installation</i></a> for general
      overview.</p><p>
        1. Download the package. You will receive detailed instructions how to
        get it separately. This will be a file with a name similar to
        kea-premium-1.4.0.tar.gz. Your name may differ depending on which
        package you got.
      </p><p>
        2. If you have the sources for the corresponding version of the
        open-source Kea package still on your system (from when you installed
        Kea), skip this step.  Otherwise extract the Kea source from the
        original tarball you downloaded.  For example, if you downloaded Kea
        1.4.0., you should have a tarball called kea-1.4.0.tar.gz on your
        system. Unpack this tarball:

</p><pre class="screen">
$ <strong class="userinput"><code>tar zxvf kea-1.4.0.tar.gz</code></strong>
</pre><p>

        This will unpack the tarball into the kea-1.4.0 subdirectory of your
        current working directory.
      </p><p>
        3. Unpack the Kea premium tarball into the directory into which Kea was
        unpacked. For example, assuming that you followed step 2 and that Kea
        1.4.0 has been unpacked into a kea-1.4.0 subdirectory and that the Kea
        premium tarball is in your current directory, the following steps will
        unpack the premium tarball into the correct location:
</p><pre class="screen">
  $ <strong class="userinput"><code>cd kea-1.4.0</code></strong>
  $ <strong class="userinput"><code>tar xvf ../kea-premium-1.4.0.tar.gz</code></strong>
</pre><p>
        Note that unpacking the Kea premium package will put the files into a
        directory named premium. Regardless of the name of your package, the
        directory will always be called premium, just its content may vary.
      </p><p>
        4. Run autoreconf tools. This step is necessary to update Kea's build
        script to include additional directory. If this tool is not already
        available on your system, you need to install automake and autoconf
        tools. To generate configure script, please use:
</p><pre class="screen">
  $ <strong class="userinput"><code>autoreconf -i</code></strong>
</pre><p>
      </p><p>
        5. Rerun configure, using the same configure options as you used when
        originally building Kea. You can check if configure has detected the
        premium package by inspecting the summary printed when it exits.  The
        first section of the output should look something like:
</p><pre class="screen">
Package:
  Name:            kea
  Version:         1.4.0
  Extended version:1.4.0 (tarball)
  OS Family:       Linux
  Using GNU sed:   yes
  Premium package: yes
  Included Hooks:  forensic_log flex_id host_cmds
</pre><p>

The last line indicates which specific hooks were detected. Note that some
hooks may require its own dedicated switches, e.g. radius hook requires
extra switches for FreeRADIUS. Please consult later sections of this
chapter for details.
      </p><p>
        6. Rebuild Kea
</p><pre class="screen">
  $ <strong class="userinput"><code>make</code></strong>
</pre><p>
If your machine has multiple CPU cores, interesting option to consider here
is -j X, where X is the number of available cores.
      </p><p>
        7. Install Kea sources together with hooks:
</p><pre class="screen">
$ <strong class="userinput"><code>sudo make install</code></strong>
</pre><p>
      Note that as part of the installation procedure, the install script will
      eventually venture into premium/ directory and will install additional
      hook libraries and associated files.
      </p><p>
      The installation location of the hooks libraries depends whether you
      specified --prefix parameter to the configure script. If you did not,
      the default location will be /usr/local/lib/hooks. You can verify the
      libraries are installed properly with this command:
</p><pre class="screen">
$ <strong class="userinput"><code>ls -l /usr/local/lib/hooks/*.so</code></strong>
/usr/local/lib/hooks/libdhcp_flex_id.so
/usr/local/lib/hooks/libdhcp_host_cmds.so
/usr/local/lib/hooks/libdhcp_lease_cmds.so
/usr/local/lib/hooks/libdhcp_legal_log.so
/usr/local/lib/hooks/libdhcp_subnet_cmds.so
</pre><p>
      The exact list you see will depend on the packages you have.
      If you specified directory via --prefix, the hooks libraries
      will be located in {prefix directory}/lib/hooks.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58545328"></a>14.3. Configuring Hooks Libraries</h2></div></div></div><p>
      The hooks libraries for a given process are configured using the
      <span class="command"><strong>hooks-libraries</strong></span> keyword in the
      configuration for that process. (Note that
      the word "hooks" is plural).  The value of the keyword
      is an array of map structures, each structure corresponding to a hooks
      library.  For example, to set up two hooks libraries for the DHCPv4
      server, the configuration would be:
</p><pre class="screen">
<strong class="userinput"><code>"Dhcp4": {
    :
    "hooks-libraries": [
        {
            "library": "/opt/charging.so"
        },
        {
            "library": "/opt/local/notification.so",
            "parameters": {
                "mail": "spam@example.com",
                "floor": 13,
                "debug": false,
                "users": [ "alice", "bob", "charlie" ],
                "languages": {
                    "french": "bonjour",
                    "klingon": "yl'el"
                }
            }
        }
    ]
    :
}</code></strong>
</pre><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        This is a change to the syntax used in Kea 0.9.2 and earlier, where
        hooks-libraries was a list of strings, each string being the name of
        a library.  The change was made in Kea 1.0 to facilitate the
        specification of library-specific parameters, a capability
        available in Kea 1.1.0 onwards. Libraries should allow a parameter
        entry where to put comments as it is done for many configuration
        scopes with comment and user context.
      </p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          The library reloading behavior has changed in Kea 1.1. Libraries are
          reloaded, even if their list hasn't changed. Kea does that, because
          the parameters specified for the library (or the files those
          parameters point to) may have changed.
          </p></div><p>
        Libraries may have additional parameters. Those are not mandatory in the
        sense that there may be libraries that don't require them. However, for
        specific library there is often specific requirement for specify certain
        set of parameters. Please consult the documentation for your library
        for details. In the example above, the first library has no parameters.
        The second library has five parameters, specifying mail (string
        parameter), floor (integer parameter), debug (boolean parameter) and
        even lists (list of strings) and maps (containing strings). Nested
        parameters could be used if the library supports it. This topic is
        explained in detail in the Hooks Developer's Guide in the "Configuring
        Hooks Libraries" section.
      </p><p>
      Notes:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
          The full path to each library should be given.
          </p></li><li class="listitem" style="list-style-type: disc"><p>
          As noted above, order may be important - consult the documentation for
          each library.
          </p></li><li class="listitem" style="list-style-type: disc"><p>
          An empty list has the same effect as omitting the
          <span class="command"><strong>hooks-libraries</strong></span> configuration element all together.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          There is one case where this is not true: if Kea
          is running with a configuration that contains a
          <span class="command"><strong>hooks-libraries</strong></span> item, and that item is
          removed and the configuration reloaded, the removal will be
          ignored and the libraries remain loaded.  As a workaround,
          instead of removing the <span class="command"><strong>hooks-libraries</strong></span>
          item, change it to an empty list.  This will be fixed in a
          future version of Kea.
          </p></div></li></ul></div><p>
      </p><p>
      At the present time, only the kea-dhcp4 and kea-dhcp6 processes support
      hooks libraries.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp58576272"></a>14.4. Available Hooks Libraries</h2></div></div></div><p>
      As described above, the hooks functionality provides a way to customize
      a Kea server without modifying the core code.  ISC has chosen to take
      advantage of this feature to provide functions that may only be useful
      to a subset of Kea users.  To this end ISC has created some hooks
      libraries; these discussed in the following sections.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
      Some of these libraries will be available with the base code while others
      will be shared with organizations supporting development of Kea
      , possibly as a 'benefit' or 'thank you' for helping to sustain
      the larger Kea project. If you would like to get access to those
      libraries, please consider taking out a support contract: this includes
      professional support, advance security notifications, input into our
      roadmap planning, and many other benefits, while helping
      making Kea sustainable in the long term.
      </p></div><p>Currently the following libraries are available or planned from ISC:

        </p><div class="table"><a name="hook-libs"></a><p class="title"><b>Table 14.1. List of available hooks libraries</b></p><div class="table-contents"><table summary="List of available hooks libraries" border="1"><colgroup><col class="name"><col class="avail"><col class="description"></colgroup><thead><tr><th>Name</th><th>Availability</th><th>Since</th><th>Description</th></tr></thead><tbody><tr><td>user_chk</td><td>Kea sources</td><td>Kea 0.8</td><td>Reads known users list from a file. Unknown users
              will be assigned a
              lease from the last subnet defined in the configuration file,
              e.g. to redirect them a captive portal. This demonstrates how an
              external source of information can be used to influence the Kea
              allocation engine. This hook is part of the Kea source code and is
              available in the src/hooks/dhcp/user_chk directory.</td></tr><tr><td>Forensic Logging</td><td>Support customers</td><td>Kea 1.1.0</td><td>This library provides hooks that record a detailed log of
              lease assignments and renewals into a set of log files. In many
              legal jurisdictions companies, especially ISPs, must record
              information about the addresses they have leased to DHCP
              clients. This library is designed to help with that
              requirement. If the information that it records is sufficient it
              may be used directly. If your jurisdiction requires that you save
              a different set of information, you may use it as a template or
              example and create your own custom logging hooks.</td></tr><tr><td>Flexible Identifier</td><td>Support customers</td><td>Kea 1.2.0</td><td>Kea software provides a way to handle host reservations
              that include addresses, prefixes, options, client classes and
              other features. The reservation can be based on hardware address,
              DUID, circuit-id or client-id in DHCPv4 and using hardware address
              or DUID in DHCPv6. However, there are sometimes scenarios where the
              reservation is more complex, e.g. uses other options that
              mentioned above, uses part of specific options or perhaps even a
              combination of several options and fields to uniquely identify a
              client. Those scenarios are addressed by the Flexible Identifiers
              hook application. It allows defining an expression, similar to
              the one used in client classification,
              e.g. substring(relay6[0].option[37],0,6). Each incoming packet is
              evaluated against that expression and its value is then searched
              in the reservations database.
              </td></tr><tr><td>Host Commands</td><td>Support customers</td><td>Kea 1.2.0</td><td>Kea provides a way to store host reservations in a
              database. In many larger deployments it is useful to be able to
              manage that information while the server is running. This library
              provides management commands for adding, querying and deleting
              host reservations in a safe way without restarting the server.
              In particular, it validates the parameters, so an attempt to
              insert incorrect data, e.g. add a host with conflicting identifier
              in the same subnet will be rejected. Those commands are
              exposed via command channel (JSON over unix sockets) and Control
              Agent (JSON over RESTful interface). Additional commands and
              capabilities related to host reservations will be added in the
              future.</td></tr><tr><td>Subnet Commands</td><td>Support customers</td><td>Kea 1.3.0</td><td>In deployments in which subnet configuration needs to
              be frequently updated, it is a hard requirement that such updates be
              performed without the need for a full DHCP server reconfiguration
              or restart. This hooks library allows for incremental changes
              to the subnet configuration such as: adding a subnet, removing
              a subnet. It also allows for listing all available subnets and
              fetching detailed information about a selected subnet. The
              commands exposed by this library do not affect other subnets
              or configuration parameters currently used by the server.
              </td></tr><tr><td>Lease Commands</td><td>Kea sources</td><td>Kea 1.3.0</td><td>The lease commands hook library offers a number of new
              commands used to manage leases. Kea provides a way to store lease
              information in various backends: memfile, MySQL, PostgreSQL and
              Cassandra. This library provides a unified interface that can
              manipulate leases in an unified, safe way. In particular, it
              allows: manipulate leases in memfile while Kea is running, sanity
              check changes, check lease existence and remove all leases
              belonging to specific subnet. It can also catch more obscure
              errors, like adding a lease with subnet-id that does not exist in
              the configuration or configuring a lease to use an address that is
              outside of the subnet to which it is supposed to belong.
              </td></tr><tr><td>High Availability</td><td>Support customers</td><td>Kea 1.4.0</td><td>Minimizing a risk of DHCP service unavailability is
              achieved by setting up a pair of the DHCP servers in a network.
              Two modes of operation are supported. The first one is called load
              balancing and is sometimes referred to as active-active. Each
              server can handle selected group of clients in this network or all
              clients, if it detects that its partner has became unavailable.
              It is also possible
              to designate one server to serve all DHCP clients, and leave
              another server as "standby". This mode is called hot standby and
              is sometimes referenced to as active-passive. This server will
              activate its DHCP function when it detects that its partner is not
              available.  Such cooperation between the DHCP servers requires
              that these servers constantly communicate with each other to send
              updates about allocated leases and to periodically test whether
              their partners are still operational. The hook library also
              provides an ability to send lease updates to external backup
              server, making it much easier to have a replacement that is almost
              up to date. The "libdhcp_ha" library provides such functionality
              for Kea DHCP servers.
              </td></tr><tr><td>Radius</td><td>Support customers</td><td>Kea 1.4.0</td><td>The RADIUS Hook library allows Kea to interact with the
              RADIUS servers using access and accounting mechanisms. The access
              mechanism may be used for access control, assigning specific IPv4
              or IPv6 addresses reserved by RADIUS, dynamically assigning
              addresses from designated pools chosen by RADIUS or rejecting
              the client's messages altogether. The accounting mechanism allows
              RADIUS server to keep track of device activity over time.
              </td></tr><tr><td>Host Cache</td><td>Support customers</td><td>Kea 1.4.0</td><td>Some of the database backends, such as RADIUS, are
              considered slow and may take a long time to respond. Since Kea in
              general is synchronous, the backend performance directly affects
              the DHCP performance. To minimize the impact and improve
              performance, the Host Cache library provides a way to cache
              responses from other hosts. This includes negative caching,
              i.e. the ability to remember that there is no client information
              in the database.
              </td></tr></tbody></table></div></div><p><br class="table-break">

      </p><p>
        ISC hopes to see more hooks libraries become available as time
        progresses, both developed internally and externally. Since
        this list may evolve dynamically, we decided to keep it on a
        wiki page, available at this link: <a class="ulink" href="http://kea.isc.org/wiki/Hooks" target="_top">http://kea.isc.org/wiki/Hooks</a>.
        If you are a developer or are aware of any hooks libraries not
        listed there, please send a note to the kea-users or kea-dev
        mailing lists and someone will update it.
      </p><p>
        The libraries developed by ISC are described in detail in the following sections.
      </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58614576"></a>14.4.1. user_chk: Checking User Access</h3></div></div></div><p>
          The user_chk library is the first hooks library published by ISC. It
          attempts to serve several purposes:

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>To assign "new" or "unregistered" users to a
              restricted subnet, while "known" or "registered" users are assigned
              to unrestricted subnets.</p></li><li class="listitem"><p>To allow DHCP response options or vendor option
              values to be customized based upon user identity. </p></li><li class="listitem"><p>To provide a real time record of the user registration
              activity which can be sampled by an external consumer.</p></li><li class="listitem"><p> To serve as a demonstration of various capabilities
              possible using the hooks interface.</p></li></ul></div><p>
        </p><p>
          Once loaded, the library allows segregating incoming requests into
          known and unknown clients. For known clients, the packets are
          processed mostly as usual, except it is possible to override certain
          options being sent. That can be done on a per host basis. Clients
          that are not on the known hosts list will be treated as unknown and
          will be assigned to the last subnet defined in the configuration file.
        </p><p>
          As an example of use, this behavior may be used to put unknown users into a
          separate subnet that leads to a walled garden, where they can only
          access a registration portal. Once they fill in necessary data, their
          details are added to the known clients file and they get a proper
          address after their device is restarted.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This library was developed several years before the host
        reservation mechanism has become available. Currently host reservation is
        much more
        powerful and flexible, but nevertheless the user_chk capability to consult
        and external source of information about clients and alter Kea's
        behavior is useful and remains of educational value.
        </p></div><p>
          The library reads the /tmp/user_chk_registry.txt file while being
          loaded and each time an incoming packet is processed. The file is expected
          to have each line contain a self-contained JSON snippet which must
          have the following two entries:

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>type</strong></span>, whose value
            is "HW_ADDR" for IPv4 users or "DUID" for IPv6
            users</p></li><li class="listitem"><p><span class="command"><strong>id</strong></span>, whose value is
            either the hardware address or the DUID from the request
            formatted as a string of hex digits, with or without
            ":" delimiters.</p></li></ul></div><p>

and may have the zero or more of the following entries:

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>bootfile</strong></span> whose value
            is the pathname of the desired file</p></li><li class="listitem"><p><span class="command"><strong>tftp_server</strong></span> whose
            value is the hostname or IP address of the desired
            server</p></li></ul></div><p>

          A sample user registry file is shown below:

</p><pre class="screen">{ "type" : "HW_ADDR", "id" : "0c:0e:0a:01:ff:04", "bootfile" : "/tmp/v4bootfile" }
{ "type" : "HW_ADDR", "id" : "0c:0e:0a:01:ff:06", "tftp_server" : "tftp.v4.example.com" }
{ "type" : "DUID", "id" : "00:01:00:01:19:ef:e6:3b:00:0c:01:02:03:04", "bootfile" : "/tmp/v6bootfile" }
{ "type" : "DUID", "id" : "00:01:00:01:19:ef:e6:3b:00:0c:01:02:03:06", "tftp_server" : "tftp.v6.example.com" }</pre><p>

        </p><p>As with any other hooks libraries provided by ISC, internals of the
        user_chk code are well documented. You can take a look at the  <a class="ulink" href="https://jenkins.isc.org/job/Kea_doc/doxygen/d8/db2/libdhcp_user_chk.html" target="_top">Kea Developer's Guide section dedicated to the user_chk library</a>
        that discusses how the code works internally. That, together with
        our general entries in <a class="ulink" href="https://jenkins.isc.org/job/Kea_doc/doxygen" target="_top">Hooks
        Framework section</a> should give you some pointers how to extend
        this library and perhaps even write your own from scratch.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp58631760"></a>14.4.2. legal_log: Forensic Logging Hooks</h3></div></div></div><p>
        This section describes the forensic log hooks library. This library
        provides hooks that record a detailed log of lease assignments
        and renewals into a set of log files.  Currently this library
        is only available to ISC customers with a support contract.
        </p><p>
        In many legal jurisdictions companies, especially ISPs, must record
        information about the addresses they have leased to DHCP clients.
        This library is designed to help with that requirement.  If the
        information that it records is sufficient it may be used directly.
        If your jurisdiction requires that you save a different set of
        information you may use it as a template or example and create your
        own custom logging hooks.
        </p><p>
        This logging is done as a set of hooks to allow it to be customized
        to any particular need.  Modifying a hooks library is easier and
        safer than updating the core code.  In addition by using the hooks
        features those users who don't need to log this information can
        leave it out and avoid any performance penalties.
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58635008"></a>14.4.2.1. Log File Naming</h4></div></div></div><p>
          The names for the log files have the following form:
          </p><pre class="screen">
path/base-name.CCYYMMDD.txt
</pre><p>
          The "path" and "base-name" are supplied in the
          configuration as described below see
          <a class="xref" href="#forensic-log-configuration" title="14.4.2.4. Configuring the Forensic Log Hooks">Section 14.4.2.4, “Configuring the Forensic Log Hooks”</a>.  The next part of the name is
          the date the log file was started, with four digits for year, two digits
          for month and two digits for day.  The file is rotated on a daily basis.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
          When running Kea servers for both DHCPv4 and DHCPv6 the log names must
          be distinct.  See the examples in <a class="xref" href="#forensic-log-configuration" title="14.4.2.4. Configuring the Forensic Log Hooks">Section 14.4.2.4, “Configuring the Forensic Log Hooks”</a>.
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58637232"></a>14.4.2.2. DHCPv4 Log Entries</h4></div></div></div><p>
          For DHCPv4 the library creates entries based on DHCPREQUEST messages
          and corresponding DHCPv4 leases intercepted by lease4_select
          (for new leases) and lease4_renew (for renewed leases) hooks.
          </p><p>
          An entry is a single string with no embedded end-of-line markers,
          a prepended timestamp and has the following sections:
</p><pre class="screen">
timestamp address duration device-id {client-info} {relay-info}
</pre><p>
          </p><p>
          Where:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            timestamp - the current date and time the log entry was written
            in "%Y-%m-%d %H:%M:%S %Z" strftime format ("%Z" is the time zone
            name).
            </p></li><li class="listitem"><p>
            address - the leased IPv4 address given out and whether it was
            assigned or renewed.
            </p></li><li class="listitem"><p>
            duration - the lease lifetime expressed in days (if present),
            hours, minutes and seconds.  A lease lifetime of 0xFFFFFFFF will be
            denoted with the text "infinite duration".
            </p></li><li class="listitem"><p>
            device-id - the client's hardware address shown as numerical type
            and hex digit string.
            </p></li><li class="listitem"><p>
            client-info - the DHCP client id option (61) if present, shown as
            a hex string.
            </p></li><li class="listitem"><p>
            relay-info - for relayed packets the giaddr and the RAI circuit-id,
            remote-id and subscriber-id options (option 82 sub
            options: 1, 2 and 6) if present.
            The circuit id and remote id are presented as hex strings
            </p></li></ul></div><p>
          </p><p>
          For instance (line breaks added for readability, they would not
          be present in the log file).
</p><pre class="screen">
2018-01-06 01:02:03 CET Address: 192.2.1.100 has been renewed for 1 hrs 52 min 15 secs to a device with hardware address: hwtype=1 08:00:2b:02:3f:4e, client-id: 17:34:e2:ff:09:92:54 connected via relay at address: 192.2.16.33, identified by circuit-id: 68:6f:77:64:79 and remote-id: 87:f6:79:77:ef
</pre><p>
        </p><p>
        In addition to logging lease activity driven by DHCPv4 client traffic, it also
        logs entries for the following lease management control channel commands:
        lease4-add, lease4-update, and lease4-del.  Each entry is a single string
        with no embedded end-of-line markers and they will typically have the following
        forms:
        </p><p>
        <span class="command"><strong>lease4-add:</strong></span>
</p><pre class="screen">
*timestamp* Administrator added a lease of address: *address* to a device with hardware address: *device-id*
</pre><p>
        Dependent on the arguments of the add command, it may also include the
        client-id and duration.
        </p><p>
        Example:
</p><pre class="screen">
2018-01-06 01:02:03 CET Administrator added a lease of address: 192.0.2.202 to a device with hardware address: 1a:1b:1c:1d:1e:1f for 1 days 0 hrs 0 mins 0 secs
</pre><p>
        </p><p>
        <span class="command"><strong>lease4-update:</strong></span>
</p><pre class="screen">
*timestamp* Administrator updated information on the lease of address: *address* to a device with hardware address: *device-id*
</pre><p>
        Dependent on the arguments of the update command, it may also include the
        client-id and lease duration.
        </p><p>
        Example:
</p><pre class="screen">
2018-01-06 01:02:03 CET Administrator updated information on the lease of address: 192.0.2.202 to a device with hardware address: 1a:1b:1c:1d:1e:1f, client-id: 1234567890
</pre><p>
        </p><p>
        <span class="command"><strong>lease4-del:</strong></span>
        Deletes have two forms, one by address and one by identifier and identifier type:
</p><pre class="screen">
*timestamp* Administrator deleted the lease for address: *address*
</pre><p>
        or
</p><pre class="screen">
*timestamp* Administrator deleted a lease for a device identified by: *identifier-type* of *identifier*
</pre><p>
        Currently only a type of @b hw-address (hardware address) is supported.
        </p><p>
        Examples:
</p><pre class="screen">
2018-01-06 01:02:03 CET Administrator deleted the lease for address: 192.0.2.202

2018-01-06 01:02:12 CET Administrator deleted a lease for a device identified by: hw-address of 1a:1b:1c:1d:1e:1f
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58640000"></a>14.4.2.3. DHCPv6 Log Entries</h4></div></div></div><p>
          For DHCPv6 the library creates entries based on lease management
          actions intercepted by the lease6_select (for new leases), lease6_renew
          (for renewed leases) and lease6_rebind (for rebound leases).
          </p><p>
          An entry is a single string with no embedded end-of-line markers,
          a prepended timestamp and has the following sections:
</p><pre class="screen">
timestamp address duration device-id {relay-info}*
</pre><p>
          </p><p>
          Where:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            timestamp - the current date and time the log entry was written
            in "%Y-%m-%d %H:%M:%S %Z" strftime format ("%Z" is the time zone
            name).
            </p></li><li class="listitem"><p>
            address - the leased IPv6 address or prefix given out and whether
            it was assigned or renewed.
            </p></li><li class="listitem"><p>
            duration - the lease lifetime expressed in days (if present),
            hours, minutes and seconds.  A lease lifetime of 0xFFFFFFFF will be
            denoted with the text "infinite duration".
            </p></li><li class="listitem"><p>
            device-id - the client's DUID and hardware address (if present).
            </p></li><li class="listitem"><p>
            relay-info - for relayed packets the content of relay agent
            messages, remote-id (code 37), subscriber-id (code 38) and
            interface-id (code 18) options if present. Note that
            interface-id option, if present, identifies the whole interface the
            relay agent received the message on. This typically translates to a
            single link in your network, but it depends on your specific network
            topology. Nevertheless, this is useful information to better scope
            down the location of the device, so it is being recorded, if present.
            </p></li></ul></div><p>
          </p><p>
          For instance (line breaks added for readability, they would not
          be present in the log file).
</p><pre class="screen">
2018-01-06 01:02:03 PST Address:2001:db8:1:: has been assigned for 0 hrs 11 mins 53 secs to a device with DUID: 17:34:e2:ff:09:92:54 and hardware address: hwtype=1 08:00:2b:02:3f:4e (from Raw Socket) connected via relay at address: fe80::abcd for client on link address: 3001::1, hop count: 1, identified by remote-id: 01:02:03:04:0a:0b:0c:0d:0e:0f and subscriber-id: 1a:2b:3c:4d:5e:6f
</pre><p>
        </p><p>
        In addition to logging lease activity driven by DHCPv6 client traffic, it also
        logs entries for the following lease management control channel commands:
        lease6-add, lease6-update, and lease6-del.  Each entry is a single string
        with no embedded end-of-line markers and they will typically have the following
        forms:
        </p><p>
        <span class="command"><strong>lease6-add:</strong></span>
</p><pre class="screen">
*timestamp* Administrator added a lease of address: *address* to a device with DUID: *DUID*
</pre><p>
        Dependent on the arguments of the add command, it may also include the hardware address and duration.
        </p><p>
        Example:
</p><pre class="screen">
2018-01-06 01:02:03 PST Administrator added a lease of address: 2001:db8::3 to a device with DUID: 1a:1b:1c:1d:1e:1f:20:21:22:23:24 for 1 days 0 hrs 0 mins 0 secs
</pre><p>
        </p><p>
        <span class="command"><strong>lease6-update:</strong></span>
</p><pre class="screen">
*timestamp* Administrator updated information on the lease of address: *address* to a device with DUID: *DUID*
</pre><p>
        Dependent on the arguments of the update command, it may also include the hardware address and lease duration.
        </p><p>
        Example:
</p><pre class="screen">
2018-01-06 01:02:03 PST Administrator updated information on the lease of address: 2001:db8::3 to a device with DUID: 1a:1b:1c:1d:1e:1f:20:21:22:23:24, hardware address: 1a:1b:1c:1d:1e:1f
</pre><p>
        </p><p>
        <span class="command"><strong>lease6-del:</strong></span>
        Deletes have two forms, one by address and one by identifier and identifier type:
</p><pre class="screen">
*timestamp* Administrator deleted the lease for address: *address*
</pre><p>
        or
</p><pre class="screen">
*timestamp* Administrator deleted a lease for a device identified by: *identifier-type* of *identifier*
</pre><p>
        Currently only a type of DUID is supported.
        </p><p>
Examples:
</p><pre class="screen">
2018-01-06 01:02:03 PST Administrator deleted the lease for address: 2001:db8::3

2018-01-06 01:02:11 PST Administrator deleted a lease for a device identified by: duid of 1a:1b:1c:1d:1e:1f:20:21:22:23:24
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="forensic-log-configuration"></a>14.4.2.4. Configuring the Forensic Log Hooks</h4></div></div></div><p>
          To use this functionality the hook library must be included in the
          configuration of the desired DHCP server modules. The legal_log
          library is installed alongside the Kea libraries in
          <code class="filename">[kea-install-dir]/lib</code> where
          <code class="filename">kea-install-dir</code> is determined by the
          "--prefix" option of the configure script.  It defaults to
          <code class="filename">/usr/local</code>.  Assuming the
          default value then, configuring kea-dhcp4 to load the legal_log
          library could be done with the following Kea4 configuration:
</p><pre class="screen">
"Dhcp4": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/usr/local/lib/libdhcp_legal_log.so",
            "parameters": {
                "path": "/var/kea/var",
                "base-name": "kea-forensic4"
            }
        },
        ...
    ] </code></strong>
}
</pre><p>
          </p><p>
          To configure it for kea-dhcp6, the commands are simply as shown below:
</p><pre class="screen">
"Dhcp6": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/usr/local/lib/libdhcp_legal_log.so",
            "parameters": {
                "path": "/var/kea/var",
                "base-name": "kea-forensic6"
            }
        },
        ...
    ] </code></strong>
}
</pre><p>
          </p><p>
          Two Hook Library parameters are supported:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
            path - the directory in which the forensic file(s) will be written.  The
            default value is
            <code class="filename">[prefix]/kea/var</code>.  The directory must exist.
            </p></li><li class="listitem"><p>
            base-name - an arbitrary value which is used in conjunction with
            the current system date to form the current forensic file name.  It defaults
            to <code class="filename">kea-legal</code>.
            </p></li></ul></div><p>
          </p><p>
            If it is desired to restrict forensic logging to certain subnets, the
            "legal-logging" boolean parameter can be specified within a user context of
            these subnets. For example:
</p><pre class="screen">
"Dhcpv4" {
    "subnet4": [
        {
            "subnet": "192.0.2.0/24",
            "pools": [
                {
                     "pool": "192.0.2.1 - 192.0.2.200"
                }
            ],
            <strong class="userinput"><code>"user-context": {
                "legal-logging": false
            }</code></strong>
        }
    ]
}
</pre><p>
              disables legal logging for the subnet "192.0.2.0/24". If this parameter
              is not specified, it defaults to 'true', which enables legal logging for
              the subnet.
          </p><p>
            The following example demonstrates how to selectively disable legal logging
            for an IPv6 subnet.
</p><pre class="screen">
"Dhcpv6": {
    "subnet6": [
        {
            "subnet": "2001:db8:1::/64",
            "pools": [
                 {
                     "pool": "2001:db8:1::1-2001:db8:1::ffff"
                 }
            ],
            <strong class="userinput"><code>"user-context": {
                "legal-logging": false
            }</code></strong>
        }
    ]
}
</pre><p>
          </p><p>
            See <a class="xref" href="#dhcp4-user-contexts" title="8.11. User contexts in IPv4">Section 8.11, “User contexts in IPv4”</a> and <a class="xref" href="#dhcp6-user-contexts" title="9.14. User contexts in IPv6">Section 9.14, “User contexts in IPv6”</a>
            to learn more about user contexts in Kea configuration.
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="forensic-log-database"></a>14.4.2.5. Database backend</h4></div></div></div><p>
          Log entries can be inserted into a database when Kea is configured
          with database backend support: a table named 'logs' is used with a
          timestamp (timeuuid for Cassandra CQL) generated by the database
          software and a text log with the same format than for files
          without the timestamp.
          </p><p>
          Please refer to <a class="xref" href="#mysql-database" title="4.3.2. MySQL">Section 4.3.2, “MySQL”</a> for MySQL,
          to <a class="xref" href="#pgsql-database" title="4.3.3. PostgreSQL">Section 4.3.3, “PostgreSQL”</a> for PostgreSQL or
          to <a class="xref" href="#cql-database" title="4.3.4. CQL (Cassandra)">Section 4.3.4, “CQL (Cassandra)”</a> for Cassandra CQL.
          Scripts are in
          <code class="filename"><em class="replaceable"><code>path-to-kea</code></em>/share/kea/legal_log/scripts</code> directory, for instance the PostgreSQL create schema
          command is:
</p><pre class="screen">
$ <strong class="userinput"><code>psql -d <em class="replaceable"><code>database-name</code></em> -U <em class="replaceable"><code>user-name</code></em> -f <em class="replaceable"><code>path-to-kea</code></em>/share/kea/legal_log/scripts/pgsql/legldb_create.pgsql</code></strong>
Password for user <em class="replaceable"><code>user-name</code></em>:
START TRANSACTION
CREATE TABLE
CREATE INDEX
CREATE TABLE
INSERT 0 1
COMMIT
$
</pre><p>
          </p><p>
          Configuration parameters are extended by standard lease database
          parameters as defined in <a class="xref" href="#database-configuration4" title="8.2.2.2. Lease Database Configuration">Section 8.2.2.2, “Lease Database Configuration”</a>.
          The "type" parameter should be "mysql", "postgresql",  "cql" or
          be "logfile". When it is absent or set to "logfile" files are
          used.
          </p><p>
          This database feature is experimental and will be likely
          improved, for instance to add an address / prefix index (currently
          the only index is the timestamp). No specific tools is provided
          to operate the database but standard tools are applicable,
          for instance to dump the logs table from a CQL database:
</p><pre class="screen">
$ <strong class="userinput"><code>echo 'SELECT dateOf(timeuuid), log FROM logs;' | cqlsh -k <em class="replaceable"><code>database-name</code></em></code></strong>

 system.dateof(timeuuid)         | log
---------------------------------+---------------------------------------
 2018-01-06 01:02:03.227000+0000 | Address: 192.2.1.100 has been renewed ...
 ...
(12 rows)
$
</pre><p>
          </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="flex-id"></a>14.4.3. flex_id: Flexible Identifiers for Host Reservations</h3></div></div></div><p>
          This section describes a hook application dedicated to generate
          flexible identifiers for host reservation. Kea software provides a way
          to handle host reservations that include addresses, prefixes, options,
          client classes and other features. The reservation can be based on
          hardware address, DUID, circuit-id or client-id in DHCPv4 and using
          hardware address or DUID in DHCPv6. However, there are sometimes
          scenarios where the reservation is more complex, e.g. uses other
          options that mentioned above, uses part of specific options or perhaps
          even a combination of several options and fields to uniquely identify
          a client. Those scenarios are addressed by the Flexible Identifiers
        hook application.</p><p>Currently this library is only available to ISC customers with a
        support contract.</p><p>The library allows for defining an expression, using notation
        initially used for client classification only. See <a class="xref" href="#classification-using-expressions" title="13.3. Using Expressions In Classification">Section 13.3, “Using Expressions In Classification”</a> for detailed description
        of the syntax available. One notable difference is that for client
        classification the expression currently has to evaluate to either true
        or false, while the flexible identifier expression is expected to
        evaluate to a string that will be used as identifier. It is a valid case
        for the expression to evaluate to empty string (e.g. in cases where a
        client does not sent specific options). This expression is then
        evaluated for each incoming packet. This evaluation generates an
        identifier that is used to identify the client. In particular, there may
        be host reservations that are tied to specific values of the flexible
        identifier.</p><p>
          The library can be loaded in similar way as other hook libraries. It
          takes a mandatory parameter identifier-expression and optional
          boolean parameter replace-client-id:
</p><pre class="screen">
"Dhcp6": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<strong class="userinput"><code>expression</code></strong>",
                "replace-client-id": "<strong class="userinput"><code>false</code></strong>"
            }
        },
        ...
    ] </code></strong>
}
</pre><p>
        </p><p>
          The flexible identifier library supports both DHCPv4 and DHCPv6.
        </p><p>
          EXAMPLE: Let's consider a case of an IPv6 network that has an
          independent interface for each of the connected customers. Customers
          are able to plug in whatever device they want, so any type of
          identifier (e.g. a client-id) is unreliable. Therefore the operator
          may decide to use an option inserted by a relay agent to differentiate
          between clients. In this particular deployment, the operator verified
          that the interface-id is unique for each customer facing
          interface. Therefore it is suitable for usage as reservation. However,
          only the first 6 bytes of the interface-id are interesting, because
          remaining bytes are either randomly changed or not unique between
          devices. Therefore the customer decided to use first 6 bytes of the
          interface-id option inserted by the relay agent. After adding "flex-id"
          host-reservation-identifiers goal can be achieved by using the
          following configuration:
</p><pre class="screen">
"Dhcp6": {
    "subnet6": [{ ..., // subnet definition starts here
    "reservations": [
        <strong class="userinput"><code>"flex-id": "'port1234'"</code></strong>, // value of the first 8 bytes of the interface-id
        "ip-addresses": [ "2001:db8::1" ]
    ],
    }], // end of subnet definitions
    "host-reservation-identifiers": ["duid", "flex-id"], // add "flex-id" to reservation identifiers
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<strong class="userinput"><code>substring(relay6[0].option[18].hex,0,8)</code></strong>"
            }
        },
        ...
    ]
}
</pre><p>
        </p><p>
          NOTE: Care should be taken when adjusting the expression. If the
          expression changes, then all the flex-id values may change, possibly
          rendering all reservations based on flex-id unusable until they're
          manually updated. Therefore it is strongly recommended to start with
          the expression and a handful reservations, adjust the expression as
          needed and only after it was confirmed the expression does exactly
          what is expected out of it go forward with host reservations on any
          broader scale.
        </p><p>
          flex-id values in host reservations can be specified in two
          ways. First, they can be expressed as hex string, e.g. bar string
          can be represented as 626174. Alternatively, it can be expressed
          as quoted value (using double and single quotes), e.g. "'bar'".
          The former is more convenient for printable characters, while hex
          string values are more convenient for non-printable characters.
        </p><pre class="screen">
"Dhcp6": {
    "subnet6": [{ ..., // subnet definition starts here
    "reservations": [
        <strong class="userinput"><code>"flex-id": "01:02:03:04:05:06"</code></strong>, // value of the first 8 bytes of the interface-id
        "ip-addresses": [ "2001:db8::1" ]
    ],
    }], // end of subnet definitions
    "host-reservation-identifiers": ["duid", "flex-id"], // add "flex-id" to reservation identifiers
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<strong class="userinput"><code>vendor[4491].option[1026].hex</code></strong>"
            }
        },
        ...
    ]
}
</pre><p>
          When "replace-client-id" is set to false (which is the default setting),
          the flex-id hook library uses evaluated flexible identifier solely for
          identifying host reservations, i.e. searching for reservations within a
          database. This is a functional equivalent of other identifiers,
          similar to hardware address or circuit-id. However,
          this mode of operation has an implication that if a client device is
          replaced, it may cause a conflict between an existing lease (allocated
          for old device) and the new lease being allocated for the new device. The
          conflict arises because the same flexible identifier is computed for the
          replaced device and the server will try to allocate the same lease. The
          mismatch between client identifiers sent by new device and old device causes
          the server to refuse this new allocation until the old lease expires.
          A manifestation of this problem is dependant on specific expression
          used as flexible identifier and is likely to appear if you only use options
          and other parameters that are identifying where the device is
          connected (e.g. circuit-id), rather than the device identification
          itself (e.g. MAC address).
        </p><p>
          The flex-id library offers a way to overcome the problem with lease conflicts
          by dynamically replacing client identifier (or DUID in DHCPv6 case) with a
          value derived from flexible identifier. The server processes the client's
          query as if flexible identifier was sent in the client identifier (or DUID)
          option. This guarantees that returning client (for which the same flexible
          identifier is evaluated) will be assigned the same lease despite the client
          identifier and/or MAC address change.
        </p><p>
          The following is a stub configuration that enables this behavior:
</p><pre class="screen">
"Dhcp4": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_flex_id.so",
            "parameters": {
                "identifier-expression": "<strong class="userinput"><code>expression</code></strong>",
                "replace-client-id": "<strong class="userinput"><code>true</code></strong>"
            }
        },
        ...
    ] </code></strong>
}
</pre><p>
        </p><p>
          In the DHCPv4 case, the value derived from the flexible identifier is formed
          by prepending 1 byte with a value of zero to flexible identifier. In the IPv6
          case, it is formed by prepanding two zero bytes before the flexible identifier.
        </p><p>
          Note that for this mechanism to take effect, the DHCPv4 server must be configured
          to respect the client identifier option value during lease allocation, i.e.
          "match-client-id" must be set to true. See
          <a class="xref" href="#dhcp4-match-client-id" title="8.2.19. Using Client Identifier and Hardware Address">Section 8.2.19, “Using Client Identifier and Hardware Address”</a> for details. No additional settings
          are required for DHCPv6.
        </p><p>
          If "replace-client-id" option is set to true, the value of "echo-client-id"
          parameter (that governs whether to send back a client-id option or
          not) is ignored.
        </p><p>
          The <a class="xref" href="#lease-cmds" title="14.4.5. lease_cmds: Lease Commands">Section 14.4.5, “lease_cmds: Lease Commands”</a> section describes commands used to retrieve,
          update and delete leases using various identifiers, e.g. "hw-address",
          "client-id". The lease_cmds library doesn't natively support querying for
          leases by flexible identifier. However, when "replace-client-id" is set to
          true, it makes it possible to query for leases using a value derived from
          the flexible identifier. In the DHCPv4 case, the query will look similar to this:
</p><pre class="screen">
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "client-id",
        "identifier": "00:<strong class="userinput"><code>54:64:45:66</code></strong>",
        "subnet-id": 44
    }
}
</pre><p>

            where hexadecimal value of "54:64:45:66" is a flexible identifier computed
            for the client.
        </p><p>
          In the DHCPv6 case, the corresponding query will look similar to this:
</p><pre class="screen">
{
    "command": "lease6-get",
    "arguments": {
        "identifier-type": "duid",
        "identifier": "00:00:<strong class="userinput"><code>54:64:45:66</code></strong>",
        "subnet-id": 10
    }
}</pre><p>

        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="host-cmds"></a>14.4.4. host_cmds: Host Commands</h3></div></div></div><p>
          This section describes a hook application that offers a number of new
          commands used to query and manipulate host reservations. Kea provides
          a way to store host reservations in a database. In many larger
          deployments it is useful to be able to manage that information while
          the server is running. This library provides management commands for
          adding, querying and deleting host reservations in a safe way without
          restarting the server.  In particular, it validates the parameters, so
          an attempt to insert incorrect data e.g. add a host with conflicting
          identifier in the same subnet will be rejected. Those commands are
          exposed via command channel (JSON over unix sockets) and Control Agent
          (JSON over RESTful interface). Additional commands and capabilities
          related to host reservations will be added in the future.
        </p><p>Currently this library is only available to ISC customers with a
        support contract.</p><p>
          Currently three commands are supported: reservation-add (which adds
          new host reservation), reservation-get (which returns existing
          reservation if specified criteria are matched) and reservation-del
          (which attempts to delete a reservation matching specified
          criteria). To use commands that change the reservation information
          (currently these are reservation-add and reservation-del, but this
          rule applies to other commands that may be implemented in the future),
          hosts database must be specified (see hosts-databases description in
          <a class="xref" href="#hosts-databases-configuration4" title="8.2.3.1. DHCPv4 Hosts Database Configuration">Section 8.2.3.1, “DHCPv4 Hosts Database Configuration”</a> and <a class="xref" href="#hosts-databases-configuration6" title="9.2.3.1. DHCPv6 Hosts Database Configuration">Section 9.2.3.1, “DHCPv6 Hosts Database Configuration”</a>) and it must not operate in
          read-only mode. If the hosts-databases are not specified or are running
          in read-only mode, the host_cmds library will load, but any attempts
          to use reservation-add or reservation-del will fail.
        </p><p>
          Additional host reservation commands are planned in the future. For
          a description of envisaged commands, see
<a class="ulink" href="http://kea.isc.org/wiki/ControlAPIRequirements" target="_top">Control API
Requirements </a> document.</p><p>
          All commands are using JSON syntax. They can be issued either using
          control channel (see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>) or via Control
          Agent (see <a class="xref" href="#kea-ctrl-agent" title="Chapter 7. Kea Control Agent">Chapter 7, <i>Kea Control Agent</i></a>).
        </p><p>
          The library can be loaded in similar way as other hook libraries. It
          does not take any parameters. It supports both DHCPv4 and DHCPv6
          servers.
</p><pre class="screen">
"Dhcp6": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_host_cmds.so"
        }
        ...
    ] </code></strong>
}
</pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58739600"></a>14.4.4.1. reservation-add command</h4></div></div></div><p>
          <span class="command"><strong>reservation-add</strong></span> allows for the insertion of a new host.  It
          takes a set of arguments that vary depending on the nature of the host
          reservation. Any parameters allowed in the configuration file that
          pertain to host reservation are permitted here. For details regarding
          IPv4 reservations, see <a class="xref" href="#host-reservation-v4" title="8.3. Host Reservation in DHCPv4">Section 8.3, “Host Reservation in DHCPv4”</a> and <a class="xref" href="#host-reservation-v6" title="9.3. Host Reservation in DHCPv6">Section 9.3, “Host Reservation in DHCPv6”</a>. There is one notable addition. A
          <span class="command"><strong>subnet-id</strong></span> must be specified.  This parameter is
          mandatory, because reservations specified in the configuration file
          are always defined within a subnet, so the subnet they belong to is
          clear. This is not the case with reservation-add, therefore the
          subnet-id must be specified explicitly. An example command can be as
          simple as:
</p><pre class="screen">{
    "command": "reservation-add",
    "arguments": {
        <strong class="userinput"><code>"reservation": {
            "subnet-id": 1,
            "hw-address": "1a:1b:1c:1d:1e:1f",
            "ip-address": "192.0.2.202"
        }</code></strong>
    }
}</pre><p> but can also take many more parameters, for example:

</p><pre class="screen">
{
    "command": "reservation-add",
    "arguments": {
        <strong class="userinput"><code>"reservation":
            {
                "subnet-id":1,
                "client-id": "01:0a:0b:0c:0d:0e:0f",
                "ip-address": "192.0.2.205",
                "next-server": "192.0.2.1",
                "server-hostname": "hal9000",
                "boot-file-name": "/dev/null",
                "option-data": [
                    {
                        "name": "domain-name-servers",
                        "data": "10.1.1.202,10.1.1.203"
                    }
                ],
                "client-classes": [ "special_snowflake", "office" ]
            }</code></strong>
    }
}</pre><p>

Here is an example of complex IPv6 reservation:
</p><pre class="screen">
{
    "command": "reservation-add",
    "arguments": {
        <strong class="userinput"><code>"reservation":
            {
                "subnet-id":1,
                "duid": "01:02:03:04:05:06:07:08:09:0A",
                "ip-addresses": [ "2001:db8:1:cafe::1" ],
                "prefixes": [ "2001:db8:2:abcd::/64" ],
                "hostname": "foo.example.com",
                "option-data": [
                    {
                        "name": "vendor-opts",
                        "data": "4491"
                    },
                    {
                        "name": "tftp-servers",
                        "space": "vendor-4491",
                        "data": "3000:1::234"
                    }
                ]
            }</code></strong>
    }
}</pre><p>
        </p><p>
          The command returns a status that indicates either a success (result
          0) or a failure (result 1). Failed command always includes text
          parameter that explains the cause of failure. Example results:
          </p><pre class="screen">{ "result": 0, "text": "Host added." }</pre><p> Example failure:
          </p><pre class="screen">{ "result": 1, "text": "Mandatory 'subnet-id' parameter missing." }</pre><p>
        </p><p>
          As <span class="command"><strong>reservation-add</strong></span> is expected to store the host,
          hosts-databases parameter must be specified in your configuration and
          databases must not run in read-only mode. In the future versions
          it will be possible to modify the reservations read from a
          configuration file. Please contact ISC if you are interested in this
          functionality.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58750928"></a>14.4.4.2. reservation-get command</h4></div></div></div><p><span class="command"><strong>reservation-get</strong></span> can be used to query the host
          database and retrieve existing reservations. There are two types of
          parameters this command supports: (subnet-id, address) or (subnet-id,
          identifier-type, identifier). The first type of query is used when the
          address (either IPv4 or IPv6) is known, but the details of the
          reservation aren't. One common use case of this type of query is to
          find out whether a given address is reserved or not. The second query
          uses identifiers. For maximum flexibility, Kea stores the host
          identifying information as a pair of values: type and the actual
          identifier. Currently supported identifiers are "hw-address", "duid",
          "circuit-id", "client-id" and "flex-id", but additional types may be
          added in the future. If any new identifier types are defined in the
          future, reservation-get command will support them
          automatically.</p><p>
            An example command for getting a host reservation by (subnet-id,
            address) pair looks as follows:
</p><pre class="screen">
{
    "command": "reservation-get",
    "arguments": {
        "subnet-id": 1,
        "ip-address": "192.0.2.202"
    }
}</pre><p>

An example query by (subnet-id, identifier-type, identifier) looks as follows:
</p><pre class="screen">
{
    "command": "reservation-get",
    "arguments":
        "subnet-id": 4,
        "identifier-type": "hw-address",
        "identifier": "01:02:03:04:05:06"
    }
}</pre><p>

          </p><p><span class="command"><strong>reservation-get</strong></span> typically returns result 0
          when the query was conducted properly. In particular, 0 is returned
          when the host was not found. If the query was successful a number
          of host parameters will be returned. An example of a query that
          did not find the host looks as follows:
</p><pre class="screen">{ "result": 0, "text": "Host not found." }</pre><p>

An example result returned when the host was found:
</p><pre class="screen">{
  "arguments": {
    "boot-file-name": "bootfile.efi",
    "client-classes": [

    ],
    "hostname": "somehost.example.org",
    "hw-address": "01:02:03:04:05:06",
    "ip-address": "192.0.2.100",
    "next-server": "192.0.0.2",
    "option-data": [

    ],
    "server-hostname": "server-hostname.example.org"
  },
  "result": 0,
  "text": "Host found."
}</pre><p>

An example result returned when the query was malformed:</p><pre class="screen">
{ "result": 1, "text": "No 'ip-address' provided and 'identifier-type'
                        is either missing or not a string." }</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58758288"></a>14.4.4.3. reservation-del command</h4></div></div></div><p><span class="command"><strong>reservation-del</strong></span> can be used to delete a
          reservation from the host database. There are two types of parameters
          this command supports: (subnet-id, address) or (subnet-id,
          identifier-type, identifier). The first type of query is used when the
          address (either IPv4 or IPv6) is known, but the details of the
          reservation aren't. One common use case of this type of query is to
          remove a reservation (e.g. you want a specific address to no longer be
          reserved). The second query uses identifiers. For maximum flexibility,
          Kea stores the host identifying information as a pair of values: type
          and the actual identifier. Currently supported identifiers are
          "hw-address", "duid", "circuit-id", "client-id" and "flex-id", but
          additional types may be added in the future. If any new identifier
          types are defined in the future, reservation-get command will support
          them automatically.</p><p>
            An example command for deleting a host reservation by (subnet-id,
            address) pair looks as follows:
</p><pre class="screen">
{
    "command": "reservation-del",
    "arguments": {
        "subnet-id": 1,
        "ip-address": "192.0.2.202"
    }
}</pre><p>

An example deletion by (subnet-id, identifier-type, identifier) looks as follows:
</p><pre class="screen">
{
    "command": "reservation-del",
    "arguments":
        "subnet-id": 4,
        "identifier-type": "hw-address",
        "identifier": "01:02:03:04:05:06"
    }
}</pre><p>
          </p><p>
            <span class="command"><strong>reservation-del</strong></span> returns result 0 when the host
            deletion was successful or 1 if it was not. A descriptive text is
            provided in case of error. Example results look as follows:
</p><pre class="screen">
{
    "result": 1,
    "text": "Host not deleted (not found)."
}</pre><p>

</p><pre class="screen">
{
    "result": 0,
    "text": "Host deleted."
}</pre><p>

</p><pre class="screen">
{
    "result": 1,
    "text": "Unable to delete a host because there is no hosts-database
             configured."
}</pre><p>
          </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="lease-cmds"></a>14.4.5. lease_cmds: Lease Commands</h3></div></div></div><p>
          This section describes the hook library that offers a number of new
          commands used to manage leases. Kea provides a way to store lease
          information in several backends (memfile, MySQL, PostgreSQL and
          Cassandra). This library provides a unified interface that can
          manipulate leases in an unified, safe way. In particular, it allows
          things previously impossible: manipulate leases in memfile while Kea
          is running, sanity check changes, check lease existence and remove all
          leases belonging to specific subnet. It can also catch more obscure
          errors, like adding a lease with subnet-id that does not exist in the
          configuration or configuring a lease to use an address that is outside
          of the subnet to which it is supposed to belong.
        </p><p>There are many use cases when an administrative command may be
        useful: during migration between servers (possibly even between
        different vendors), when a certain network is being retired, when a
        device has been disconnected and the sysadmin knows for sure that it
        will not be coming back. The "get" queries may be useful for automating
        certain management and monitoring tasks. They can also act as
        preparatory steps for lease updates and removals.</p><p>
          This library provides the following commands:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>lease4-add</strong></span> - adds new IPv4 lease;</p></li><li class="listitem"><p><span class="command"><strong>lease6-add</strong></span> - adds new IPv6 lease;</p></li><li class="listitem"><p><span class="command"><strong>lease4-get</strong></span> - checks if an IPv4 lease with
              the specified parameters exists and returns it if it does;</p></li><li class="listitem"><p><span class="command"><strong>lease6-get</strong></span> - checks if an IPv6 lease with
              the specified parameters exists and returns it if it does;</p></li><li class="listitem"><p><span class="command"><strong>lease4-get-all</strong></span> - returns all IPv4 leases
              or IPv4 leases for specified subnets;</p></li><li class="listitem"><p><span class="command"><strong>lease6-get-all</strong></span> - returns all IPv6 leases
              or IPv6 leases for specified subnets;</p></li><li class="listitem"><p><span class="command"><strong>lease4-del</strong></span> - attempts to delete an IPv4
              lease with the specified parameters;</p></li><li class="listitem"><p><span class="command"><strong>lease6-del</strong></span> - attempts to delete an IPv6
              lease with the specified parameters;</p></li><li class="listitem"><p><span class="command"><strong>lease4-update</strong></span> - updates an IPv4 lease;</p></li><li class="listitem"><p><span class="command"><strong>lease6-update</strong></span> - updates an IPv6 lease;</p></li><li class="listitem"><p><span class="command"><strong>lease4-wipe</strong></span> - removes all leases from a
              specific IPv4 subnet or all subnets;</p></li><li class="listitem"><p><span class="command"><strong>lease6-wipe</strong></span> - removes all leases from a
              specific IPv6 subnet or all subnets;</p></li></ul></div><p>

        </p><p>Lease commands library is part of the open source code and is
        available to every Kea user.</p><p>
          All commands are using JSON syntax. They can be issued either using
          control channel (see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>) or via Control
          Agent (see <a class="xref" href="#kea-ctrl-agent" title="Chapter 7. Kea Control Agent">Chapter 7, <i>Kea Control Agent</i></a>).
        </p><p>
          The library can be loaded in the same way as other hook libraries. It
          does not take any parameters. It supports both DHCPv4 and DHCPv6
          servers.
</p><pre class="screen">
"Dhcp6": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_lease_cmds.so"
        }
        ...
    ] </code></strong>
}
</pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58789088"></a>14.4.5.1. lease4-add, lease6-add commands</h4></div></div></div><p>
          <span class="command"><strong>lease4-add</strong></span> and <span class="command"><strong>lease6-add</strong></span>
          commands allow for the creation of a new lease. Typically Kea creates a lease
          on its own, when it first sees a new device. However, sometimes it may
          be convenient to create the lease administratively. The
          <span class="command"><strong>lease4-add</strong></span> command requires at least three
          parameters: an IPv4 address, a subnet-id and an identifier: hardware
          (MAC) address. The simplest successful call might look as follows:
</p><pre class="screen">
{
    "command": "lease4-add",
    "arguments": {
        "subnet-id": 44,
        "ip-address": "192.0.2.202",
        "hw-address": "1a:1b:1c:1d:1e:1f"
    }
}
</pre><p>
        </p><p><span class="command"><strong>lease6-add</strong></span> command requires four
        parameters: an IPv6 address, a subnet-id, and IAID value
        (identity association identifier, a value sent by clients) and
        a DUID:
</p><pre class="screen">
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "ip-address": "2001:db8::3",
        "duid": "1a:1b:1c:1d:1e:1f:20:21:22:23:24",
        "iaid": 1234
    }
}</pre><p>

<span class="command"><strong>lease6-add</strong></span> can be also used to add leases for IPv6
prefixes. In this case there are two parameters that must be
specified: type (set to value of "IA_PD") and a prefix
length. The actual prefix is set using ip-address field. For example,
to configure a lease for prefix 2001:db8:abcd::/48, the following
command can be used:

</p><pre class="screen">
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "type": "IA_PD",
        "ip-address": "2001:db8:abcd::",
        "prefix-len": 48,
        "duid": "1a:1b:1c:1d:1e:1f:20:21:22:23:24",
        "iaid": 1234
    }
}</pre><p>

The commands can take a number of additional optional parameters:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>valid-lft</strong></span> - specifies the lifetime of the
              lease, expressed in seconds. If not specified, the value
              configured in the subnet related to specified subnet-id is
              used.</p></li><li class="listitem"><p><span class="command"><strong>expire</strong></span> - timestamp of the lease
              expiration time, expressed in unix format (seconds since 1 Jan
              1970). If not specified, the default value is now + valid
              lifetime.</p></li><li class="listitem"><p><span class="command"><strong>fqdn-fwd</strong></span> - specifies whether the lease
              should be marked as if forward DNS update was conducted. Note this
              only affects the lease parameter and the actual DNS update will
              not be conducted at the lease insertion time. If configured, a DNS
              update to remove the A or AAAA records will be conducted when the
              lease is removed due to expiration or being released by a
              client. If not specified, the default value is false. Hostname
              parameter must be specified in fqdn-fwd is set to true.</p></li><li class="listitem"><p><span class="command"><strong>fqdn-rev</strong></span> - specifies whether the lease
              should be marked as if reverse DNS update was conducted. Note this
              only affects the lease parameter and the actual DNS update will
              not be conducted at the lease insertion time. If configured, a DNS
              update to remove the PTR record will be conducted when the lease
              is removed due to expiration or being released by a client. If not
              specified, the default value is false. Hostname parameter must be
              specified in fqdn-fwd is set to true.</p></li><li class="listitem"><p><span class="command"><strong>hostname</strong></span> - specifies the hostname to be
              associated with this lease. Its value must be non-empty if either
              fqdn-fwd or fwdn-rev are set to true. If not specified, the
              default value is an empty string.</p></li><li class="listitem"><p><span class="command"><strong>hw-address</strong></span> - hardware (MAC) address can
              be optionally specified for IPv6 lease. It is mandatory parameter
              for IPv4 lease.</p></li><li class="listitem"><p><span class="command"><strong>client-id</strong></span> - client identifier is an
              optional parameter that can be specified for IPv4 lease.</p></li><li class="listitem"><p><span class="command"><strong>preferred-lft</strong></span> - Preferred lifetime is an
              optional parameter for IPv6 leases. If not specified, the value
              configured for the subnet corresponding to the specified subnet-id
              is used. This parameter is not used in IPv4.</p></li></ul></div><p>
        </p><p>Here's an example of more complex lease addition:

</p><pre class="screen">
{
    "command": "lease6-add",
    "arguments": {
        "subnet-id": 66,
        "ip-address": "2001:db8::3",
        "duid": "01:02:03:04:05:06:07:08",
        "iaid": 1234,
        "hw-address": "1a:1b:1c:1d:1e:1f",
        "preferred-lft": 500,
        "valid-lft": 1000,
        "expire": 12345678,
        "fqdn-fwd": true,
        "fqdn-rev": true,
        "hostname": "urania.example.org"
    }
}
</pre><p>
        </p><p>
          The command returns a status that indicates either a success (result
          0) or a failure (result 1). Failed command always includes text
          parameter that explains the cause of failure. Example results:
          </p><pre class="screen">{ "result": 0, "text": "Lease added." }</pre><p> Example failure:
          </p><pre class="screen">{ "result": 1, "text": "missing parameter 'ip-address' (&lt;string&gt;:3:19)" }</pre><p>
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp58811008"></a>14.4.5.1.1. lease4-get, lease6-get commands</h5></div></div></div><p><span class="command"><strong>lease4-get</strong></span> or <span class="command"><strong>lease6-get</strong></span>
          can be used to query the lease database and retrieve existing
          leases. There are two types of parameters the
          <span class="command"><strong>lease4-get</strong></span> supports: (address) or (subnet-id,
          identifier-type, identifier). There are two types for
          <span class="command"><strong>lease6-get</strong></span>: (address,type) or (subnet-id,
          identifier-type, identifier, IAID, type). The first type of query is
          used when the address (either IPv4 or IPv6) is known, but the details
          of the lease aren't. One common use case of this type of query is to
          find out whether a given address is being used or not. The second
          query uses identifiers. Currently supported identifiers for leases are:
          "hw-address" (IPv4 only), "client-id" (IPv4 only) and "duid" (IPv6 only).
          </p><p>
            An example <span class="command"><strong>lease4-get</strong></span> command for getting a lease
            by an IPv4 address looks as follows:
</p><pre class="screen">
{
    "command": "lease4-get",
    "arguments": {
        "ip-address": "192.0.2.1"
    }
}
</pre><p>
          </p><p>An example of the <span class="command"><strong>lease6-get</strong></span> query
          looks as follows:
</p><pre class="screen">
{
  "command": "lease6-get",
  "arguments": {
    "ip-address": "2001:db8:1234:ab::",
    "type": "IA_PD"
  }
}</pre><p>
          </p><p>An example query by "hw-address" for IPv4 lease looks
          as follows:
</p><pre class="screen">
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "hw-address",
        "identifier": "08:08:08:08:08:08",
        "subnet-id": 44
    }
}</pre><p>

          </p><p>An example query by "client-id" for IPv4 lease looks
          as follows:
</p><pre class="screen">
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "client-id",
        "identifier": "01:01:02:03:04:05:06",
        "subnet-id": 44
    }
}</pre><p>

          </p><p>An example query by (subnet-id, identifier-type,
          identifier, iaid, type) for IPv6 lease looks as follows:
</p><pre class="screen">
{
    "command": "lease4-get",
    "arguments": {
        "identifier-type": "duid",
        "identifier": "08:08:08:08:08:08",
        "iaid": 1234567,
        "type": "IA_NA",
        "subnet-id": 44
    }
}</pre><p>
The type is an optional parameter. Supported values are: IA_NA
(non-temporary address) and IA_PD (IPv6 prefix) are supported.
If not specified, IA_NA is assumed.
          </p><p><span class="command"><strong>leaseX-get</strong></span> returns a result that indicates a
          result of the operation and lease details, if found. It has one of the
          following values: 0 (success), 1 (error) or 2 (empty). The empty
          result means that a query has been completed properly, but the object
          (a lease in this case) has not been found. The lease parameters, if
          found, are returned as arguments.
          </p><p>
An example result returned when the host was found:
</p><pre class="screen">{
  "arguments": {
    "client-id": "42:42:42:42:42:42:42:42",
    "cltt": 12345678,
    "fqdn-fwd": false,
    "fqdn-rev": true,
    "hostname": "myhost.example.com.",
    "hw-address": "08:08:08:08:08:08",
    "ip-address": "192.0.2.1",
    "state": 0,
    "subnet-id": 44,
    "valid-lft": 3600
  },
  "result": 0,
  "text": "IPv4 lease found."
}</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp58823264"></a>14.4.5.1.2. lease4-get-all, lease6-get-all commands</h5></div></div></div><p><span class="command"><strong>lease4-get-all</strong></span> and
          <span class="command"><strong>lease6-get-all</strong></span> are used to retrieve all
          IPv4 or IPv6 leases or all leases for the specified set of
          subnets. All leases are returned when there are no arguments
          specified with the command as in the following example:
</p><pre class="screen">
{
    "command": "lease4-get-all"
}
</pre><p>
          </p><p>If the arguments are provided, it is expected that they contain
          "subnets" parameter, being a list of subnet identifiers for which the
          leases should be returned. For example, in order to retrieve all IPv6
          leases belonging to the subnets with identifiers 1, 2, 3 and 4:
</p><pre class="screen">
{
    "command": "lease6-get-all",
    "arguments": {
        "subnets": [ 1, 2, 3, 4 ]
    }
}
</pre><p>
          </p><p>
            The returned response contains a detailed list of leases in the
            following format:
</p><pre class="screen">{
    "arguments": {
        "leases": [
            {
                "cltt": 12345678,
                "duid": "42:42:42:42:42:42:42:42",
                "fqdn-fwd": false,
                "fqdn-rev": true,
                "hostname": "myhost.example.com.",
                "hw-address": "08:08:08:08:08:08",
                "iaid": 1,
                "ip-address": "2001:db8:2::1",
                "preferred-lft": 500,
                "state": 0,
                "subnet-id": 44,
                "type": "IA_NA",
                "valid-lft": 3600
            },
            {
                "cltt": 12345678,
                "duid": "21:21:21:21:21:21:21:21",
                "fqdn-fwd": false,
                "fqdn-rev": true,
                "hostname": "",
                "iaid": 1,
                "ip-address": "2001:db8:0:0:2::",
                "preferred-lft": 500,
                "prefix-len": 80,
                "state": 0,
                "subnet-id": 44,
                "type": "IA_PD",
                "valid-lft": 3600
            }
        ]
    },
    "result": 0,
    "text": "2 IPv6 lease(s) found."
}</pre><p>
          </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>The <span class="command"><strong>lease4-get</strong></span> and
            <span class="command"><strong>lease6-get</strong></span> commands may result in very
            large responses. This may have negative impact on the DHCP server
            responsiveness while the response is generated and transmitted
            over the control channel, as the server imposes no restriction
            on the number of leases returned as a result of this command.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp58832080"></a>14.4.5.1.3. lease4-del, lease6-del commands</h5></div></div></div><p><span class="command"><strong>leaseX-del</strong></span> can be used to delete a lease from
          the lease database. There are two types of parameters this command
          supports, similar to leaseX-get commands: (address) for both v4 and
          v6, (subnet-id, identifier-type, identifier) for v4 and (subnet-id,
          identifier-type, identifier, type, IAID) for v6. The first type of
          query is used when the address (either IPv4 or IPv6) is known, but the
          details of the lease are not. One common use case of this type of query
          is to remove a lease (e.g. you want a specific address to no longer be
          used, no matter who may use it). The second query uses
          identifiers. For maximum flexibility, this interface uses identifiers
          as a pair of values: type and the actual identifier. Currently
          supported identifiers are "hw-address" (IPv4 only), "client-id"
          (IPv4 only) and "duid" (IPv6 only), but additional types may be added
          in the future. </p><p>
            An example command for deleting a host reservation by address looks
            as follows:
</p><pre class="screen">
{
    "command": "lease4-del",
    "arguments": {
        "ip-address": "192.0.2.202"
    }
}</pre><p>

An example IPv4 lease deletion by "hw-address" looks as follows:

</p><pre class="screen">{
  "command": "lease4-del",
  "arguments": {
    "identifier": "08:08:08:08:08:08",
    "identifier-type": "hw-address",
    "subnet-id": 44
  }
}</pre><p>
          </p><p><span class="command"><strong>leaseX-del</strong></span> returns a result that
          indicates a outcome of the operation. It has one of the
          following values: 0 (success), 1 (error) or 3 (empty). The
          empty result means that a query has been completed properly,
          but the object (a lease in this case) has not been found.
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp58837232"></a>14.4.5.1.4. lease4-update, lease6-update commands</h5></div></div></div><p><span class="command"><strong>lease4-update</strong></span> and
          <span class="command"><strong>lease6-update</strong></span> commands can be used to update
          existing leases. Since all lease database backends are indexed by IP
          addresses, it is not possible to update an address. All other fields
          may be updated. If an address needs to be changed, please use
          <span class="command"><strong>leaseX-del</strong></span> followed by
          <span class="command"><strong>leaseX-add</strong></span> commands.</p><p>The optional boolean parameter "force-create" specifies
          if the lease should be created if it doesn't exist in the database.
          It defaults to false, which indicates that the lease is not created
          if it doesn't exist. In such case, an error is returned as a result
          of trying to update a non-existing lease. If the "force-create" parameter
          is set to true and the updated lease doesn't exist, the new lease is
          created as a result of receiving the <span class="command"><strong>leaseX-update</strong></span>.
          </p><p>
            An example command updating IPv4 lease looks as follows:
</p><pre class="screen">{
  "command": "lease4-update",
  "arguments": {
    "ip-address": "192.0.2.1",
    "hostname": "newhostname.example.org",
    "hw-address": "1a:1b:1c:1d:1e:1f",
    "subnet-id": 44,
    "force-create": true
  }
}</pre><p>
          </p><p>
            An example command updating IPv6 lease looks as follows:
</p><pre class="screen">{
  "command": "lease6-update",
  "arguments": {
    "ip-address": "2001:db8::1",
    "duid": "88:88:88:88:88:88:88:88",
    "iaid": 7654321,
    "hostname": "newhostname.example.org",
    "subnet-id": 66,
    "force-create": false
  }
}</pre><p>
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp58844144"></a>14.4.5.1.5. lease4-wipe, lease6-wipe commands</h5></div></div></div><p><span class="command"><strong>lease4-wipe</strong></span> and
          <span class="command"><strong>lease6-wipe</strong></span> are designed to remove all
          leases associated with a given subnet. This administrative
          task is expected to be used when existing subnet is being
          retired. Note that the leases are not properly expired,
          there are no DNS updates conducted, no log messages and
          hooks are not called for leases being removed.</p><p>An example of <span class="command"><strong>lease4-wipe</strong></span> looks as follows:
</p><pre class="screen">{
  "command": "lease4-wipe",
  "arguments": {
    "subnet-id": 44
  }
}</pre><p>
          </p><p>An example of <span class="command"><strong>lease6-wipe</strong></span> looks as follows:
</p><pre class="screen">{
  "command": "lease6-wipe",
  "arguments": {
    "subnet-id": 66
  }
}</pre><p>
          </p><p>The commands return a textual description of the
          number of leases removed and 0 (success) status code if any
          leases were removed and 2 (empty) if there were no
          leases. Status code 1 (error) may be returned in case the
          parameters are incorrect or some other exception is
          encountered.</p><p>The subnet-id 0 has special meaning. It tells Kea to
          delete leases from all configured subnets. Also, the
          subnet-id parameter may be omitted. If not specified, leases
          from all subnets are wiped.</p><p>Note: not all backends support this command.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="subnet-cmds"></a>14.4.6. subnet_cmds: Subnet Commands</h3></div></div></div><p>
          This section describes a hook application that offers a number of new
          commands used to query and manipulate subnet and shared network
          configurations in Kea.  This application is very useful in deployments
          with a large number of subnets being managed by the DHCP servers and
          when the subnets are frequently updated. The commands offer
          lightweight approach for manipulating subnets without a need to fully
          reconfigure the server and without affecting existing servers'
          configurations. An ability to manage shared networks (listing,
          retrieving details, adding new ones, removing existing ones, adding
          subnets to and removing from shared networks) is also provided.
        </p><p>Currently this library is only available to ISC customers with a
        support contract.</p><p>The following commands are currently supported:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><span class="command"><strong>subnet4-list/subnet6-list</strong></span>: lists all configured subnets
            </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>subnet4-get/subnet6-get</strong></span>: retrieves detailed information about a specified subnet
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>subnet4-add/subnet6-add</strong></span>: adds new subnet into server's configuration
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>subnet4-del/subnet6-del</strong></span>: removes a subnet from the server's configuration
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-list/network6-list</strong></span>: lists all configured
            shared networks
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-get/network6-get</strong></span>: retrieves detailed
            information about specified shared network
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-add/network6-add</strong></span>: adds a new shared
            network to the server's configuration
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-del/network6-del</strong></span>: removes a shared
            network from the server's configuration
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-subnet-add/network6-subnet-add</strong></span>: adds
            existing subnet to existing shared network
          </li><li class="listitem" style="list-style-type: disc">
            <span class="command"><strong>network4-subnet-del/network6-subnet-del</strong></span>: removes
            a subnet from existing shared network and demotes it to a plain
            subnet.
          </li></ul></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58869728"></a>14.4.6.1. subnet4-list command</h4></div></div></div><p>
            This command is used to list all currently configured subnets. The
            subnets are returned in a brief form, i.e. a subnet identifier
            and subnet prefix is included for each subnet. In order to retrieve
            the detailed information about the subnet the
            <span class="command"><strong>subnet4-get</strong></span> should be used.
          </p><p>
            This command has the simple structure:
</p><pre class="screen">
{
    "command": "subnet4-list"
}
</pre><p>
          </p><p>
            The list of subnets returned as a result of this command is returned
            in the following format:
</p><pre class="screen">
{
    "result": 0,
    "text": "2 IPv4 subnets found",
    "arguments": {
    "subnets": [
        {
            "id": 10,
            "subnet": "10.0.0.0/8"
        },
        {
            "id": 100,
            "subnet": "192.0.2.0/24"
        }
    ]
}
</pre><p>
          </p><p>
            If no IPv4 subnets are found, an error code is returned along with
            the error description.
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58874464"></a>14.4.6.2. subnet6-list command</h4></div></div></div><p>
            This command is used to list all currently configured subnets. The
            subnets are returned in a brief form, i.e. a subnet identifier
            and subnet prefix is included for each subnet. In order to retrieve
            the detailed information about the subnet the
            <span class="command"><strong>subnet6-get</strong></span> should be used.
          </p><p>
            This command has the simple structure:
</p><pre class="screen">
{
    "command": "subnet6-list"
}
</pre><p>
          </p><p>
            The list of subnets returned as a result of this command is returned
            in the following format:
</p><pre class="screen">
{
    "result": 0,
    "text": "2 IPv6 subnets found",
    "arguments": {
    "subnets": [
        {
            "id": 11,
            "subnet": "2001:db8:1::/64"
        },
        {
            "id": 233,
            "subnet": "3000::/16"
        }
    ]
}
</pre><p>
          </p><p>
            If no IPv6 subnets are found, an error code is returned along with
            the error description.
          </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58879296"></a>14.4.6.3. subnet4-get command</h4></div></div></div><p>This command is used to retrieve detailed information about the
        specified subnet. This command usually follows the
        <span class="command"><strong>subnet4-list</strong></span>, which is used to discover available
        subnets with their respective subnet identifiers and prefixes. Any of
        those parameters can be then used in <span class="command"><strong>subnet4-get</strong></span>
        to fetch subnet information:
</p><pre class="screen">
{
    "command": "subnet4-get",
    "arguments": {
        "id": 10
    }
}</pre><p>

or

</p><pre class="screen">
{
    "command": "subnet4-get",
    "arguments": {
        "subnet": "10.0.0.0/8"
    }
}
</pre><p>
        </p><p>
          If the subnet exists the response will be similar to this:
</p><pre class="screen">
{
    "result": 0,
    "text": "Info about IPv4 subnet 10.0.0.0/8 (id 10) returned",
    "arguments": {
        "subnets": [
            {
                "subnet": "10.0.0.0/8",
                "id": 1,
                "option-data": [
                    ....
                ]
                ...
            }
        ]
    }
}

</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58884064"></a>14.4.6.4. subnet6-get command</h4></div></div></div><p>This command is used to retrieve detailed information about the
        specified subnet. This command usually follows the
        <span class="command"><strong>subnet6-list</strong></span>, which is used to discover available
        subnets with their respective subnet identifiers and prefixes. Any of
        those parameters can be then used in <span class="command"><strong>subnet6-get</strong></span>
        to fetch subnet information:
</p><pre class="screen">
{
    "command": "subnet6-get",
    "arguments": {
        "id": 11
    }
}
</pre><p>

or

</p><pre class="screen">
{
    "command": "subnet6-get",
    "arguments": {
        "subnet": "2001:db8:1::/64"
    }
}</pre><p>

If the subnet exists the response will be similar to this:
</p><pre class="screen">
{
    "result": 0,
    "text": "Info about IPv6 subnet 2001:db8:1::/64 (id 11) returned",
    "arguments": {
        "subnets": [
            {
                "subnet": "2001:db8:1::/64",
                "id": 1,
                "option-data": [
                    ...
                ]
                ....
            }
        ]
    }
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58888304"></a>14.4.6.5. subnet4-add</h4></div></div></div><p>
          This command is used to create and add new subnet to the existing
          server configuration. This operation has no impact on other
          subnets. The subnet identifier must be specified and must be
          unique among all subnets. If the identifier or a subnet prefix is
          not unique an error is reported and the subnet is not added.
        </p><p>
          The subnet information within this command has the same structure
          as the subnet information in the server configuration file with the
          exception that static host reservations must not be specified
          within <span class="command"><strong>subnet4-add</strong></span>. The commands described in
          <a class="xref" href="#host-cmds" title="14.4.4. host_cmds: Host Commands">Section 14.4.4, “host_cmds: Host Commands”</a> should be used to add, remove and
          modify static reservations.
</p><pre class="screen">
{
    "command": "subnet4-add",
    "arguments": {
        "subnets": [ {
            "id": 123,
            "subnet": "10.20.30.0/24",
            ...
        } ]
    }
}
</pre><p>
        </p><p>
          The response to this command has the following structure:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv4 subnet added",
    "arguments": {
        "subnets": [
            {
                "id": 123,
                "subnet": "10.20.30.0/24"
            }
        ]
    }
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58893664"></a>14.4.6.6. subnet6-add</h4></div></div></div><p>
          This command is used to create and add new subnet to the existing
          server configuration. This operation has no impact on other
          subnets. The subnet identifier must be specified and must be
          unique among all subnets. If the identifier or a subnet prefix is
          not unique an error is reported and the subnet is not added.
        </p><p>
          The subnet information within this command has the same structure
          as the subnet information in the server configuration file with the
          exception that static host reservations must not be specified
          within <span class="command"><strong>subnet6-add</strong></span>. The commands described in
          <a class="xref" href="#host-cmds" title="14.4.4. host_cmds: Host Commands">Section 14.4.4, “host_cmds: Host Commands”</a> should be used to add, remove and
          modify static reservations.
</p><pre class="screen">
{
    "command": "subnet6-add",
    "arguments": {
        "subnet6": [ {
            "id": 234,
            "subnet": "2001:db8:1::/64",
            ...
        } ]
    }
}
</pre><p>
        </p><p>
          The response to this command has the following structure:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv6 subnet added",
    "arguments": {
        "subnet6": [
            {
                "id": 234,
                "subnet": "2001:db8:1::/64"
            }
        ]
    }
}
</pre><p>
        </p><p>
          It is recommended, but not mandatory to specify subnet
          id. If not specified, Kea will try to assign the next
          subnet-id value. This automatic ID value generator is
          simple. It returns a previously automatically assigned value
          increased by 1. This works well, unless you manually create
          a subnet with a value bigger than previously used. For
          example, if you call subnet4-add five times, each without
          id, Kea will assign IDs: 1,2,3,4 and 5 and it will work just
          fine. However, if you try to call subnet4-add five times,
          with the first subnet having subnet-id of value 3 and
          remaining ones having no subnet-id, it will fail. The first
          command (with explicit value) will use subnet-id 3, the
          second command will create a subnet with id of 1, the third
          will use value of 2 and finally the fourth will have the
          subnet-id value auto-generated as 3. However, since there is
          already a subnet with that id, it will fail.
        </p><p>
          The general recommendation is to either: never use explicit
          values (so the auto-generated values will always work) or
          always use explicit values (so the auto-generation is never
          used). You can mix those two approaches only if you
          understand how the internal automatic subnet-id generation works.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58901040"></a>14.4.6.7. subnet4-del command</h4></div></div></div><p>
          This command is used to remove a subnet from the server's configuration.
          This command has no effect on other configured subnets but removing
          a subnet has certain implications which the server's administrator
          should be aware of.
        </p><p>
          In most cases the server has assigned some leases to the clients
          belonging to the subnet. The server may also be configured with
          static host reservations which are associated with this subnet.
          The current implementation of the <span class="command"><strong>subnet4-del</strong></span>
          removes neither the leases nor host reservations associated with
          a subnet. This is the safest approach because the server doesn't
          loose track of leases assigned to the clients from this subnet.
          However, removal of the subnet may still cause configuration
          errors and conflicts. For example: after removal of the subnet,
          the server administrator may add a new subnet with the ID used
          previously for the removed subnet. This means that the existing
          leases and static reservations will be in conflict with this
          new subnet. Thus, we recommend that this command is used with extreme
          caution.
        </p><p>
          This command can also be used to completely delete an IPv4 subnet that
          is part of a shared network. If you want to simply remove the subnet
          from a shared network and keep the subnet configuration, use
          <span class="command"><strong>network4-subnet-del</strong></span> command instead.
        </p><p>The command has the following structure:
</p><pre class="screen">
{
    "command": "subnet4-del",
    "arguments": {
        "id": 123
    }
}
</pre><p>
        </p><p>
          The example successful response may look like this:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv4 subnet 192.0.2.0/24 (id 123) deleted",
    "arguments": {
        "subnets": [
            {
                "id": 123,
                "subnet": "192.0.2.0/24"
            }
        ]
    }
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58907776"></a>14.4.6.8. subnet6-del command</h4></div></div></div><p>
          This command is used to remove a subnet from the server's configuration.
          This command has no effect on other configured subnets but removing
          a subnet has certain implications which the server's administrator
          should be aware of.
        </p><p>
          In most cases the server has assigned some leases to the clients
          belonging to the subnet. The server may also be configured with
          static host reservations which are associated with this subnet.
          The current implementation of the <span class="command"><strong>subnet6-del</strong></span>
          removes neither the leases nor host reservations associated with
          a subnet. This is the safest approach because the server doesn't
          loose track of leases assigned to the clients from this subnet.
          However, removal of the subnet may still cause configuration
          errors and conflicts. For example: after removal of the subnet,
          the server administrator may add a new subnet with the ID used
          previously for the removed subnet. This means that the existing
          leases and static reservations will be in conflict with this
          new subnet. Thus, we recommend that this command is used with extreme
          caution.
        </p><p>
          This command can also be used to completely delete an IPv6 subnet that
          is part of a shared network. If you want to simply remove the subnet
          from a shared network and keep the subnet configuration, use
          <span class="command"><strong>network6-subnet-del</strong></span> command instead.
        </p><p>The command has the following structure:
</p><pre class="screen">
{
    "command": "subnet6-del",
    "arguments": {
        "id": 234
    }
}
</pre><p>
        </p><p>
          The example successful response may look like this:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv6 subnet 2001:db8:1::/64 (id 234) deleted",
    "subnets": [
        {
            "id": 234,
            "subnet": "2001:db8:1::/64"
        }
    ]
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58914528"></a>14.4.6.9. network4-list, network6-list commands</h4></div></div></div><p>
          These commands are used to retrieve full list of currently configured
          shared networks. The list contains only very basic information about
          each shared network. If more details are needed, please use
          <span class="command"><strong>network4-get</strong></span> or <span class="command"><strong>network6-get</strong></span> to
          retrieve all information available. This command does not require any
          parameters and its invocation is very simple:
</p><pre class="screen">
{
    "command": "network4-list"
}
</pre><p>
An example response for <span class="command"><strong>network4-list</strong></span> looks as follows:
</p><pre class="screen">
{
    "arguments": {
        "shared-networks": [
            { "name": "floor1" },
            { "name": "office" }
        ]
    },
    "result": 0,
    "text": "2 IPv4 network(s) found"
}</pre><p>
<span class="command"><strong>network6-list</strong></span> follows exactly the same syntax for
both the query and the response.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58919056"></a>14.4.6.10. network4-get, network6-get commands</h4></div></div></div><p>
          These commands are used to retrieve detailed information
          about shared networks, including subnets currently
          being part of a given network. Both commands take one
          mandatory parameter <span class="command"><strong>name</strong></span>, which specify
          the name of shared network. An example command to retrieve
          details about IPv4 shared network with a name "floor13"
          looks as follows:
</p><pre class="screen">
{
    "command": "network4-get",
    "arguments": {
        "name": "floor13"
    }
}</pre><p>
An example response could look as follows:
</p><pre class="screen">
{
    "result": 0,
    "text": "Info about IPv4 shared network 'floor13' returned",
    "arguments": {
        "shared-networks": [
        {
            "match-client-id": true,
            "name": "floor13",
            "option-data": [ ],
            "rebind-timer": 90,
            "relay": {
                "ip-address": "0.0.0.0"
            },
            "renew-timer": 60,
            "reservation-mode": "all",
            "subnet4": [
                {
                    "subnet": "192.0.2.0/24",
                    "id": 5,
                    // many other subnet specific details here
                },
                {
                    "id": 6,
                    "subnet": "192.0.3.0/31",
                    // many other subnet specific details here
                }
            ],
            "valid-lifetime": 120
        }
        ]
    }
}
</pre><p>
Note that actual response contains many additional fields that are
omitted here for clarity. The response format is exactly the same as
used in <span class="command"><strong>config-get</strong></span>, just is limited to returning
shared networks information.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58923728"></a>14.4.6.11. network4-add, network6-add commands</h4></div></div></div><p>
          These commands are used to add a new shared network. New
          network has to have unique name. This command requires one parameter
          <span class="command"><strong>shared-networks</strong></span>, which is a list and
          should contain exactly one entry that defines the
          network. The only mandatory element for a network is its
          name. Although it does not make operational sense, it is
          allowed to add an empty shared network that does not have
          any subnets in it. That is allowed for testing purposes, but
          having empty networks (or with only one subnet) is
          discouraged in production environments. For details regarding
          syntax, see <a class="xref" href="#shared-network4" title="8.4. Shared networks in DHCPv4">Section 8.4, “Shared networks in DHCPv4”</a> and <a class="xref" href="#shared-network6" title="9.4. Shared networks in DHCPv6">Section 9.4, “Shared networks in DHCPv6”</a>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As opposed to parameter inheritance during full
          new configuration processing, this command does not fully handle
          parameter inheritance and any missing parameters will be
          filled with default values, rather than inherited from
          global scope.</p></div><p>
          An example that showcases how to add a new IPv4 shared network looks
          as follows:
</p><pre class="screen">
{
    "command": "network4-add",
    "arguments": {
        "shared-networks": [ {
            "name": "floor13",
            "subnet4": [
            {
                "id": 100,
                "pools": [ { "pool": "192.0.2.2-192.0.2.99" } ],
                "subnet": "192.0.2.0/24",
                "option-data": [
                    {
                        "name": "routers",
                        "data": "192.0.2.1"
                    }
                ]
            },
            {
                "id": 101,
                "pools": [ { "pool": "192.0.3.2-192.0.3.99" } ],
                "subnet": "192.0.3.0/24",
                "option-data": [
                    {
                        "name": "routers",
                        "data": "192.0.3.1"
                    }
                ]
            } ]
        } ]
    }
}
</pre><p>
Assuming there was no shared network with a name floor13 and no subnets with id
100 and 101 previously configured, the command will be successful and will
return the following response:
</p><pre class="screen">
{
    "arguments": {
        "shared-networks": [ { "name": "floor13" } ]
    },
    "result": 0,
    "text": "A new IPv4 shared network 'floor13' added"
}
</pre><p>
The <span class="command"><strong>network6-add</strong></span> uses the same syntax for both the query and
the response. However, there are some parameters that are IPv4-only
(e.g. match-client-id) and some are IPv6-only (e.g. interface-id). The same
applies to subnets within the network.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58931536"></a>14.4.6.12. network4-del, network6-del commands</h4></div></div></div><p>
          These commands are used to delete existing shared
          networks. Both commands take exactly one parameter 'name' that
          specifies the name of the network to be removed. An example invocation
          of <span class="command"><strong>network4-del</strong></span> command looks as follows:
</p><pre class="screen">
{
    "command": "network4-del",
    "arguments": {
        "name": "floor13"
    }
}
</pre><p>
Assuming there was such a network configured, the response will look similar to
the following:
</p><pre class="screen">
{
    "arguments": {
        "shared-networks": [
            {
                "name": "floor13"
            }
        ]
    },
    "result": 0,
    "text": "IPv4 shared network 'floor13' deleted"
}</pre><p>
The <span class="command"><strong>network6-del</strong></span> command uses exactly the same syntax for
both the command and the response.
        </p><p>If there are any subnets belonging to the shared network
        being deleted, they will be demoted to a plain subnet. There
        is an optional parameter called
        <span class="command"><strong>subnets-action</strong></span> that, if specified, takes
        one of two possible values: <span class="command"><strong>keep</strong></span> (which is
        the default) and <span class="command"><strong>delete</strong></span>. It controls
        whether the subnets be demoted to plain subnets or removed. An
        example usage in network6-del command that deletes the shared
        network and all subnets in it could looks like as follows:
</p><pre class="screen">
{
    "command": "network4-del",
    "arguments": {
        "name": "floor13",
        "subnets-action": "delete"
    }
}
</pre><p>
        </p><p>Alternatively, if you want to completely remove the
        subnets, you may use <span class="command"><strong>subnet4-del</strong></span> or
        <span class="command"><strong>subnet6-del</strong></span> commands.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58939520"></a>14.4.6.13. network4-subnet-add, network6-subnet-add commands</h4></div></div></div><p>
          These commands are used to add existing subnets to existing shared
          networks. There are several ways to add new shared network. System
          administrator can add the whole shared network at once, either by
          editing a configuration file or by calling
          <span class="command"><strong>network4-add</strong></span> or <span class="command"><strong>network6-add</strong></span>
          commands with desired subnets in it. This approach works better for completely
          new shared subnets. However, there may be cases when an existing
          subnet is running out of addresses and needs to be extended with
          additional address space. In other words another subnet has to be
          added on top of it. For this scenario, a system administrator can use
          <span class="command"><strong>network4-add</strong></span> or <span class="command"><strong>network6-add</strong></span> and
          then add existing subnet to this newly created shared network  using
          <span class="command"><strong>network4-subnet-add</strong></span> or
          <span class="command"><strong>network6-subnet-add</strong></span>.
        </p><p>
          The <span class="command"><strong>network4-subnet-add</strong></span> and
          <span class="command"><strong>network6-subnet-add</strong></span> commands take two parameters:
          <span class="command"><strong>id</strong></span>, which is an integer and specifies subnet-id of existing subnet to
          be added to a shared network; and <span class="command"><strong>name</strong></span>, which
          specifies name of the shared network the subnet will be added to. The
          subnet must not belong to any existing network. In case you want to
          reassign a subnet from one shared network to another, please use
          <span class="command"><strong>network4-subnet-del</strong></span> or
          <span class="command"><strong>network6-subnet-del</strong></span> commands first.
        </p><p>
          An example invocation of <span class="command"><strong>network4-subnet-add</strong></span>
          command looks as follows:
</p><pre class="screen">
{
    "command": "network4-subnet-add",
    "arguments": {
        "name": "floor13",
        "id": 5
    }
}</pre><p>
Assuming there is a network named 'floor13', there is a subnet with subnet-id 5
and it is not a part of existing network, the command will return a response
similar to the following:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv4 subnet 10.0.0.0/8 (id 5) is now part of shared network 'floor1'"
}</pre><p>
        The <span class="command"><strong>network6-subnet-add</strong></span> command uses exactly the same syntax for
both the command and the response.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>As opposed to parameter inheritance during full
          new configuration processing or when adding a new shared network with
          new subnets, this command does not fully handle
          parameter inheritance and any missing parameters will be
          filled with default values, rather than inherited from
          global scope or from the shared network.</p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58950496"></a>14.4.6.14. network4-subnet-del, network6-subnet-del commands</h4></div></div></div><p>
          These commands are used to remove a subnet that is part of existing shared
          network and demote it to a plain, stand-alone subnet. If you want to
          remove a subnet completely, use <span class="command"><strong>subnet4-del</strong></span> or
          <span class="command"><strong>subnet6-del</strong></span> commands instead.
          The <span class="command"><strong>network4-subnet-del</strong></span> and
          <span class="command"><strong>network6-subnet-del</strong></span> commands take two parameters:
          <span class="command"><strong>id</strong></span>, which is an integer and specifies subnet-id of
          existing subnet to be removed from a shared network; and
          <span class="command"><strong>name</strong></span>, which specifies name of the shared network
          the subnet will be removed from.
        </p><p>An example invocation of the
        <span class="command"><strong>network4-subnet-del</strong></span> command looks as follows:
 </p><pre class="screen">
 {
    "command": "network4-subnet-del",
    "arguments": {
        "name": "floor13",
        "id": 5
    }
 }</pre><p>
 Assuming there was a subnet with subnet-id equal to 5 that was part of a shared
 network named 'floor13', the response would look similar to the following:
</p><pre class="screen">
{
    "result": 0,
    "text": "IPv4 subnet 10.0.0.0/8 (id 5) is now removed from shared network 'floor13'"
}</pre><p>
The <span class="command"><strong>network6-subnet-del</strong></span> command uses exactly the same syntax for
both the command and the response.
        </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="high-availability-library"></a>14.4.7. ha: High Availability</h3></div></div></div><p>
        This section describes the High Availability hooks library, which can be
        loaded on a pair of DHCPv4 or DHCPv6 servers to increase reliability of
        the DHCP service in case of outage of one of the servers. This library
        is only available to ISC customers.
      </p><p>
        High Availability (HA) of the DHCP service is provided by running multiple
        cooperating server instances. If any of these instances becomes
        unavailable for whatever reason (DHCP software crash, Control Agent
        software crash, power outage, hardware failure), a surviving
        server instance can continue providing the reliable service to the clients. Many
        DHCP servers implementations include "DHCP Failover" protocol, which most
        significant features are: communication between the servers, partner
        failure detection and leases synchronization between the servers.
        However, the DHCPv4 failover standardization process was never completed
        at IETF. The DHCPv6 failover standard (RFC 8156) was published, but it
        is complex, difficult to use, has significant operational constraints
        and is different than its v4 counterpart.
        Although it may be useful for some users to use a "standard" failover
        protocol, it seems that most of the Kea users are simply interested in
        a working solution which guarantees high availability of the DHCP
        service. Therefore, Kea HA hook library derives major concepts from the
        DHCP Failover protocol but uses its own solutions for communication,
        configuration and its own state machine, which greatly simplifies its
        implementation and generally better fits into Kea. Also, it provides the
        same features in both DHCPv4 and DHCPv6. This document purposely
        uses the term "High Availability" rather than "Failover" to emphasize that
        it is not the Failover protocol implementation.
      </p><p>
        The following sections describe the configuration and operation of the Kea
        HA hook library.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58963248"></a>14.4.7.1. Supported Configurations</h4></div></div></div><p>The Kea HA hook library supports two configurations also known as HA
        modes: load balancing and hot standby. In the load balancing mode, there
        are two servers responding to the DHCP requests. The load balancing function
        is implemented as described in RFC3074, with each server responding to
        1/2 of received DHCP queries. When one of the servers allocates a lease
        for a client, it notifies the partner server over the control channel
        (RESTful API), so as the partner can save the lease information in its
        own database. If the communication with the partner is unsuccessful,
        the DHCP query is dropped and the response is not returned to the DHCP
        client. If the lease update is successful, the response is returned to
        the DHCP client by the server which has allocated the lease. By
        exchanging the lease updates, both servers get a copy of all leases
        allocated by the entire HA setup and any of the servers can be switched
        to handle the entire DHCP traffic if its partner becomes unavailable.</p><p>In the load balancing configuration, one of the servers must be
        designated as "primary" and the other server is designated as "secondary".
        Functionally, there is no difference between the two during the normal
        operation. This distniction is required when the two servers are
        started at (nearly) the same time and have to synchronize their
        lease databases. The primary server synchronizes the database first.
        The secondary server waits for the primary server to complete the
        lease database synchronization before it starts the synchronization.
        </p><p>In the hot standby configuration one of the servers is designated as
        "primary" and the second server is designated as "secondary". During the
        normal operation, the primary server is the only one that responds to
        the DHCP requests. The secodary server receives lease updates from the
        primary over the control channel. However, it does not respond to any
        DHCP queries as long as the primary is running or, more accurately,
        until the secondary considers the primary to be offline. When the
        secondary server detects the failure of the primary, it starts
        responding to all DHCP queries.
        </p><p>In the configurations described above, the primary, secondary and
        standby are referred to as "active" servers, because they receive
        lease updates and can automatically react to the partner's failures by
        responding to the DHCP queries which would normally be handled by the
        partner. The HA hook library supports another server type (role) -
        backup server. The use of the backup servers is optional. They can be used
        in both load balancing and hot standby setup, in addition to the active
        servers. There is no limit on the number of backup servers in the HA
        setup. However, the presence of the backup servers increases latency
        of the DHCP responses, because not only do active servers send lease
        updates to each other, but also to the backup servers.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp58967904"></a>14.4.7.2. Server States</h4></div></div></div><p>The DHCP server operating within an HA setup runs a state machine
        and the state of the server can be retrieved by its peers using the
        <span class="command"><strong>ha-heartbeat</strong></span> command sent over the RESTful API. If
        the partner server doesn't respond to the <span class="command"><strong>ha-heartbeat</strong></span>
        command longer than configured amount of time, the communication is
        considered interrupted and the server may (depending on the configuration)
        use additional measures (desribed further in this document) to verify if
        the partner is still operating. If it finds that the partner is not
        operating, the server transitions to the <span class="command"><strong>partner-down</strong></span>
        state to handle the entire DHCP traffic directed to the system.</p><p>In this case, the surviving server continues to send the
        <span class="command"><strong>ha-heartbeat</strong></span> command to detect when the partner wakes
        up. The partner synchronizes the lease database and when it is finally
        ready to operate, the surviving server returns to the normal operation,
        i.e. <span class="command"><strong>load-balancing</strong></span> or <span class="command"><strong>hot-standby</strong></span>
        state.</p><p>The following is the list of all possible states into which the
        servers may transition:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>backup</strong></span> - normal operation of the
          backup server. In this state it receives lease updates from the active
          servers.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>hot-standby</strong></span> - normal operation of
          the active server running in the hot standby mode. Both primary and
          standby server are in this state during their normal operation.
          The primary server is responding to the DHCP queries and sends lease updates
          to the standby server and to the backup servers, if any backup servers
          are present.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>load-balancing</strong></span> - normal operation
          of the active server running in the load balancing mode. Both primary
          and secondary server are in this state during their normal operation.
          Both servers are responding to the DHCP queries and send lease updates
          to each other and to the backup servers, if any backup servers are
          present.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>partner-down</strong></span> - an active server
          transitions to this state after detecting that its partner (another
          active server) is offline. The server doesn't transition to this state
          if any of the backup servers is unavailable. In the <span class="command"><strong>
          partner-down</strong></span> state the server responds to all DHCP queries,
          so also those queries which are normally handled by the active server
          which is now unavailable.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>ready</strong></span> - an active server transitions
          to this state after synchronizing its lease database with an active
          partner. This state is to indicate to the partner (likely being in the
          <span class="command"><strong>partner-down</strong></span> state that it may return to the
          normal operation. When it does, the server being in the <span class="command"><strong>
          ready</strong></span> state will also start normal operation.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>syncing</strong></span> - an active server
          transitions to this state to fetch leases from the active partner
          and update the local lease database. When it this state, it
          issues the <span class="command"><strong>dhcp-disable</strong></span> to disable the DHCP
          service of the partner from which the leases are fetched. The DHCP
          servie is disabled for the maximum time of 60 seconds, after which
          it is automatically enabled, in case the syncing partner has died
          again failing to re-enable the service. If the synchronization is
          completed the syncing server issues the <span class="command"><strong>dhcp-enable
          </strong></span> to re-enable the DHCP service of the partner. The
          syncing operation is synchronous. The server is waiting for an
          answer from the partner and is not doing anything else while the
          leases synchronization takes place.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>waiting</strong></span> - each started server
          instance enters this state. The backup server will transition
          directly from this state to the <span class="command"><strong>backup</strong></span> state.
          An active server will send heartbeat to its partner to check its
          state. If the partner appears to be unavailable the server will
          transition to the <span class="command"><strong>partner-down</strong></span>, otherwise it
          will transition to the <span class="command"><strong>syncing</strong></span> state and attempt
          to synchronize the lease database. If both servers appear to be
          in this state (concurrent startup) the primary server will
          synchronize first. The secondary or standby server will remain
          in the <span class="command"><strong>waiting</strong></span> state until the primary
          synchronizes the database.</p></li></ul></div><p>

        Whether the server responds to the DHCP queries and which
        queries it responds to is a matter of the server's state, if no
        administrative action is performed to configure the server
        otherwise. The following table provides the default behavior for
        various states.</p><p>The <span class="command"><strong>DHCP Server Scopes</strong></span> denotes what group
        of received DHCP queries the server responds to in the given state.
        The in-depth explanation what the scopes are can be found below.
        </p><p>
          </p><div class="table"><a name="ha-default-states-behavior"></a><p class="title"><b>Table 14.2. Default behavior of the server in various HA states</b></p><div class="table-contents"><table summary="Default behavior of the server in various HA states" border="1"><colgroup><col class="state"><col align="center" class="server type"><col align="center" class="dhcp-service"><col align="center" class="dhcp-service-scopes"></colgroup><thead><tr><th>State</th><th align="center">Server Type</th><th align="center">DHCP Service</th><th align="center">DHCP Service Scopes</th></tr></thead><tbody><tr><td>backup</td><td align="center">backup server</td><td align="center">disabled</td><td align="center">none</td></tr><tr><td>hot-standby</td><td align="center">primary or standby (hot standby mode)</td><td align="center">enabled</td><td align="center"><span class="command"><strong>ha_server1</strong></span> if primary, none otherwise</td></tr><tr><td>load-balancing</td><td align="center">primary or secondary (load balancing mode)</td><td align="center">enabled</td><td align="center"><span class="command"><strong>ha_server1</strong></span> or <span class="command"><strong>ha_server2</strong></span></td></tr><tr><td>partner-down</td><td align="center">active server</td><td align="center">enabled</td><td align="center">all scopes</td></tr><tr><td>ready</td><td align="center">active server</td><td align="center">disabled</td><td align="center">none</td></tr><tr><td>syncing</td><td align="center">active server</td><td align="center">disabled</td><td align="center">none</td></tr><tr><td>waiting</td><td align="center">any server</td><td align="center">disabled</td><td align="center">none</td></tr></tbody></table></div></div><p><br class="table-break">
        </p><p>The DHCP service scopes require some explanation. The HA
        configuration must specify a unique name for each server within
        the HA setup. This document uses the following convention within
        provided examples: <span class="command"><strong>server1</strong></span> for a primary server,
        <span class="command"><strong>server2</strong></span> for the secondary or standby server and
        <span class="command"><strong>server3</strong></span> for the backup server. In the real life
        any names can be used as long as they remain unique.</p><p>In the load balancing mode there are two scopes named after
        the active servers: <span class="command"><strong>ha_server1</strong></span> and <span class="command"><strong>
        ha_server2</strong></span>. The DHCP queries load balanced to the
        <span class="command"><strong>server1</strong></span> belong to the <span class="command"><strong>ha_server1</strong></span>
        scope and the queries load balanced to the <span class="command"><strong>server2</strong></span>
        belong to the <span class="command"><strong>ha_server2</strong></span> scope. If any of the
        servers is in the <span class="command"><strong>partner-down</strong></span> state, it is
        responsible for serving both scopes.</p><p>In the hot standby mode, there is only one scope <span class="command"><strong>
        ha_server1</strong></span> because only the <span class="command"><strong>server1</strong></span>
        is responding to the DHCP queries. If that server becomes unavailable,
        the <span class="command"><strong>server2</strong></span> becomes responsible for this scope.
        </p><p>The backup servers do not have their own scopes. In some
        cases they can be used to respond to the queries belonging to
        the scopes of the active servers. Also, a server which is neither
        in the partner-down state nor in the normal operation serves
        no scopes.</p><p>The scope names can be used to associate pools, subnets
        and networks with certain servers, so as only these servers
        can allocate addresses or prefixes from those pools, subnets
        or network. This is done via the client classification mechanism
        (see below).</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-scope-transition"></a>14.4.7.3. Scope Transition in Partner Down Case</h4></div></div></div><p>When one of the servers finds that its partner is unavailble,
        it will start serving clients from its own scope and the scope of the
        partner which is considered unavailable. This is straight forward
        for the new clients, i.e. sending DHCPDISCOVER (DHCPv4) or Solicit
        (DHCPv6), because those requests are not sent to any particular server.
        The available server will respond to all such queries when it is
        in the <span class="command"><strong>partner-down</strong></span> state.</p><p>When the client is renewing a lease, it will send its
        DHCPREQUEST (DHCPv4) or Renew (DHCPv6) message directly to the
        server which has allocated the lease being renewed. Because this
        server is unavailable, the client will not get any response. In
        that case, the client continues to use its lease and re-tries to
        renew until the rebind timer (T2) elapses. The client will now enter
        the rebinding phase, in which it will send DHCPREQUEST (DHCPv4) or
        Rebind (DHCPv6) message to any available server. The surviving
        server will receive the rebinding request and will (typically)
        extend the lifetime of the lease. The client will continue to
        contact that new server to renew its lease as appropriate.</p><p>When the other server becomes available, both active servers
        will eventually transition to the <span class="command"><strong>load-balancing</strong></span>
        or <span class="command"><strong>hot-standby</strong></span> state, in which they will be
        responsible for their own scopes. Some clients belonging to the
        scope of the started server will be trying to renew their leases
        via the surviving server. This server will not respond to them
        anymore and the client will eventually transition back to the
        right server via rebinding mechanism again.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-load-balancing-config"></a>14.4.7.4. Load Balancing Configuration</h4></div></div></div><p>The following is the configuration snippet which enables
        high availability on the primary server within the load balancing
        configuration. The same configuration should be applied on the
        secondary and the backup server, with the only difference that
        the <span class="command"><strong>this-server-name</strong></span> should be set to
        <span class="command"><strong>server2</strong></span> and <span class="command"><strong>server3</strong></span>
        on those servers respectively.
</p><pre class="screen">
{
"Dhcp4": {

    ...

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {
                    "this-server-name": "server1",
                    "mode": "load-balancing",
                    "heartbeat-delay": 10000,
                    "max-response-delay": 10000,
                    "max-ack-delay": 5000,
                    "max-unacked-clients": 5,
                    "peers": [
                        {
                            "name": "server1",
                            "url": "http://192.168.56.33:8080/",
                            "role": "primary",
                            "auto-failover": true
                        },
                        {
                            "name": "server2",
                            "url": "http://192.168.56.66:8080/",
                            "role": "secondary",
                            "auto-failover": true
                        },
                        {
                            "name": "server3",
                            "url": "http://192.168.56.99:8080/",
                            "role": "backup",
                            "auto-failover": false
                        }
                    ]
                } ]
            }
        }
    ],

    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [
                {
                    "pool": "192.0.3.100 - 192.0.3.150",
                    "client-class": "ha_server1"
                },
                {
                    "pool": "192.0.3.200 - 192.0.3.250",
                    "client-class": "ha_server2"
                }
            ],

            "option-data": [
                {
                    "name": "routers",
                    "data": "192.0.3.1"
                }
            ],

            "relay": { "ip-address": "10.1.2.3" }
        }
    ],

    ...

}

}
</pre><p>
        </p><p>Two hook libraries must be loaded to enable HA:
        <code class="filename">libdhcp_lease_cmds.so</code> and
        <code class="filename">libdhcp_ha.so</code>. The latter provides the
        implemenation of the HA feature. The former enables control
        commands required by HA to fetch and manipulate leases on the
        remote servers. In the example provided above, it is assumed that
        Kea libraries are installed in the <code class="filename">/usr/lib</code>
        directory. If Kea is not installed in the /usr directory, the
        hook libraries locations must be updated accordingly.
        </p><p>The HA configuration is specified within the scope of the
        <code class="filename">libdhcp_ha.so</code>. Note that the top level
        parameter <span class="command"><strong>high-availability</strong></span> is a list, even
        though it currently contains only one entry. In the future this
        configuration is likely to be extended to contain more entries,
        if the particular server can participate in more than one
        HA relationships.</p><p>The following are the global parameters which control the server's
        behavior with respect to HA:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>this-server-name</strong></span> - is a unique
          identifier of the server within this HA setup. It must match with one
          of the servers specified within <span class="command"><strong>peers</strong></span> list.
          </p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>mode</strong></span> - specifies a HA mode
          of operation. Currently supported modes are <span class="command"><strong>load-balancing
          </strong></span> and <span class="command"><strong>hot-standby</strong></span>.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>heartbeat-delay</strong></span> - specifies
          a duration in milliseconds between the last heartbeat (or other command sent
          to the partner) and sending the next heartbeat. The heartbeats are sent
          periodically to gather the status of the partner and to verify whether
          the partner is still operating. The default value of this parameter is
          10000 ms.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>max-response-delay</strong></span> - specifies a
          duration in milliseconds since the last successful communication with the
          partner, after which the server assumes that the communication with
          the partner is interrupted. This duration should be greater than
          the <span class="command"><strong>heartbeat-delay</strong></span>. Usually it is a greater than
          the duration of multiple <span class="command"><strong>heartbeat-delay</strong></span> values.
          When the server detects that the communication is interrupted, it
          may transition to the <span class="command"><strong>partner-down</strong></span> state (when
          <span class="command"><strong>max-unacked-clients</strong></span> is 0) or trigger failure
          detection procedure using the values of the two parameters below.
          The default value of this parameter is 60000.
          </p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>max-ack-delay</strong></span> - is one of
          the parameters controlling partner failure detection. When the
          communication with the partner is interrupted, the server examines values
          of the <span class="command"><strong>secs</strong></span> field (DHCPv4) or <span class="command"><strong>Elapsed Time
          </strong></span> option (DHCPv6) which denote how long the DHCP client has been
          trying to communicate with the DHCP server. This parameter specifies the
          maximum time in milliseconds for the client to try to communicate with the
          DHCP server, after which this server assumes that the client failed to
          communicate with the DHCP server (is "unacked"). The default value of
          this parameter is 10000.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>max-unacked-clients</strong></span> - specifies
          how many "unacked" clients are allowed (see <span class="command"><strong>max-ack-delay</strong></span>)
          before this server assumes that the partner is offline and transitions
          to the <span class="command"><strong>partner-down</strong></span> state. The special value of 0
          is allowed for this parameter which disables failure detection
          mechanism. In this case, the server which can't communicate with the
          partner over the control channel assumes that the partner server is
          down and transitions to the <span class="command"><strong>partner-down</strong></span> state
          immediately. The default value of this parameter is 10.</p></li></ul></div><p>
        </p><p>
          The values of <span class="command"><strong>max-ack-delay</strong></span> and
          <span class="command"><strong>max-unacked-clients</strong></span> must be selected carefully, taking
          into account specifics of the network in which DHCP servers are
          operating. Note that the server in question may not respond to some
          of the DHCP clients because these clients are not to be serviced
          by this server (per administrative policy). The server may also
          drop malformed queries from the clients. Therefore, selecting too
          low value for the <span class="command"><strong>max-unacked-clients</strong></span> may
          result in transitioning to the <span class="command"><strong>partner-down</strong></span>
          state even though the partner is still operating. On the other
          hand, selecting too high value may result in never transitioning
          to the <span class="command"><strong>partner-down</strong></span> state if the DHCP
          traffic in the network is very low (e.g. night time), because the
          number of distinct clients trying to communicate with the server
          could be lower than <span class="command"><strong>max-unacked-clients</strong></span>.
        </p><p>In some cases it may be useful to disable the failure detection
        mechanism altogether, if the servers are located very close to each
        other and the network partitioning is unlikely, i.e. failure to
        respond to heartbeats is only possible when the partner is offline.
        In such cases, set the <span class="command"><strong>max-unacked-clients</strong></span> to 0.
        </p><p>The <span class="command"><strong>peers</strong></span> parameter contains a list of servers
        within this HA setup. In this configuration it must contain at least
        one primary and one secondary server. It may also contain unlimited
        number of backup servers. In this example there is one backup server
        which receives lease updates from the active servers.</p><p>There are the following parameters specified for each of the
        peers within this list:

        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>name</strong></span> - specifies unique name for
          the server.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>url</strong></span> - specifies URL to be used to
          contact this server over the control channel. Other servers use this
          URL to send control commands to that server.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>role</strong></span> - denotes the role of the
          server in the HA setup. The following roles are supported in the
          load balancing configuration: <span class="command"><strong>primary</strong></span>,
          <span class="command"><strong>secondary</strong></span> and <span class="command"><strong>backup</strong></span>.
          There must be exactly one primary and one secondary server in the
          load balancing setup.</p></li><li class="listitem" style="list-style-type: disc"><p><span class="command"><strong>auto-failover</strong></span> - a boolean value
          which denotes whether the server detecting a partner's failure should
          automatically start serving partner's clients. The default value of
          this parameter is true.</p></li></ul></div><p>
        </p><p>In our example configuration, both active servers can allocate
        leases from the subnet "192.0.3.0/24". This subnet contains two
        address pools: "192.0.3.100 - 192.0.3.150" and "192.0.3.200 - 192.0.3.250",
        which are associated with HA servers scopes using client classification.
        When the <span class="command"><strong>server1</strong></span> processes a DHCP query it will use
        the first pool for the lease allocation. Conversely, when the
        <span class="command"><strong>server2</strong></span> is processing the DHCP query it will use the
        second pool. When any of the servers is in the <span class="command"><strong>partner-down
        </strong></span> state, it can serve leases from both pools and it will
        select the pool which is appropriate for the received query. In
        other words, if the query would normally be processed by the
        <span class="command"><strong>server2</strong></span>, but this server is not available, the
        <span class="command"><strong>server1</strong></span> will allocate the lease from the pool of
        "192.0.3.200 - 192.0.3.250".
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-load-balancing-advanced-config"></a>14.4.7.5. Load Balancing with Advanced Classification</h4></div></div></div><p>In the previous section we have provided an example which demonstrated
        the load balancing configuration with the client classification limited
        to the use of <span class="command"><strong>ha_server1</strong></span> and <span class="command"><strong>ha_server2</strong></span>
        classes, which are dynamically assigned to the received DHCP queries.
        In many cases it will be required to use HA in deployments which already
        use some client classification.
        </p><p>
          Suppose there is a system which classifies devices into two groups:
          phones and laptops, based on some classification criteria specified in
          Kea configuration file. Both types of devices are allocated leases
          from different address pools. Introducing HA in the load balancing mode
          is expected to result in further split of each of those pools, so as
          each of the servers can allocate leases for some part of the phones
          and part of the laptops. This requires that each of the existing pools
          should be split between the <span class="command"><strong>ha_server1</strong></span> and
          <span class="command"><strong>ha_server2</strong></span>, so we end up with the following classes:

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">phones_server1</li><li class="listitem">laptops_server1</li><li class="listitem">phones_server2</li><li class="listitem">laptops_server2</li></ul></div><p>
        </p><p>The corresponding server configuration using advanced classification
        (and <span class="command"><strong>member</strong></span> expression) is provided below. For brevity
        the HA hook library configuration has been removed from this example.
</p><pre class="screen">
{
"Dhcp4": {

    "client-classes": [
        {
            // No test expression for this class. Incoming packets will be
            // assigned to that class dynamically by the HA Hook library.
            "name": "ha_server1"
        },
        {
            // No test expression for this class. Incoming packets will be
            // assigned to that class dynamically by the HA Hook library.
            "name": "ha_server2"
        },
        {
            "name": "phones",
            "test": "substring(option[60].hex,0,6) == 'Aastra'",
        },
        {
            "name": "laptops",
            "test": "not member('phones')"
        },
        {
            "name": "phones_server1",
            "test": "member('phones') and member('ha_server1')"
        },
        {
            "name": "phones_server2",
            "test": "member('phones') and member('ha_server2')"
        },
        {
            "name": "laptops_server1",
            "test": "member('laptops') and member('ha_server1')"
        },
        {
            "name": "laptops_server2",
            "test": "member('laptops') and member('ha_server2')"
        }
    ],

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {

                    ...

                } ]
            }
        }
    ],

    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [
                {
                    "pool": "192.0.3.100 - 192.0.3.125",
                    "client-class": "phones_server1"
                },
                {
                    "pool": "192.0.3.126 - 192.0.3.150",
                    "client-class": "laptops_server1"
                },
                {
                    "pool": "192.0.3.200 - 192.0.3.225",
                    "client-class": "phones_server2"
                },
                {
                    "pool": "192.0.3.226 - 192.0.3.250",
                    "client-class": "laptops_server2"
                }
            ],

            "option-data": [
                {
                    "name": "routers",
                    "data": "192.0.3.1"
                }
            ],

            "relay": { "ip-address": "10.1.2.3" }
        }
    ],

    ...

}

}
</pre><p>
        </p><p>The configuration provided above splits the address range into
        four pools. Two pools are dedicated to server1 and two are dedicated for
        server2. Each server can assign leases to both phones and laptops.
        Both groups of devices are assigned addresses from different pools.
        Note that definition of classes <span class="command"><strong>ha_server1</strong></span> and
        <span class="command"><strong>ha_server2</strong></span> is required because other classes
        refer to them via <span class="command"><strong>member</strong></span> expression. These classes
        do not include <span class="command"><strong>test</strong></span> parameter because they are
        not evaluated with other classes. They are assigned dynamically
        by the HA hook library as a result of load balancing algorithm.
        The <span class="command"><strong>phones_*</strong></span> and <span class="command"><strong>laptop_*</strong></span>
        evaluate to "true" when the query belongs to a given combination
        of other classes, e.g. <span class="command"><strong>ha_server1</strong></span> and
        <span class="command"><strong>phones</strong></span>. The pool will be selected accordingly
        as a result of such evaluation.
        </p><p>Consult <a class="xref" href="#classify" title="Chapter 13. Client Classification">Chapter 13, <i>Client Classification</i></a> for details on how to use
        <span class="command"><strong>member</strong></span> expression and about class dependencies.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-hot-standby-config"></a>14.4.7.6. Hot Standby Configuration</h4></div></div></div><p>The following is the example configuration of the primary server
        in the hot standby configuration:
</p><pre class="screen">
{
"Dhcp4": {

    ...

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {
                    "this-server-name": "server1",
                    "mode": "hot-standby",
                    "heartbeat-delay": 10000,
                    "max-response-delay": 10000,
                    "max-ack-delay": 5000,
                    "max-unacked-clients": 5,
                    "peers": [
                        {
                            "name": "server1",
                            "url": "http://192.168.56.33:8080/",
                            "role": "primary",
                            "auto-failover": true
                        },
                        {
                            "name": "server2",
                            "url": "http://192.168.56.66:8080/",
                            "role": "standby",
                            "auto-failover": true
                        },
                        {
                            "name": "server3",
                            "url": "http://192.168.56.99:8080/",
                            "role": "backup",
                            "auto-failover": false
                        }
                    ]
                } ]
            }
        }
    ],

    "subnet4": [
        {
            "subnet": "192.0.3.0/24",
            "pools": [
                {
                    "pool": "192.0.3.100 - 192.0.3.250",
                    "client-class": "ha_server1"
                }
            ],

            "option-data": [
                {
                    "name": "routers",
                    "data": "192.0.3.1"
                }
            ],

            "relay": { "ip-address": "10.1.2.3" }
        }
    ],

    ...

}

}
</pre><p>
        </p><p>This configuration is very similar to the load balancing
        configuration described <a class="xref" href="#ha-load-balancing-config" title="14.4.7.4. Load Balancing Configuration">Section 14.4.7.4, “Load Balancing Configuration”</a>,
        with a few notable differences.</p><p>The <span class="command"><strong>mode</strong></span> is now set to <span class="command"><strong>hot-standby</strong></span>,
        in which only one server is responding to the DHCP clients.
        If the primary server is online, the primary server is responding to
        all DHCP queries. The <span class="command"><strong>standby</strong></span> server takes over the
        entire DHCP traffic when it discovers that the primary is unavailable.
        </p><p>In this mode, the non-primary active server is called
        <span class="command"><strong>standby</strong></span> and that's what the role of the second
        active server is set to.</p><p>Finally, because there is always one server responding to the
        DHCP queries, there is only one scope <span class="command"><strong>ha_server1</strong></span>
        in use within pools definitions. In fact, the <span class="command"><strong>client-class</strong></span>
        parameter could be removed from this configuration without harm,
        because there are no conflicts in lease allocations by different
        servers as they do not allocate leases concurrently. The
        <span class="command"><strong>client-class</strong></span> is left in this example mostly for
        demonstration purposes, to highlight the differences between the
        hot standby and load balancing mode of operation.</p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-send-lease-updates"></a>14.4.7.7. Controlling Lease Updates</h4></div></div></div><p>The HA enabled server informs its active partner about allocated
        or renewed leases by sending appropriate control commands. The partner
        updates the lease information in its own database. This guarantees
        consistency of the lease information between the servers and allows for
        designating one of the servers to handle the entire DHCP traffic in
        case the other server becomes unavailable.</p><p>In some cases, though, it is desired to disable lease updates
        between the active servers if the exchange of information about the
        allocated leases is performed using some other mechanism. Kea supports
        various types of databases to be used as a storage for leases, e.g.
        MySQL, Postgres, Cassandra. Those databases include builtin solutions
        for data replication which are often used by Kea users to provide
        redundancy.</p><p>The HA hook library supports such scenarios by allowing to
        disable lease updates over the control channel, leaving the server
        to rely on the database replication mechanism. This is controlled by
        the <span class="command"><strong>send-lease-updates</strong></span> boolean parameter, which
        value defaults to true:

</p><pre class="screen">
{
"Dhcp4": {

    ...

    "hooks-libraries": [
        {
            "library": "/usr/lib/hooks/libdhcp_lease_cmds.so",
            "parameters": { }
        },
        {
            "library": "/usr/lib/hooks/libdhcp_ha.so",
            "parameters": {
                "high-availability": [ {
                    "this-server-name": "server1",
                    "mode": "load-balancing",
                    "send-lease-updates": false,
                    "peers": [
                        {
                            "name": "server1",
                            "url": "http://192.168.56.33:8080/",
                            "role": "primary"
                        },
                        {
                            "name": "server2",
                            "url": "http://192.168.56.66:8080/",
                            "role": "secondary"
                        }
                    ]
                } ]
            }
        }
    ],

    ...

}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-ctrl-agent-config"></a>14.4.7.8. Control Agent Configuration</h4></div></div></div><p>The <a class="xref" href="#kea-ctrl-agent" title="Chapter 7. Kea Control Agent">Chapter 7, <i>Kea Control Agent</i></a> describes in detail the
        Kea deamon which provides RESTful interface to control Kea servers.
        The same functionality is used by High Availability hook library to
        establish communication between the HA peers. Therefore, the HA
        library requires that Control Agent is started for each DHCP
        instance within HA setup. If the Control Agent is not started
        the peers will not be able to communicate with the particular DHCP
        server (even if the DHCP server itself is online) and may eventually
        consider this server to be offline.
        </p><p>The following is the example configuration for the CA running
        on the same machine as the primary server. This configuration is
        valid for both load balancing and hot standby cases presented in
        previous sections.

</p><pre class="screen">
{
"Control-agent": {
    "http-host": "192.168.56.33",
    "http-port": 8080,

    "control-sockets": {
        "dhcp4": {
            "socket-type": "unix",
            "socket-name": "/tmp/kea-dhcp4-ctrl.sock"
        },
        "dhcp6": {
            "socket-type": "unix",
            "socket-name": "/tmp/kea-dhcp6-ctrl.sock"
        }
    }
}
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="ha-control-commands"></a>14.4.7.9. Control Commands for High Availability</h4></div></div></div><p>Even though the HA hook library is designed to automatically
        resolve issues with DHCP service interruptions by redirecting the
        DHCP traffic to a surviving server and synchronizing the lease
        database when required, it may be useful for the administrator to
        have control over the server behavior. In particular, it may be
        useful be able to trigger lease database synchronization on demand.
        It may also be useful to manually set the HA scopes that are being
        served.</p><p>Note that the backup server can sometimes be used to handle
        the DHCP traffic in case if both active servers are down. The backup
        servers do not perform failover function automatically. Hence, in
        order to use the backup server to respond to the DHCP queries,
        the server administrator must enable this function manually.
        </p><p>The following sections describe commands supported by the
        HA hook library which are available for the administrator.
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-sync-command"></a>14.4.7.9.1. ha-sync command</h5></div></div></div><p>The <span class="command"><strong>ha-sync</strong></span> is issued to instruct the
          server to synchronize its local lease database with the
          selected peer. The server fetches all leases from the peer and
          updates those locally stored leases which are older comparing to
          those fetched. It also creates new leases when any of those
          fetched do not exist in the local database. All leases that
          are not returned by the peer but are in the local database are
          preserved. The database synchronization is unidirectional, i.e.
          only the database on the server to which the command has been
          sent is updated. In order to synchronize the peer's database a
          separate <span class="command"><strong>ha-sync</strong></span> has to be issued to that
          peer.</p><p>The database synchronization may be triggered for
          both active and backup server type. The <span class="command"><strong>ha-sync</strong></span>
          has the following structure (DHCPv4 server case):
</p><pre class="screen">
{
    "command": "ha-sync",
    "service": [ "dhcp4 "],
    "arguments": {
        "server-name": "server2",
        "max-period": 60
    }
}
</pre><p>
          </p><p>
            When the server receives this command it first disables the
            DHCP service of the server from which it will be fetching leases,
            i.e. sends <span class="command"><strong>dhcp-disable</strong></span> command to that server.
            The <span class="command"><strong>max-period</strong></span> parameter specifies the maximum
            duration (in seconds) for which the DHCP service should be disabled.
            If the DHCP service is successfully disabled, the synchronizing
            server will fetch leases from the remote server by issuing the
            <span class="command"><strong>lease4-get-all</strong></span> command. When the lease database
            synchronization is complete, the synchronizing server sends the
            <span class="command"><strong>dhcp-enable</strong></span> to the peer to re-enable its
            DHCP service.
          </p><p>The <span class="command"><strong>max-period</strong></span> value should be sufficiently
          long to guarantee that it doesn't elapse before the synchronization
          is completed. Otherwise, the DHCP server will automatically enable
          its DHCP function while the synchronization is still in progress.
          If the DHCP server subsequently allocates any leases during the
          synchronization, those new (or updated) leases will not be fetched
          by the synchronizing server leading to database inconsistencies.
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="ha-scopes-command"></a>14.4.7.9.2. ha-scopes command</h5></div></div></div><p>This command allows for modifying the HA scopes that the
          server is serving. Consult <a class="xref" href="#ha-load-balancing-config" title="14.4.7.4. Load Balancing Configuration">Section 14.4.7.4, “Load Balancing Configuration”</a>
          and <a class="xref" href="#ha-hot-standby-config" title="14.4.7.6. Hot Standby Configuration">Section 14.4.7.6, “Hot Standby Configuration”</a> to learn what scopes
          are available for different HA modes of operation. The
          <span class="command"><strong>ha-scopes</strong></span> command has the following structure
          (DHCPv4 server case):
</p><pre class="screen">
{
    "command": "ha-scopes",
    "service": [ "dhcp4 "],
    "arguments": {
        "scopes": [ "ha_server1", "ha_server2" ]
    }
}
</pre><p>
          </p><p>This command configures the server to handle traffic from
          both <span class="command"><strong>ha_server1</strong></span> and <span class="command"><strong>ha_server2</strong></span>
          scopes. In order to disable all scopes specify an empty list:

</p><pre class="screen">
{
    "command": "ha-scopes",
    "service": [ "dhcp4 "],
    "arguments": {
        "scopes": [ ]
    }
}
</pre><p>
          </p></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hooks-radius"></a>14.4.8. radius: RADIUS server support</h3></div></div></div><p>
    The RADIUS hook library allows Kea to interact with two types of
    RADIUS servers: access and accounting. Although the most common
    DHCP and RADIUS integration is done on DHCP relay agent level
    (DHCP clients send DHCP packets to DHCP relays; relays contact
    RADIUS server and depending on the response either send the packet
    to the DHCP server or drop it), it does require a DHCP relay
    hardware to support RADIUS communication. Also, even if the relay
    has necessary support it is often not flexible enough to send and
    receive additional RADIUS attributes. As such, the alternative
    looks more appealing: to extend DHCP server to talk to RADIUS
    directly. That is the goal this library intends to fulfill.
  </p><p>
    The major feature of the library is the ability to use RADIUS
    authorization. When a DHCP packet is received, the Kea server
    will send send Access-Request to the RADIUS server and will await
    a response. The server will then send back either Access-Accept
    with specific client attributes or Access-Reject. There are two
    cases supported here. First, the Access-Accept includes
    Framed-IP-Address (for DHCPv4) or Framed-IPv6-Address (for
    DHCPv6), which will be interpreted by Kea as an instruction to
    assign that specified IPv4 or IPv6 address. This effectively
    means RADIUS can act as address reservation database.
  </p><p>
    The second case supported is the ability to assign clients to
    specific pools based on RADIUS response. In this case RADIUS
    server sends back Access-Accept with Framed-Pool (IPv4) or
    Framed-IPv6-Pool (IPv6). In both cases, Kea will interpret those
    attributes as client classes. With the recent addition of the
    ability to limit access to pools to specific classes (see <a class="xref" href="#classification-pools" title="13.7. Configuring Pools With Class Information">Section 13.7, “Configuring Pools With Class Information”</a>), it can be used to force client
    to be assigned a dynamic address from specific pool. Furthermore,
    the same mechanism can be used to control what kind of options the
    client will get (if there are DHCP options specified for a
    particular class).
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hooks-radius-install"></a>14.4.8.1. Compilation and Installation of RADIUS Hook</h4></div></div></div><p>
      The following section describes how to compile and install the
      software on CentOS 7.0. Other systems may differ slightly.
    </p><p>
      STEP 1: Install dependencies
    </p><p>
      Several tools are needed to build dependencies and Kea
      itself. The following commands should install them:
</p><pre class="screen">
$ sudo rpm -Uvh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
$ sudo yum install gcc-g++ openssl-devel log4cplus-devel wget git
</pre><p>
    </p><p>
      STEP 2: FreeRADIUS installation.
    </p><p>
      Kea RADIUS hook library uses FreeRadius client library to
      conduct RADIUS communication. Unfortunately, the standard
      1.1.7 release available from the project website
      <code class="uri"><a class="uri" href="http://freeradius.org/sub_projects/" target="_top">http://freeradius.org/sub_projects/</a></code>
      has several serious deficiencies. ISC engineers observed a segmentation
      fault during testing. Also, the base version of the library does
      not offer asynchronous transmissions, which is essential for
      effective accounting implementation. Both of these issues
      were addressed by ISC engineers. The changes have been
      reported to FreeRadius client project. Acceptance of those
      changes is outside of ISC responsibilities. Until those
      are processed, it is strongly recommended to use FreeRadius
      client with ISC patches. To and compile this version, please use
      the following steps:
</p><pre class="screen">
$ git clone https://github.com/fxdupont/freeradius-client.git
$ cd freeradius-client/
$ git checkout iscdev
$ ./configure
$ make
$ sudo make install
</pre><p>

      You may pass additional parameters to configure script, if you need
      to. Once installed, the FreeRADIUS client will be installed in
      /usr/local. This is the default path where Kea will be looking for
      it. You may install it in a different directory. If you choose to do
      so, make sure you pass that path to configure script when compiling kea.
      </p><p>
        STEP 3: Install recent BOOST version
      </p><p>
        Kea requires reasonably recent Boost version. Unfortunately,
        the version available in CentOS 7 is too old. Therefore a
        newer Boost version is necessary. Furthermore, CentOS 7 has an
        old version of g++ compiler that does not handle latest Boost
        versions. Fortunately, Boost 1.65 meets both requirements: is
        recent enough for Kea and is still able to be compiled using
        the g++ 4.8 version in CentOS.
      </p><p>
        To download and compile Boost 1.65, please use the following
        commands:
</p><pre class="screen">
$ wget -nd https://dl.bintray.com/boostorg/release/1.65.1/source/boost_1_65_1.tar.gz
$ tar zxvf boost_1_65_1.tar.gz
$ cd boost_1_65_1/
$ ./bootstrap.sh
$ ./b2 --without-python
$ sudo ./b2 install
</pre><p>
        Note that b2 script may optionally take extra parameters. One
        of them specify the destination path where the sources are to
        be compiled. Boost is different compared to other software in
        the sense that there is no explicit make install step.
      </p><p>
        STEP 4: Compile and Install Kea
      </p><p>
        Obtain Kea sources either by downloading it from git repository or extract the tarball:
</p><pre class="screen">
# Use one of those commands to obtain Kea sources:

# Choice 1: get from github
$ git clone https://github.com/isc-projects/kea

# Get a tarball and extract it
$ tar zxvf kea-1.4.0-beta.tar.gz
</pre><p>

The next step is to extract premium Kea package that contains Radius repository
into the Kea sources. After the tarball is extracted, the Kea sources should have
a premium/ subdirectory.

</p><pre class="screen">
  $ cd kea
  $ tar zxvf ../kea-premium-radius-1.4.0-beta.tar.gz
</pre><p>

Once this is done, make sure the kea sources look similar to this:
</p><pre class="screen">
$ ls -l
total 952
-rw-r--r--   1 thomson  staff    6192 Apr 25 17:38 AUTHORS
-rw-r--r--   1 thomson  staff   29227 Apr 25 17:38 COPYING
-rw-r--r--   1 thomson  staff  360298 Apr 25 20:00 ChangeLog
-rw-r--r--   1 thomson  staff     645 Apr 25 17:38 INSTALL
-rw-r--r--   1 thomson  staff    5015 Apr 25 17:38 Makefile.am
-rw-r--r--   1 thomson  staff     587 Apr 25 17:38 README
drwxr-xr-x   5 thomson  staff     170 Apr 26 19:04 compatcheck
-rw-r--r--   1 thomson  staff   62323 Apr 25 17:38 configure.ac
-rw-r--r--   1 thomson  staff     300 Apr 25 17:38 dns++.pc.in
drwxr-xr-x  12 thomson  staff     408 Apr 26 19:04 doc
drwxr-xr-x   7 thomson  staff     238 Apr 25 17:38 examples
drwxr-xr-x   5 thomson  staff     170 Apr 26 19:04 ext
drwxr-xr-x   8 thomson  staff     272 Apr 26 19:04 m4macros
drwxr-xr-x  20 thomson  staff     680 Apr 26 11:22 <strong class="userinput"><code>premium</code></strong>
drwxr-xr-x  10 thomson  staff     340 Apr 26 19:04 src
drwxr-xr-x  14 thomson  staff     476 Apr 26 19:04 tools
</pre><p>

The next step is to configure Kea. There are several essential steps necessary here.
The --with-tier2=yes flag is necessary to compile premium package that contains
RADIUS. Also, --with-freeradius option is necessary to tell Kea where the FreeRADIUS
client sources can be found. Also, since the non-standard boost is used, the path
to it has to be specified.</p><p>If the sources are not from a tarball release, makefiles have to be regenerated
using autoreconf.</p><pre class="screen">
$ autoreconf -i
$ ./configure --with-freeradius=/path/to/freeradius --with-boost-include=/path/to/boost --with-boost-lib-dir=/path/to/boost/state/lib
</pre><p>
For example, assuming FreeRadius client was installed in the default directory (/usr/local)
and Boost 1.65 sources were compiled in /home/thomson/devel/boost1_65_1, the configure path
should look as follows:</p><pre class="screen">
./configure --with-freeradius=/usr/local \
            --with-boost-include=/home/thomson/devel/boost_1_65_1 \
            --with-boost-lib-dir=/home/thomson/devel/boost_1_65_1/stage/lib \
            --with-tier2=yes
</pre><p>
  After some checks, the configure script should print a report similar to the
  following:

</p><pre class="screen">

       Kea source configure results:
    -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Package:
  Name:              kea
  Version:           1.3.0-git
  Extended version:  1.3.0-git (git c494c28cc958bb21a9c6cb0f8dc805a721c69893)
  OS Family:         Linux
  Using GNU sed:     yes
  Premium package:   yes
  Tier1 Packages:    host_cmds flex_id legal_log
  Tier2 Packages:    high_availability subnet_cmds radius
  Included Packages: host_cmds flex_id legal_log high_availability subnet_cmds radius

C++ Compiler:
  CXX:             g++ --std=c++11
  CXX_VERSION:     g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-16)
  CXX_STANDARD:    201103
  DEFS:            -DHAVE_CONFIG_H
  CPPFLAGS:         -DOS_LINUX  -DBOOST_ASIO_HEADER_ONLY -DBOOST_ASIO_DISABLE_THREADS=1
  CXXFLAGS:        -g -O2
  LDFLAGS:          -lpthread
  KEA_CXXFLAGS:     -Wall -Wextra -Wnon-virtual-dtor -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -pthread -Wno-missing-field-initializers -fPIC

Python:
  PYTHON_VERSION:  not needed (because kea-shell is disabled)

Boost:
  BOOST_VERSION:   1.65.1
  BOOST_INCLUDES:  -I/home/thomson/devel/boost_1_65_1
  BOOST_LIBS:      -L/home/thomson/devel/boost_1_65_1/stage/lib  -lboost_system

OpenSSL:
  CRYPTO_VERSION:  OpenSSL 1.0.2k  26 Jan 2017
  CRYPTO_CFLAGS:
  CRYPTO_INCLUDES:
  CRYPTO_LDFLAGS:
  CRYPTO_LIBS:     -lcrypto

Botan: no

Log4cplus:
  LOG4CPLUS_VERSION:  1.1.3
  LOG4CPLUS_INCLUDES: -I/usr/include
  LOG4CPLUS_LIBS:     -L/usr/lib -L/usr/lib64 -llog4cplus

Flex/bison:
  FLEX:  flex
  BISON: bison -y

MySQL:
  no

PostgreSQL:
  no

Cassandra CQL:
  no
Google Test:
  no
Google Benchmark:
  no

FreeRADIUS client:
  FREERADIUS_INCLUDE:    -I/usr/local/include
  FREERADIUS_LIB:        -L/usr/local/lib -lfreeradius-client
  FREERADIUS_DICTIONARY: /usr/local/etc/radiusclient/dictionary

Developer:
  Enable Debugging:       no
  Google Tests:           no
  Valgrind:               not found
  C++ Code Coverage:      no
  Logger checks:          no
  Generate Documentation: no
  Parser Generation:      no
  Kea-shell:              no
</pre><p>
</p><p>
Please make sure that your compilation has the following:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">radius listed in tier 2 packages</li><li class="listitem">FreeRadius client directories printed and pointing to the right
  directories</li><li class="listitem">Boost version is at least 1.65.1. The versions available
  in CentOS 7 (1.48 and and 1.53) are too old.</li></ul></div><p>

</p><p>
  After that compile kea using make. If your system has more than one core, it is recommended to use -j N option.
  </p><pre class="screen">
    $ make -j5
    $ sudo make install</pre><p>

      </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="hooks-radius-config"></a>14.4.8.2. RADIUS Hook Configuration</h4></div></div></div><p>
      The RADIUS Hook is a library that has to be loaded by either DHCPv4 or
      DHCPv6 Kea servers. Compared to other available hook libraries, this one
      takes many parameters to actually run. For example, this configuration
      could be used:

</p><pre class="screen">
  "Dhcp4": {

  // Your regular DHCPv4 configuration parameters here.

  "hooks-libraries": [
  {
      // Note that RADIUS requires host-cache for proper operation,
      // so that library is loaded as well.
      "library": "/usr/local/lib/hooks/libdhcp_host_cache.so"
  },
  {
      "library": "/usr/local/lib/hooks/libdhc_radius.so",
      "parameters": {

          // Specify where FreeRADIUS dictionary could be located
          "dictionary": "/usr/local/etc/freeradius/dictionary",

          // Specify which address to use to communicate with RADIUS servers
          "bindaddr": "*",

          // more RADIUS parameters here
      }
  } ]</pre><p>
    </p><p>
      Radius is a complicated environment. As such, it's not really possible
      to provide a default configuration that would work out of the box.
      However, we do have one example that showcases some of the more
      common features. Please see doc/examples/kea4/hooks-radius.json in your
      Kea sources.
    </p><p>
      The RADIUS hook library supports the following global configuration
      flags, which corresponds to FreeRADIUS client library options:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>bindaddr</strong></span> (default "*") specifies
        the address to be used by the hook library in communication with RADIUS
        servers. The "*" special value means to leave the kernel to choose
        it.</li><li class="listitem"><span class="command"><strong>canonical-mac-address</strong></span> (default
      false) specifies whether MAC addresses in attributes follows the canonical
      Radius format (lowercase pairs of hexadecimal digits separated by
      '-').</li><li class="listitem"><span class="command"><strong>client-id-pop0</strong></span> (default false) used
      with flex-id removes the leading zero (or pair of zero in DHCPv6) type in
      client-id (aka duid in DHCPv6). Implied by
      client-id-printable.</li><li class="listitem"><span class="command"><strong>client-id-printable</strong></span> (default false)
      checks if the client-id / duid content is printable and uses it as it
      instead of in hexadecimal.  Implies client-id-pop0 and extract-duid as 0
      and 255 are not printable.</li><li class="listitem"><span class="command"><strong>deadtime</strong></span> (default 0) is a mechanism
      to try not responding servers after responding servers. Its value
      specifies the number of seconds the fact a server did not answer is kept,
      so 0 disables the mechanism.  As the asynchronous communication does not
      use locks or atomics it is not recommended to use this feature with this
      mode. </li><li class="listitem"><span class="command"><strong>dictionary</strong></span> (default set by configure
      at build time) is the attribute and value dictionary. Note it is a
      critical parameter. </li><li class="listitem"><span class="command"><strong>extract-duid</strong></span> (default true) extracts
      from RFC 4361 compliant DHCPv4 client-id the embedded duid. Implied by
      client-id-printable. </li><li class="listitem"><span class="command"><strong>identifier-type4</strong></span> (default client-id)
      specifies the identifier type to build the User-Name attribute. It should
      be the same than host identifier and when the flex-id hook library is
      used the replace-client-id must be set to true and client-id will be used
      with client-id-pop0. </li><li class="listitem"><span class="command"><strong>identifier-type6</strong></span> (default duid)
      specifies the identifier type to build the User-Name attribute. It should
      be the same than host identifier and when the flex-id hook librairy is
      used the replace-client-id must be set to true and duid will be used with
      client-id-pop0. </li><li class="listitem"><span class="command"><strong>realm</strong></span> (default "") is the default
      realm. </li><li class="listitem"><span class="command"><strong>reselect-subnet-address</strong></span> (default
      false) uses the Kea reserved address / RADIUS Framed-IP-Address or
      Framed-IPv6-Address to reselect subnets where the address is not in
      the subnet range. </li><li class="listitem"><span class="command"><strong>reselect-subnet-pool</strong></span> (default
      false) uses the Kea client-class / RADIUS Frame-Pool to reselect
      subnets where no available pool can be found. </li><li class="listitem"><span class="command"><strong>retries</strong></span> (default 3) is the number of
      retries before trying the next server. Note it is not supported for
      asynchronous communication. </li><li class="listitem"><span class="command"><strong>session-history</strong></span> (default "") is the
      name of the file providing persistent storage for accounting session
      history. </li><li class="listitem"><span class="command"><strong>timeout</strong></span> (default 10) is the number
      of seconds a response is waited for. </li></ul></div><p>

    </p><p> When <span class="command"><strong>reselect-subnet-pool</strong></span> or
    <span class="command"><strong>reselect-subnet-address</strong></span> is set to true at the
    reception of RADIUS Access-Accept the selected subnet is checked
    against the client-class name or the reserved address and if it does
    not matched another subnet is selected among matching subnets.
    </p><p>
      Two services are supported:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>access</strong></span> - the authentication service </li><li class="listitem"><span class="command"><strong>accounting</strong></span> - the accounting service</li></ul></div><p>
    </p><p>
      Configuration of services is divided into two parts:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p class="simpara">servers that define RADIUS servers the library is expected to
          contact. Each server may have the following items specified:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><span class="command"><strong>name</strong></span> which specifies the IP
            address of the server (it is allowed to use a name which will be
            resolved but it is not recommended).</li><li class="listitem"><span class="command"><strong>port</strong></span> (default RADIUS
            authentication or accounting service) which specifies the UDP port
            of the server. Note that the FreeRADIUS client library by default
            uses ports 1812 (auth) and 1813 (acct). Some server implementations
            use 1645 (auth) ns 1646 (acct). You may use the "port" parameter to
            adjust as needed.</li><li class="listitem"><span class="command"><strong>secret</strong></span> which authenticates
            messages.</li></ul></div><p class="simpara">There may be up to 8 servers. Note when no server was
          specified the service is disabled.</p></li><li class="listitem"><p class="simpara">attributes which define additional attributes that
          the Kea server will send to a RADIUS server. The parameter
          must be identified either by a name or type. Its value can
          be specified using one of three possible ways: data (which
          defines a plain text value), raw (which defines the value in
          hex) or expr (which defines an expression, which will be
          evaluated for each incoming packet independently).
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><span class="command"><strong>name</strong></span> of the
            attribute. </li><li class="listitem"><span class="command"><strong>type</strong></span> of the attribute. Type or
            name is required, and the attribute must be defined in the
            dictionary.</li><li class="listitem"><span class="command"><strong>data</strong></span> is the first out of three
            ways to specify the attribute content. The data entry is parsed by
            the FreeRADIUS library so values defined in the dictionary of the
            attribute may be used.</li><li class="listitem"><span class="command"><strong>raw</strong></span> is the second out of three
            way to specify the attribute content. It specifies the content in
            hexadecimal. Note it does not work with integer content attributes
            (date, integer and IPv4 address), a string content attribute
            (string. IPv6 address and IPv6 prefix) is
            required.</li><li class="listitem"><span class="command"><strong>expr</strong></span> is the last way to
            specify the attribute content. It specifies an evaluation expression
            which must return a not empty string when evaluated with the DHCP
            query packet.  Currently this is restricted to the access
            service. </li></ul></div></li></ul></div><p>
    </p><p>
  For example, to specify a single access server available on localhost that
  uses "secret" as a secret and tell Kea to send three additional attributes
  (Password, Connect-Info and Configuration-Token), the following snipped could
  be used:
  </p><pre class="screen">
"parameters": {

    // Other RADIUS parameters here

    "access": {

        // This starts the list of access servers
        "servers": [
        {
            // These are parameters for the first (and only) access server
            "server": "127.0.0.1",
            "port": 1812,
            "secret": "secret"
        }
        // Additional access servers could be specified here
        ],

        // This define a list of additional attributes Kea will send to each
        // access server in Access-Request.
        "attributes": [
        {
            // This attribute is identified by name (must be present in the
            // dictionary) and has static value (i.e. the same value will be
            // sent to every server for every packet)
            "name": "Password",
            "data": "mysecretpassword"
        },
        {
            // It's also possible to specify an attribute using its type,
            // rather than a name. 77 is Connect-Info. The value is specified
            // using hex. Again, this is a static value. It will be sent the
            // same for every packet and to every server.
            "type": 77,
            "raw": "65666a6a71"
        },
        {
            // This example shows how an expression can be used to send dynamic
            // value. The expression (see Section 13) may take any value from
            // the incoming packet or even its metadata (e.g. the interface
            // it was received over from)
            "name": "Configuration-Token",
            "expr": "pkt.iface"
        }
        ] // End of attributes
    } // End of access

    // accounting could be specified here.

    }
</pre><p>
</p><p>For the RADIUS Hook library to operate properly in DHCPv4, it is necessary
to also load the Host Cache hook library. The reason for this is somewhat
complex. In a typical deployment the DHCP clients send their packets via
DHCP relay which inserts certain Relay Agent Information options, such are
circuit-id or remote-id. The values of those options are then used by the
Kea DHCP server to formulate necessary attributes in the Access-Request message
sent to the RADIUS server. However, once the DHCP client gets its address, it
then renews by sending packets directly to the DHCP server. As a result, the
relays are not able to insert their RAI options and DHCP server can't send the
Access-Request queries to the RADIUS server by using just the information from
incoming packets. Kea needs to keep the information received during initial
Discover/Offer exchanges and later use it when sending accounting
messages.</p><p>This mechanism is implemented based on user context in host reservations.
(See <a class="xref" href="#user-context" title="14.5. User contexts">Section 14.5, “User contexts”</a> for details about user context). The host
cache mechanism allows to retain the information retrieved by RADIUS to be
stored and later used for sending accounting and access queries to the RADIUS
server. In other words, the host-cache mechanism is mandatory, unless you
don't want the RADIUS communication for messages other than
Discover and the first Request from each client.</p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hooks-host-cache"></a>14.4.9. host_cache: Caching Host Reservations</h3></div></div></div><p>Some of the database backends, such as RADIUS, are considered
  slow and may take a long time to respond. Since Kea in general is
  synchronous, the backend performance directly affects the DHCP
  performance. To minimize the impact and improve performance, the
  Host Cache library provides a way to cache responses from other
  hosts. This includes negative caching, i.e. the ability to remember
  that there is no client information in the database.</p><p>

  </p><p>
    The RADIUS Host cache is a library that has to be loaded by either
    DHCPv4 or DHCPv6 Kea servers. In principle it can be used with any
    backend that may introduce performance degradation (MySQL,
    PostgreSQL, Cassandra, RADIUS). Host Cache is required to be
    loaded for the RADIUS accounting mechanism to work.
  </p><p>
    Host Cache hook library is currently very simple. It takes only
    one optional parameter ("maximum") that defines the maximum number
    of hosts to be cached. If not specified the default value of 0 is
    used, which means there is no limit. The hook library can be
    loaded the same way as any other hook library. For example, this
    configuration could be used:

</p><pre class="screen">
  "Dhcp4": {

  // Your regular DHCPv4 configuration parameters here.

  "hooks-libraries": [
  {
      "library": "/usr/local/lib/hooks/libdhc_host_cache.so",
      "parameters": {

          // Tells Kea to never cache more than 1000 hosts.
          "maximum: "1000"

      }
  } ]</pre><p>
  </p><p>
    Once loaded, the Host Cache hook library makes available a number
    of new commands. Those commands can be used either over control
    channel (see <a class="xref" href="#ctrl-channel-client" title="16.2. Using the Control Channel">Section 16.2, “Using the Control Channel”</a>) or REST API
    (see <a class="xref" href="#agent-overview" title="7.1. Overview">Section 7.1, “Overview”</a>). An example REST API client
    is described in <a class="xref" href="#shell-overview" title="19.1. Overview">Section 19.1, “Overview”</a>. The following
    sections describe the commands available.
  </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-flush-cmd"></a>14.4.9.1. cache-flush command</h4></div></div></div><p>This command allows removal of specified number of cached
    host entries. It takes one parameter which defines the number of
    hosts to be removed. An example usage looks as follows:
</p><pre class="screen">
{
    "command": "cache-flush",
    "arguments": 1000
}</pre><p>
This command will remove 1000 hosts. If you want to delete all
cached hosts, please use cache-clear instead. The hosts are stored
in FIFO order, so always the oldest entries are removed.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-clear-cmd"></a>14.4.9.2. cache-clear command</h4></div></div></div><p>This command allows removal of all cached
    host entries. An example usage looks as follows:
</p><pre class="screen">
{
    "command": "cache-clear"
}</pre><p>
This command will remove all hosts. If you want to delete only
certain number of cached hosts, please use cache-flush instead.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-write-cmd"></a>14.4.9.3. cache-write command</h4></div></div></div><p>In general case the cache content is considered a run-time
    state and the server can be shutdown or restarted as usual. The
    cache will then be repopulated after restart. However, there are
    some cases when it is useful to store contents of the cache. One
    such case is RADIUS (where the cached hosts also retain
    additional cached RADIUS attributes and there is no easy way to
    obtain this information again, because renewing clients send their
    packet to the DHCP server directly. As a result, packets never go
    through relay which doesn't insert relay options, which in turn
    are in some deployment to query the RADIUS server). Another use
    case is when you want to restart the server and for performance
    reasons you want it to start with a hot (populated) cache.
    </p><p>This command allows writing the contents of in-memory cache
    to a file on disk. It takes one parameter which defines the
    filename. An example usage looks as follows:
</p><pre class="screen">
{
    "command": "cache-write",
    "arguments": "/tmp/kea-host-cache.json"
}</pre><p>
This command will store the contents to /tmp/kea-host-cache.json file.
That file can then be loaded with cache-load command or processed by
any other tool that is able to understand JSON format.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-load-cmd"></a>14.4.9.4. cache-load command</h4></div></div></div><p>See previous section for a discussion regarding use cases
    where it may be useful to write and load contents of the host
    cache to disk.</p><p>This command allows load the contents of a file on disk into
    an in-memory cache. It takes one parameter which defines the
    filename. An example usage looks as follows:
</p><pre class="screen">
{
    "command": "cache-load",
    "arguments": "/tmp/kea-host-cache.json"
}</pre><p>
This command will store the contents to /tmp/kea-host-cache.json file.
That file can then be loaded with cache-load command or processed by
any other tool that is able to understand JSON format.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-get-cmd"></a>14.4.9.5. cache-get command</h4></div></div></div><p>This command is similar to cache-write, but instead of
    writing the cache contents to disk, it returns the contents to
    whoever sent the command.</p><p>This command allows load the contents of a file on disk into
    an in-memory cache. It takes one parameter which defines the
    filename. An example usage looks as follows:
</p><pre class="screen">
{
    "command": "cache-get"
}</pre><p>
This command will return all the cached hosts. Note the response
may be large.
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-insert-cmd"></a>14.4.9.6. cache-insert command</h4></div></div></div><p>This command may be used to manually insert a host into the
    cache. There are very few use cases when this command could be
    useful. This command expects the arguments to follow the usual
    syntax for specifying host reservations (see <a class="xref" href="#host-reservation-v4" title="8.3. Host Reservation in DHCPv4">Section 8.3, “Host Reservation in DHCPv4”</a> or <a class="xref" href="#host-reservation-v6" title="9.3. Host Reservation in DHCPv6">Section 9.3, “Host Reservation in DHCPv6”</a>) with one difference: the
    subnet-id value must be specified explicitly.</p><p>
      An example command that will insert a IPv4 host into the host
      cache looks as follows:
</p><pre class="screen">
{
    "command": "cache-insert",
    "arguments": {
        "hw-address": "01:02:03:04:05:06",
        "subnet-id4": 4,
        "subnet-id6": 0,
        "ip-address": "192.0.2.100",
        "hostname": "somehost.example.org",
        "client-classes4": [ ],
        "client-classes6": [ ],
        "option-data4": [ ],
        "option-data6": [ ],
        "next-server": "192.0.0.2",
        "server-hostname": "server-hostname.example.org",
        "boot-file-name": "bootfile.efi",
        "host-id": 0
    }
}</pre><p>

    </p><p>
      An example command that will insert IPv6 host into the host
      cache looks as follows:
</p><pre class="screen">
{
    "command": "cache-insert",
    "arguments": {
        "hw-address": "01:02:03:04:05:06",
        "subnet-id4": 0,
        "subnet-id6": 6,
        "ip-addresses": [ "2001:db8::cafe:babe" ],
        "prefixes": [ "2001:db8:dead:beef::/64" ],
        "hostname": "",
        "client-classes4": [ ],
        "client-classes6": [ ],
        "option-data4": [ ],
        "option-data6": [ ],
        "next-server": "0.0.0.0",
        "server-hostname": "",
        "boot-file-name": "",
        "host-id": 0
    }
}</pre><p>
    </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="cache-remove-cmd"></a>14.4.9.7. cache-remove command</h4></div></div></div><p>Sometimes it is useful to remove a single entry from the
    host cache. A good use case is a situation where the device is up,
    Kea already provided configuration and the host entry is in
    cache. As a result of administrative action (e.g. customer hasn't
    paid their bills or perhaps been upgraded to better service), the
    information in the backend (e.g. MySQL or RADIUS) is being
    updated. However, since cache is in use, Kea does not notice the
    change as the cached values are used. Cache-remove command can
    solve this problem by removing cached entry after administrative
    changes.</p><p>
      The cache-remove command works similarly to reservation-get
      command. It allows querying by two parameters. One of them is
      either subnet-id4 or subnet-id6 and the other one is one of:
      ip-address (may be IPv4 or IPv6 address), hw-address (specifies
      hardware/MAC address), duid, circuit-id, client-id or flex-id.
    </p><p>
      An example command to remove an IPv4 host with reserved address
      192.0.2.1 from subnet with a subnet-id 123 looks as follows:
</p><pre class="screen">
{
    "command": "cache-remove",
    "arguments": {
        "ip-address": "192.0.2.1",
        "subnet-id": 123
    }
}</pre><p>
    </p><p>
      Another example that removes IPv6 host identifier by DUID and
      specific subnet-id is:
</p><pre class="screen">
{
    "command": "cache-remove",
    "arguments": {
        "duid": "00:01:ab:cd:f0:a1:c2:d3:e4",
        "subnet-id": 123
    }
}</pre><p>
    </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="hooks-stat-cmds"></a>14.4.10. stat_cmds: Supplemental Statistics Commands</h3></div></div></div><p>
    This library provides additional statistics commands for
    retrieving lease statistics from Kea DHCP servers.  These commands
    were added to address an issue with obtaining accurate lease
    statistics in deployments running multiple Kea servers that use
    shared lease back end.  The in-memory statistics kept by individual
    servers only track lease changes made by that server.  Thus in a
    deployment with multiple servers (e.g. two kea-dhcp6 servers using the
    same PostgreSQL database for lease storage), these statistics are incomplete.
    In Kea 1.4, the MySQL and PostgreSQL back ends were modified to track
    lease allocation changes as they occur via database triggers. Additionally,
    all four lease back ends were extended to support retrieving lease
    statistics for all subnets, a single subnet, or a range of subnets.
    Finally, this library was constructed to provide commands for retrieving
    these statistics.  Additional statistics commands may be added to this
    library in future releases.
  </p><p>
    The commands currently provided by this library are:
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>stat-lease4-get</strong></span> - fetches DHCPv4 lease statistics</p></li><li class="listitem"><p><span class="command"><strong>stat-lease6-get</strong></span> - fetches DHCPv6 lease statistics</p></li></ul></div><p>
  </p><p>
    The Stat commands library is part of the open source code and is
    available to every Kea user.
  </p><p>
    All commands use JSON syntax and can be issued either directly to
    the servers via the control channel (see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>)
    or via Control Agent (see <a class="xref" href="#kea-ctrl-agent" title="Chapter 7. Kea Control Agent">Chapter 7, <i>Kea Control Agent</i></a>).
  </p><p>
    This library may be loaded by both kea-dhcp4 and kea-dhcp6 servers.
    It is loaded in the same way as other libraries and currently has
    no parameters:
  </p><p>
</p><pre class="screen">
"Dhcp6": { <strong class="userinput"><code>
    "hooks-libraries": [
        {
            "library": "/path/libdhcp_stat_cmds.so"
        }
        ...
    ] </code></strong>
}
</pre><p>
</p><p>
    In a deployment with multiple Kea DHCP servers sharing a common lease
    storage, it may be loaded by any or all of the servers.  However, one
    thing to keep in mind is that a server's response to a stat-lease{4/6}-get
    command will only contain data for subnets known to that server.  In
    other words, if subnet does not appear in a server's configuration, it
    will not retrieve statistics for it.
 </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59195216"></a>14.4.10.1. stat-lease4-get, stat-lease6-get commands</h4></div></div></div><p>
      The <span class="command"><strong>stat-lease4-get</strong></span> and <span class="command"><strong>stat-lease6-get</strong></span>
      commands fetch lease statistics for a range of known subnets.  The
      range of subnets is determined through the use of optional command
      input parameters:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>subnet-id</strong></span> - ID of the subnet for which
            lease statistics should be fetched. Use this to get statistics for
            a single subnet.  If the subnet does not exist the command result
            code will be 3 (i.e. CONTROL_RESULT_EMPTY).
            </p></li><li class="listitem"><p><span class="command"><strong>subnet-range</strong></span> - A pair of subnet IDs which
            describe an inclusive range of subnets for which statistics should
            be retrieved.  Note that fuzzy values are supported thus allowing
            for a query for statistics using approximate ID values. If the
            range does not include any known subnets, the command result code
            will be 3 (i.e. CONTROL_RESULT_EMPTY).
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="command"><strong>first-subnet-id</strong></span> - ID of the first
                subnet in the range.</p></li><li class="listitem"><p><span class="command"><strong>last-subnet-id</strong></span> - ID of the first
                subnet in the range.</p></li></ul></div><p>
            </p></li></ul></div><p>
        The use of subnet-id and subnet-range are mutually exclusive.
        If no parameters are given, the result will contain data for all
        known subnets.  Note that in configurations with large numbers of
        subnets, this can be result in a large response.
    </p><p>
      The following command would fetch lease statistics for all known subnets from kea-dhcp4 server:
</p><pre class="screen">
{
  "command": "stat-lease4-get"
}
</pre><p>
    </p><p>
        The following command would fetch lease statistcis for subnet ID 10 from kea-dhcp6 server:
</p><pre class="screen">
{
  "command": "stat-lease6-get",
  "arguments": {
    "subnet-id" : 10
  }
}
</pre><p>
    </p><p>
        The following command would fetch lease statistcis for all subnets from subnet ID 10 through 50 from kea-dhcp4 server:
</p><pre class="screen">
{
  "command": "stat-lease4-get",
  "arguments": {
    "subnet-range" {
      "first-subnet-id": 10,
      "last-subnet-id": 50,
    }
  }
}
</pre><p>
    </p><p>
      The response to the either command will contain three elements:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="command"><strong>result</strong></span> - numeric value indicating the outcome of the
          command where:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><span class="command"><strong>0</strong></span> - command was successful</li><li class="listitem"><span class="command"><strong>1</strong></span> - an error occurred, an explanation will
            be the "text" element</li><li class="listitem"><span class="command"><strong>2</strong></span> - indicates the fetch found no matching data</li></ul></div><p>
          </p></li><li class="listitem"><p><span class="command"><strong>text</strong></span> - an explanation of the command outcome. When the command
      succeeds it will contain the command name along with the number of rows returned.</p></li><li class="listitem"><p><span class="command"><strong>arguments</strong></span> - a map containing the data returned by the
          command as the element "result-set", which patterned after SQL statement responses:
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p><span class="command"><strong>columns</strong></span> - a list of text column labels.
            The columns returned for DHCPv4 are:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><span class="command"><strong>subnet-id</strong></span> - ID of the subnet</li><li class="listitem"><span class="command"><strong>total-addresses</strong></span> - total number of addresses
              available for DHCPv4 management in the subnet. In other words, this is the sum of all
              addresses in all the configured pools in the subnet.</li><li class="listitem"><span class="command"><strong>assigned-addresses</strong></span> - number of addresses
              in the subnet that are currently assigned to a client.</li><li class="listitem"><span class="command"><strong>declined-addresses</strong></span> - number of addresses
              in the subnet that are currently declined and are thus unavailable for assignment.
              </li></ul></div></li><li class="listitem"><p>The columns returned for DHCPv6 are:
            </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: square; "><li class="listitem"><span class="command"><strong>subnet-id</strong></span> - ID of the subnet</li><li class="listitem"><span class="command"><strong>total-nas</strong></span> - number of NA addresses available
              for DHCPv6 management in the subnet. In other words, this is the sum of all
              the NA addresses in the all configured NA pools in the subnet.</li><li class="listitem"><span class="command"><strong>assigned-nas</strong></span> - number of NA addresses in a
              the subnet that are currently assigned to a client.</li><li class="listitem"><span class="command"><strong>declined-nas</strong></span> - number of NA addresses that
              are currently declined and are thus unavailable for assignment.</li><li class="listitem"><span class="command"><strong>total-pds</strong></span> - total number of prefixes available
              of DHCPv6 management in the subnet. In other words, this is the sum of all prefixes
              in all the configured prefix pools in the subnet.</li><li class="listitem"><span class="command"><strong>assigned-pds</strong></span> - number of prefixes in the subnet
              that are currently assigned to a client.</li></ul></div></li><li class="listitem"><p><span class="command"><strong>rows</strong></span> - a list of rows, one per subnet ID. Each row
            contains a data value for corresponding to and in the same order as each column
            listed in "columns" for a given subnet.
            </p></li><li class="listitem"><p><span class="command"><strong>timestamp</strong></span> - textual date and time the data was fetched,
            expressed as GMT</p></li></ul></div><p>
        </p></li></ul></div><p>
  </p><p>
      The response to a DHCPv4 command might look as follows:
</p><pre class="screen">
  {
    "result": 0,
    "text": "stat-lease4-get: 2 rows found",
    "arguments": {
      "result-set": {
        "columns": [ "subnet-id", "total-addresses", "assigned-addresses", "declined-addresses" ]
        "rows": [
          [ 10, 256, 111, 0 ],
          [ 20, 4098, 2034, 4 ]
        ],
      "timestamp": "2018-05-04 15:03:37.000000"
      }
    }
  }
</pre><p>
    </p><p>
      The response to a DHCPv6 command might look as follows (subnet 10 has no
      prefix pools, subnet 20 has no NA pools, and subnet 30 has both NA and PD
      pools):
</p><pre class="screen">
  {
    "result": 0,
    "text": "stat-lease6-get: 2 rows found",
    "arguments": {
      "result-set": {
        "columns": [ "subnet-id", "total-nas", "assigned-nas", "declined-nas", "total-pds", "assigned-pds" ]
        "rows": [
          [ 10, 4096, 2400, 3, 0, 0],
          [ 20, 0, 0, 0, 1048, 233 ]
          [ 30, 256, 60, 0, 1048, 15 ]
        ],
      "timestamp": "2018-05-04 15:03:37.000000"
      }
    }
  }
</pre><p>
    </p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="user-context"></a>14.5. User contexts</h2></div></div></div><p>Hook libraries can have their own configuration parameters. That is
      convenient if the parameter applies to the whole library. However,
      sometimes it is very useful if certain configuration entities are extended
      with additional configuration data. This is where the concept of user
      contexts comes in. A sysadmin can define an arbitrary set of data and
      attach it to Kea structures, as long as the data is specified as JSON map.
      In particular, it is possible to define fields that are integers, strings,
      boolean, lists and maps. It is possible to define nested structures of
      arbitrary complexity. Kea does not use that data on its own, simply stores
      and makes it available for the hook libraries.
      </p><p>
        Another use case for user contexts may be storing comments and other
        information that will be retained by Kea. Regular comments are discarded
        when configuration is loaded, but user contexts are retained. This is
        useful if you want your comments to survive config-set, config-get
        operations for example.
      </p><p>
        If user context is supported in a given context, the parser translates
        "comment" entries into user context with a "comment" entry. The pretty
        print of a configuration does the opposite operation and puts "comment"
        entries at the beginning of maps as it seems to be the common usage.
      </p><p>
        As of Kea 1.3, the structures that allow user contexts are
        pools of all types (addresses and prefixes) and subnets. Kea
        1.4 extended user context support to the global scope, interfaces config,
        shared networks, subnets, client classes, option datas and definitions,
        host reservations, control socket, dhcp ddns, loggers and server id.
        These are supported in both DHCPv4 and DHCPv6 at the exception
        of server id which is DHCPv6 only.
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="stats"></a>Chapter 15. Statistics</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idp59230016">15.1. Statistics Overview</a></span></dt><dt><span class="section"><a href="#stats-lifecycle">15.2. Statistics Lifecycle</a></span></dt><dt><span class="section"><a href="#command-stats">15.3. Commands for Manipulating Statistics</a></span></dt><dd><dl><dt><span class="section"><a href="#command-statistic-get">15.3.1. statistic-get command</a></span></dt><dt><span class="section"><a href="#command-statistic-reset">15.3.2. statistic-reset command</a></span></dt><dt><span class="section"><a href="#command-statistic-remove">15.3.3. statistic-remove command</a></span></dt><dt><span class="section"><a href="#command-statistic-get-all">15.3.4. statistic-get-all command</a></span></dt><dt><span class="section"><a href="#command-statistic-reset-all">15.3.5. statistic-reset-all command</a></span></dt><dt><span class="section"><a href="#command-statistic-remove-all">15.3.6. statistic-remove-all command</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp59230016"></a>15.1. Statistics Overview</h2></div></div></div><p>Both Kea DHCP servers support statistics gathering.
    A working DHCP server encounters various events
    that can cause certain statistics to be collected. For
    example, a DHCPv4 server may receive a packet (pkt4-received
    statistic increases by one) that after parsing was identified as a
    DHCPDISCOVER (pkt4-discover-received). The Server processed it and
    decided to send a DHCPOFFER representing its answer (pkt4-offer-sent
    and pkt4-sent statistics increase by one). Such events happen
    frequently, so it is not uncommon for the statistics to have
    values in high thousands. They can serve as an easy and powerful
    tool for observing a server's and network's health. For example,
    if pkt4-received statistic stops growing, it means that the
    clients' packets are not reaching the server.</p><p>There are four types of statistics:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="emphasis"><em>integer</em></span> - this is the most common type.  It
        is implemented as 64 bit integer (int64_t in C++), so it can hold any
        value between -2^63 to 2^63 -1.</li><li class="listitem"><span class="emphasis"><em>floating point</em></span> - this type is intended to
        store floating point precision. It is implemented as double C++ type.
        </li><li class="listitem"><span class="emphasis"><em>duration</em></span> - this type is intended for
        recording time periods. It uses boost::posix_time::time_duration type,
        which stores hours, minutes, seconds and microseconds.</li><li class="listitem"><span class="emphasis"><em>string</em></span> - this type is intended for
        recording statistics in textual form. It uses std::string C++ type.
        </li></ul></div><p>
    </p><p>
      During normal operation, DHCPv4 and DHCPv6 servers gather statistics.
      For a list of DHCPv4 and DHCPv6 statistics, see <a class="xref" href="#dhcp4-stats" title="8.8. Statistics in the DHCPv4 Server">Section 8.8, “Statistics in the DHCPv4 Server”</a> and <a class="xref" href="#dhcp6-stats" title="9.12. Statistics in the DHCPv6 Server">Section 9.12, “Statistics in the DHCPv6 Server”</a>, respectively.
    </p><p>
      To extract data from the statistics module, the control channel can be
      used. See <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a> for details. It is possible to
      retrieve a single or all statistics, reset statistics (i.e. set to neutral
      value, typically zero) or even remove completely a single or all
      statistics. See section <a class="xref" href="#command-stats" title="15.3. Commands for Manipulating Statistics">Section 15.3, “Commands for Manipulating Statistics”</a> for a list of
      statistic oriented commands.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="stats-lifecycle"></a>15.2. Statistics Lifecycle</h2></div></div></div><p>
      It is useful to understand how the Statistics Manager module works. When
      the server starts operation, the manager is empty and does not have any
      statistics. When <span class="command"><strong>statistic-get-all</strong></span> is executed, an
      empty list is returned. Once the server performs an operation that causes
      a statistic to change, the related statistic will be created. In the general
      case, once a statistic is recorded even once, it is kept in the manager, until
      explicitly removed, by <span class="command"><strong>statistic-remove</strong></span> or
       <span class="command"><strong>statistic-remove-all</strong></span> being called or the server is shut
      down. Per subnet statistics are explicitly removed when reconfiguration
      takes place.
    </p><p>
      Statistics are considered run-time properties, so they are not retained
      after server restart.
    </p><p>
      Removing a statistic that is updated frequently makes little sense as it
      will be re-added when the server code next records that statistic.
      The <span class="command"><strong>statistic-remove</strong></span> and
      <span class="command"><strong>statistic-remove-all</strong></span> commands are intended to remove
      statistics that are not expected to be observed in the near future. For
      example, a misconfigured device in a network may cause clients to report
      duplicate addresses, so the server will report increasing values of
      pkt4-decline-received. Once the problem is found and the device is
      removed, the system administrator may want to remove the
      pkt4-decline-received statistic, so it won't be reported anymore. If a
      duplicate address is detected ever again, the server will add this
      statistic back.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="command-stats"></a>15.3. Commands for Manipulating Statistics</h2></div></div></div><p>
      There are several commands defined that can be used for accessing (-get),
      resetting to zero or neutral value (-reset) or even removing a statistic
      completely (-remove). The difference between reset and remove is somewhat
      subtle.  The reset command sets the value of the statistic to zero or neutral
      value. After this operation, the statistic will have a value of 0 (integer),
      0.0 (float), 0h0m0s0us (duration) or "" (string). When asked for, a statistic
      with the values mentioned will be returned. <span class="command"><strong>Remove</strong></span> removes
      a statistic completely, so the statistic will not be reported anymore. Please
      note that the server code may add it back if there's a reason to record
      it.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
    The following sections describe commands that can be sent to the server: the
    examples are not fragments of a configuration file.  For more information on
    sending commands to Kea, see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>.
    </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-get"></a>15.3.1. statistic-get command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-get</em></span> command retrieves a single
        statistic. It takes a single string parameter called
        <span class="command"><strong>name</strong></span> that specifies the statistic name.  An example
        command may look like this:
</p><pre class="screen">
{
    "command": "statistic-get",
    "arguments": {
        "name": "<strong class="userinput"><code>pkt4-received</code></strong>"
    }
}
</pre><p>
      </p><p>
        The server will respond with details of the requested statistic, with result
        set to 0 indicating success and the specified statistic as the value of
        "arguments" parameter. If the requested statistic is not found, the response
        will contain an empty map, i.e. only { } as argument, but the status
        code will still be set to success (0).
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-reset"></a>15.3.2. statistic-reset command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-reset</em></span> command sets the specified statistic
        to its neutral value: 0 for integer, 0.0 for float, 0h0m0s0us for time
        duration and "" for string type. It takes a single string parameter
        called <span class="command"><strong>name</strong></span> that specifies the statistic name.  An
        example command may look like this:
</p><pre class="screen">
{
    "command": "statistic-reset",
    "arguments": {
        "name": "<strong class="userinput"><code>pkt4-received</code></strong>"
    }
}
</pre><p>
      </p><p>
        If the specific statistic is found and reset was successful, the
        server will respond with a status of 0, indicating success and an empty
        parameters field. If an error is encountered (e.g. requested statistic
        was not found), the server will return a status code of 1 (error)
        and the text field will contain the error description.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-remove"></a>15.3.3. statistic-remove command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-remove</em></span> command attempts to delete a single
        statistic. It takes a single string parameter called
        <span class="command"><strong>name</strong></span> that specifies the statistic name.  An example
        command may look like this:
</p><pre class="screen">
{
    "command": "statistic-remove",
    "arguments": {
        "name": "<strong class="userinput"><code>pkt4-received</code></strong>"
    }
}
</pre><p>
      </p><p>
        If the specific statistic is found and its removal was successful, the
        server will respond with a status of 0, indicating success and an empty
        parameters field. If an error is encountered (e.g. requested statistic
        was not found), the server will return a status code of 1 (error)
        and the text field will contain the error description.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-get-all"></a>15.3.4. statistic-get-all command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-get-all</em></span> command retrieves all statistics
        recorded. An example command may look like this:
</p><pre class="screen">
{
    "command": "statistic-get-all",
    "arguments": { }
}
</pre><p>
      </p><p>
        The server will respond with details of all recorded statistics, with result
        set to 0 indicating that it iterated over all statistics (even when
        the total number of statistics is zero).
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-reset-all"></a>15.3.5. statistic-reset-all command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-reset</em></span> command sets all statistics to
        their neutral values: 0 for integer, 0.0 for float, 0h0m0s0us for time
        duration and "" for string type. An example command may look like this:
</p><pre class="screen">
{
    "command": "statistic-reset-all",
    "arguments": { }
}
</pre><p>
      </p><p>
        If the operation is successful, the server will respond with a status of
        0, indicating success and an empty parameters field. If an error is
        encountered, the server will return a status code of 1 (error) and the text
        field will contain the error description.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-statistic-remove-all"></a>15.3.6. statistic-remove-all command</h3></div></div></div><p>
        <span class="emphasis"><em>statistic-remove-all</em></span> command attempts to delete all
        statistics. An example command may look like this:
</p><pre class="screen">
{
    "command": "statistic-remove-all",
    "arguments": { }
}
</pre><p>
      </p><p>
        If the removal of all statistics was successful, the server will respond
        with a status of 0, indicating success and an empty parameters field. If
        an error is encountered, the server will return a status code of 1 (error)
        and the text field will contain the error description.
      </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="ctrl-channel"></a>Chapter 16. Management API</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#ctrl-channel-syntax">16.1. Data Syntax</a></span></dt><dt><span class="section"><a href="#ctrl-channel-client">16.2. Using the Control Channel</a></span></dt><dt><span class="section"><a href="#commands-common">16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers</a></span></dt><dd><dl><dt><span class="section"><a href="#command-build-report">16.3.1. build-report</a></span></dt><dt><span class="section"><a href="#command-config-get">16.3.2. config-get</a></span></dt><dt><span class="section"><a href="#command-config-reload">16.3.3. config-reload</a></span></dt><dt><span class="section"><a href="#command-config-test">16.3.4. config-test</a></span></dt><dt><span class="section"><a href="#command-config-write">16.3.5. config-write</a></span></dt><dt><span class="section"><a href="#command-leases-reclaim">16.3.6. leases-reclaim</a></span></dt><dt><span class="section"><a href="#command-libreload">16.3.7. libreload</a></span></dt><dt><span class="section"><a href="#command-list-commands">16.3.8. list-commands</a></span></dt><dt><span class="section"><a href="#command-config-set">16.3.9. config-set</a></span></dt><dt><span class="section"><a href="#command-shutdown">16.3.10. shutdown</a></span></dt><dt><span class="section"><a href="#command-dhcp-disable">16.3.11. dhcp-disable</a></span></dt><dt><span class="section"><a href="#command-dhcp-enable">16.3.12. dhcp-enable</a></span></dt><dt><span class="section"><a href="#command-version-get">16.3.13. version-get</a></span></dt></dl></dd><dt><span class="section"><a href="#agent-commands">16.4. Commands Supported by Control Agent</a></span></dt></dl></div><p>A classic approach to daemon configuration assumes that
    the server's configuration is stored in configuration files
    and, when the configuration is changed, the daemon is restarted.
    This approach has the significant disadvantage of introducing periods
    of downtime, when client traffic is not handled. Another risk
    is that if the new configuration is invalid for whatever reason,
    the server may refuse to start, which will further extend the
    downtime period until the issue is resolved.</p><p>To avoid such problems, both the DHCPv4 and DHCPv6 servers
    include support for a mechanism that allows
    on-line reconfiguration without requiring server shutdown.
    Both servers can be instructed to open control sockets, which
    is a communication channel. The server is able to receive
    commands on that channel, act on them and report back status.
    While the set of commands in Kea 1.2.0 is limited,
    the number is expected to grow over time.</p><p>The DHCPv4 and DHCPv6 servers receive commands over the
    unix domain sockets. The details how to configure these sockets,
    see <a class="xref" href="#dhcp4-ctrl-channel" title="8.9. Management API for the DHCPv4 Server">Section 8.9, “Management API for the DHCPv4 Server”</a> and <a class="xref" href="#dhcp6-ctrl-channel" title="9.13. Management API for the DHCPv6 Server">Section 9.13, “Management API for the DHCPv6 Server”</a>. While it is possible control
    the servers directly using unix domain sockets it requires that
    the controlling client be running on the same machine as
    the server. In order to connect remotely SSH is usually used to
    connect to the controlled machine.</p><p>The network administrators usually prefer using some form
    of a RESTful API to control the servers, rather than using unix
    domain sockets directly. Therefore, as of Kea 1.2.0 release,
    Kea includes a new component called Control Agent (or CA) which
    exposes a RESTful API to the controlling clients and can forward
    commands to the respective Kea services over the unix domain
    sockets. The CA configuration has been described in
    <a class="xref" href="#agent-configuration" title="7.2. Configuration">Section 7.2, “Configuration”</a>.</p><p>The HTTP requests received by the CA contain the control
    commands encapsulated within HTTP requests. Simply speaking,
    the CA is responsible for stripping the HTTP layer from the
    received commands and forwarding the commands in a JSON format
    over the unix domain sockets to respective services. Because the
    CA receives commands for all services it requires additional
    "forwarding" information to be included in the client's messages.
    This "forwarding" information is carried within the
    <span class="command"><strong>service</strong></span> parameter of the received command.
    If the <span class="command"><strong>service</strong></span> parameter is not included or if
    the parameter is a blank list the CA will assume that the control
    command is targetted at the CA itself and will try to handle
    it on its own.
    </p><p>Control connections over both HTTP and unix domain sockets are
    guarded with timeouts. The default timeout value is set to 10s
    and is not configurable. The timeout configuration will be
    implemented in the future.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Kea 1.2.0 release and earlier had a limitation of 64kB
      on the maximum size of a command and a response sent over the unix
      domain socket. This limitation has been removed in Kea 1.3.0
      release.
      </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ctrl-channel-syntax"></a>16.1. Data Syntax</h2></div></div></div><p>Communication over the control channel is conducted using JSON
    structures. If configured, Kea will open a socket and listen
    for incoming connections. A process connecting to this socket
    is expected to send JSON commands structured as follows:

</p><pre class="screen">
{
    "command": "foo",
    "service": [ "dhcp4" ]
    "arguments": {
        "param1": "value1",
        "param2": "value2",
        ...
    }
}
</pre><p>

    The same command sent over the RESTful interface to the CA will have
    the following structure.

</p><pre class="screen">
    POST / HTTP/1.1\r\n
    Content-Type: application/json\r\n
    Content-Length: 147\r\n\r\n
    {
        "command": "foo",
        "service": [ "dhcp4" ]
        "arguments": {
            "param1": "value1",
            "param2": "value2",
            ...
        }
    }
</pre><p>

    <span class="command"><strong>command</strong></span> is the name of command to execute and
    is mandatory. <span class="command"><strong>arguments</strong></span> is a map of parameters
    required to carry out the given command.  The exact content and
    format of the map is command specific.</p><p>
      <span class="command"><strong>service</strong></span> is a list of the servers at which the control
      command is targetted. In the example above, the control command is
      targetted at the DHCPv4 server. In most cases, the CA will simply forward this
      command to the DHCPv4 server for processing via unix domain socket.
      Sometimes, the command including a service value may also be processed by the
      CA, if the CA is running a hooks library which handles such command for the
      given server. As an example, the hooks library attached to the CA
      may perform some operations on the database (like adding host reservations,
      modifying leases etc.). An advantage of performing DHCPv4 specific
      administrative operations in the CA rather than forwarding it to
      the DHCPv4 server is the ability to perform these operations without
      disrupting the DHCPv4 service (DHCPv4 server doesn't have to stop
      processing DHCP messages to apply changes to the database). Nevertheless,
      these situations are rather rare and, in most cases, when the
      <span class="command"><strong>service</strong></span> parameter contains a name of the service
      the commands are simply forwarded by the CA. The forwarded command
      includes the <span class="command"><strong>service</strong></span> parameter but this parameter
      is ignored by the receiving server. This parameter is only meaningful
      to the CA.
    </p><p>
      If the command received by the CA does not include a <span class="command"><strong>service</strong></span>
      parameter or this list is empty, the CA will simply process this message
      on its own. For example, the <span class="command"><strong>config-get</strong></span> command which
      doesn't include service parameter will return Control Agent's own
      configuration. The <span class="command"><strong>config-get</strong></span> including a service
      value "dhcp4" will be forwarded to the DHCPv4 server and will return
      DHCPv4 server's configuration and so on.
    </p><p>
      The following list contains a mapping of the values carried within the
      <span class="command"><strong>service</strong></span> parameter to the servers to which the commands
      are forwarded:

      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><span class="command"><strong>dhcp4</strong></span> - the command is forwarded to the
          <span class="command"><strong>kea-dhcp4</strong></span> server,</li><li class="listitem"><span class="command"><strong>dhcp6</strong></span> - the command is forwarded to the
          <span class="command"><strong>kea-dhcp6</strong></span> server,</li><li class="listitem"><span class="command"><strong>d2</strong></span> - the command is forwarded to the
          <span class="command"><strong>kea-d2</strong></span> server.</li></ul></div><p>
    </p><p>The server processing the incoming command will send a response of
    the form:
</p><pre class="screen">
{
    "result": 0|1|2|3,
    "text": "textual description",
    "arguments": {
        "argument1": "value1",
        "argument2": "value2",
        ...
    }
}
</pre><p>
    <span class="command"><strong>result</strong></span> indicates the outcome of the command. A value of 0
    means success while any non-zero value designates an error or at least a
    failure to complete the requested action. Currently 1 is used as a generic
    error, 2 means that a command is not supported and 3 means that the
    requested operation was completed, but the requested object was not
    found. Additional error codes may be added in the future. For example a well
    formed command that requests a subnet that exists in server's configuration
    would return result 0. If the server encounters an error condition, it would
    return 1. If the command was asking for IPv6 subnet, but was sent to DHCPv4
    server, it would return 2. If the query was asking for a subnet-id and there
    is no subnet with such id, the result would be set to 3.</p><p>
    The <span class="command"><strong>text</strong></span> field typically appears when result is non-zero
    and contains a description of the error encountered, but it often also appears
    for successful outcomes. The exact text is command specific, but in general
    uses plain English to describe the outcome of the command.
    <span class="command"><strong>arguments</strong></span> is a map of additional data values
    returned by the server which is specific to the command issued. The map is
    may be present, but that depends on specific command.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
        When sending commands via Control Agent, it is possible to specify
        multiple services at which the command is targetted. CA will forward this
        command to each service individually. Thus, the CA response to the
        controlling client will contain an array of individual responses.
      </p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ctrl-channel-client"></a>16.2. Using the Control Channel</h2></div></div></div><p>Kea development team is actively working on providing client applications
    which can be used to control the servers. These applications are, however, in the
    early stages of development and as of Kea 1.2.0 release have certain limitations.
    The easiest way to start interacting with the control API is to use common Unix/Linux tools
    such as <span class="command"><strong>socat</strong></span> and <span class="command"><strong>curl</strong></span>.</p><p>In order to control the given Kea service via unix domain socket, use
    <span class="command"><strong>socat</strong></span> as follows:
</p><pre class="screen">
$ socat UNIX:/path/to/the/kea/socket -
</pre><p>
where <span class="command"><strong>/path/to/the/kea/socket</strong></span> is the path specified in the
<span class="command"><strong>Dhcp4/control-socket/socket-name</strong></span> parameter in the Kea
configuration file. Text passed to <span class="command"><strong>socat</strong></span>
will be sent to Kea and the responses received from Kea printed to standard
    output. This approach communicates with the specific server directly and
    bypasses Control Agent.</p><p>It is also easy to open UNIX socket programmatically. An example of
    such a simplistic client written in C is available in the Kea Developer's
    Guide, chapter Control Channel Overview, section Using Control Channel.</p><p>In order to use Kea's RESTful API with <span class="command"><strong>curl</strong></span> you may
    use the following:
</p><pre class="screen">
$ curl -X POST -H "Content-Type: application/json" -d '{ "command": "config-get", "service": [ "dhcp4" ] }' http://ca.example.org:8000/
</pre><p>

    This assumes that the Control Agent is running on host
    <code class="filename">ca.example.org</code> and runs RESTful service on port 8000.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="commands-common"></a>16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-build-report"></a>16.3.1. build-report</h3></div></div></div><p>
          The <span class="emphasis"><em>build-report</em></span> command returns
          on the control channel what the command line
          <span class="command"><strong>-W</strong></span> argument displays, i.e. the embedded
          content of the <code class="filename">config.report</code> file.
          This command does not take any parameters.
        </p><pre class="screen">
{
    "command": "build-report"
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-config-get"></a>16.3.2. config-get</h3></div></div></div><p>The <span class="emphasis"><em>config-get</em></span> command retrieves the current
        configuration used by the server. This command does not take any
        parameters. The configuration returned is roughly equal to the
        configuration that was loaded using -c command line option during server
        start-up or later set using config-set command. However, there may be
        certain differences. Comments are not retained. If the original
        configuration used file inclusion, the returned configuration will
        include all parameters from all the included files.</p><p> Note that returned configuration is not redacted, i.e. it will
        contain database passwords in plain text if those were specified in the
        original configuration. Care should be taken to not expose the command
        channel to unprivileged users.</p><p>
          An example command invocation looks like this:
</p><pre class="screen">
{
    "command": "config-get"
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-config-reload"></a>16.3.3. config-reload</h3></div></div></div><p>The <span class="emphasis"><em>config-reload</em></span> command instructs
        Kea to load again the configuration file that was used
        previously. This operation is useful if the configuration file
        has been changed by some external sources. For example, a
        sysadmin can tweak the configuration file and use this command
        to force Kea pick up the changes.</p><p>Caution should be taken when mixing this with config-set
        commands. Kea remembers the location of the configuration file
        it was started with. This configuration can be significantly
        changed using config-set command. When config-reload is issued
        after config-set, Kea will attempt to reload its original
        configuration from the file, possibly losing all changes
        introduced using config-set or other commands.</p><p><span class="emphasis"><em>config-reload</em></span> does not take any parameters.
        An example command invocation looks like this:
</p><pre class="screen">
{
    "command": "config-reload"
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-config-test"></a>16.3.4. config-test</h3></div></div></div><p>
     The <span class="emphasis"><em>config-test</em></span> command instructs the server to check
     whether the new configuration supplied in the command's arguments can
     be loaded. The supplied configuration is expected to be the full
     configuration for the target server along with an optional Logger
     configuration. As for the <span class="command"><strong>-t</strong></span> command some sanity checks
     are not performed so it is possible a configuration which successfully
     passes this command will still fail in <span class="command"><strong>config-set</strong></span>
     command or at launch time.
     The structure of the command is as follows:
      </p><pre class="screen">
{
    "command": "config-test",
    "arguments":  {
        "&lt;server&gt;": {
        },
        "Logging": {
        }
     }
}
</pre><p>
    where &lt;server&gt; is the configuration element name for a given server
    such as "Dhcp4" or "Dhcp6".  For example:
      </p><pre class="screen">
{
    "command": "config-test",
    "arguments":  {
        "Dhcp6": {
            :
        },
        "Logging": {
            :
        }
     }
}
</pre><p>
        The server's response will contain a numeric code, "result" (0 for success,
    non-zero on failure), and  a string, "text", describing the outcome:
</p><pre class="screen">
    {"result": 0, "text": "Configuration seems sane..." }

    or

    {"result": 1, "text": "unsupported parameter: BOGUS (&lt;string&gt;:16:26)" }
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-config-write"></a>16.3.5. config-write</h3></div></div></div><p>The <span class="emphasis"><em>config-write</em></span> command instructs Kea server
        to write its current configuration to a file on disk. It takes one
        optional argument called <span class="emphasis"><em>filename</em></span> that specifies
        the name of the file to write configuration to. If not specified, the
        name used when starting Kea (passed as -c argument) will be
        used. If relative path is specified, Kea will write its files
        only in the directory it is running.</p><p>
          An example command invocation looks like this:
</p><pre class="screen">
{
    "command": "config-write",
    "arguments": {
        "filename": "config-modified-2017-03-15.json"
    }
}
</pre><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-leases-reclaim"></a>16.3.6. leases-reclaim</h3></div></div></div><p>
          The <span class="emphasis"><em>leases-reclaim</em></span> command instructs the server to
          reclaim all expired leases immediately. The command has the following
          JSON syntax:
</p><pre class="screen">
{
    "command": "leases-reclaim",
    "arguments": {
        "remove": true
    }
}
</pre><p>
        </p><p>The <span class="emphasis"><em>remove</em></span> boolean parameter is mandatory
        and it indicates whether the reclaimed leases should be removed from
        the lease database (if true), or they should be left in the
        <span class="emphasis"><em>expired-reclaimed</em></span> state (if false). The latter
        facilitates lease affinity, i.e. ability to re-assign expired lease to
        the same client which used this lease before. See
        <a class="xref" href="#lease-affinity" title="10.3. Configuring Lease Affinity">Section 10.3, “Configuring Lease Affinity”</a> for the details. Also, see
        <a class="xref" href="#lease-reclamation" title="10.1. Lease Reclamation">Section 10.1, “Lease Reclamation”</a> for the general information
        about the processing of expired leases (leases reclamation).</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-libreload"></a>16.3.7. libreload</h3></div></div></div><p>
          The <span class="emphasis"><em>libreload</em></span> command will first unload and then
          load all currently loaded hook libraries.  This is primarily intended
          to allow one or more hook libraries to be replaced with newer versions
          without requiring Kea servers to be reconfigured or restarted.  Note
          the hook libraries will be passed the same parameter values (if any)
          they were passed when originally loaded.
</p><pre class="screen">
{
    "command": "libreload",
    "arguments": { }
}
</pre><p>
       </p><p>
         The server will respond with a result of 0 indicating success, or 1
         indicating a failure.
       </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-list-commands"></a>16.3.8. list-commands</h3></div></div></div><p>
        The <span class="emphasis"><em>list-commands</em></span> command retrieves a list of all
        commands supported by the server. It does not take any arguments.
        An example command may look like this:
</p><pre class="screen">
{
    "command": "list-commands",
    "arguments": { }
}
</pre><p>
      </p><p>
        The server will respond with a list of all supported commands. The
        arguments element will be a list of strings. Each string will convey
        one supported command.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-config-set"></a>16.3.9. config-set</h3></div></div></div><p>
    The <span class="emphasis"><em>config-set</em></span> command instructs the server to replace
    its current configuration with the new configuration supplied in the
    command's arguments. The supplied configuration is expected to be the full
    configuration for the target server along with an optional Logger
    configuration.  While optional, the Logger configuration is highly
    recommended as without it the server will revert to its default logging
    configuration. The structure of the command is as follows:
      </p><pre class="screen">
{
    "command": "config-set",
    "arguments":  {
        "&lt;server&gt;": {
        },
        "Logging": {
        }
     }
}
</pre><p>
    where &lt;server&gt; is the configuration element name for a given server
    such as "Dhcp4" or "Dhcp6".  For example:
      </p><pre class="screen">
{
    "command": "config-set",
    "arguments":  {
        "Dhcp6": {
            :
        },
        "Logging": {
            :
        }
     }
}
</pre><p>
    If the new configuration proves to be invalid the server will retain
    its current configuration.  Please note that the new configuration is
    retained in memory only.  If the server is restarted or a configuration
    reload is triggered via a signal, the server will use the configuration
    stored in its configuration file.

        The server's response will contain a numeric code, "result" (0 for success,
    non-zero on failure), and  a string, "text", describing the outcome:
</p><pre class="screen">
    {"result": 0, "text": "Configuration successful." }

    or

    {"result": 1, "text": "unsupported parameter: BOGUS (&lt;string&gt;:16:26)" }
</pre><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-shutdown"></a>16.3.10. shutdown</h3></div></div></div><p>
        The <span class="emphasis"><em>shutdown</em></span> command instructs the server to initiate
        its shutdown procedure. It is the equivalent of sending a SIGTERM signal
        to the process. This command does not take any arguments.  An example
        command may look like this:
</p><pre class="screen">
{
    "command": "shutdown"
}
</pre><p>
      </p><p>
        The server will respond with a confirmation that the shutdown procedure
        has been initiated.
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-dhcp-disable"></a>16.3.11. dhcp-disable</h3></div></div></div><p>
        The <span class="emphasis"><em>dhcp-disable</em></span> command globally disables the DHCP
        service. The server continues to operate, but it drops all received DHCP
        messages. This command is useful when the server's maintenance requires that
        the server temporarily stops allocating new leases and renew existing leases.
        It is also useful in failover like configurations during a synchronization of
        the lease databases at startup or recovery after a failure. The optional parameter
        <span class="emphasis"><em>max-period</em></span> specifies the time in seconds after which the
        DHCP service should be automatically re-enabled if the
        <span class="emphasis"><em>dhcp-enable</em></span> command is not sent before this time elapses.
      </p><pre class="screen">
{
    "command": "dhcp-disable",
    "arguments": {
        "max-period": 20
    }
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-dhcp-enable"></a>16.3.12. dhcp-enable</h3></div></div></div><p>
        The <span class="emphasis"><em>dhcp-enable</em></span> command globally enables the DHCP
        service.
      </p><pre class="screen">
{
    "command": "dhcp-enable"
}
</pre></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="command-version-get"></a>16.3.13. version-get</h3></div></div></div><p>
          The <span class="emphasis"><em>version-get</em></span> command returns on the control
          channel what the command line <span class="command"><strong>-v</strong></span> argument
          displays with in arguments the extended version, i.e., what
          the command line <span class="command"><strong>-V</strong></span> argument displays. This command
          does not take any parameters.
        </p><pre class="screen">
{
    "command": "version-get"
}
</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="agent-commands"></a>16.4. Commands Supported by Control Agent</h2></div></div></div><p>The following commands listed in <a class="xref" href="#commands-common" title="16.3. Commands Supported by Both the DHCPv4 and DHCPv6 Servers">Section 16.3, “Commands Supported by Both the DHCPv4 and DHCPv6 Servers”</a>
      are also supported by the Control Agent, i.e. when the
      <span class="command"><strong>service</strong></span> parameter is blank the commands are handled
      by the CA and they relate to the CA process itself:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">build-report</li><li class="listitem">config-get</li><li class="listitem">config-test</li><li class="listitem">config-write</li><li class="listitem">list-commands</li><li class="listitem">shutdown</li><li class="listitem">version-get</li></ul></div><p>
      </p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="libdhcp"></a>Chapter 17. The libdhcp++ Library</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#iface-detect">17.1. Interface detection and Socket handling</a></span></dt></dl></div><p>
      libdhcp++ is a library written in C++ that handles
      many DHCP-related tasks, including:
      </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">DHCPv4 and DHCPv6 packets parsing, manipulation and assembly</li><li class="listitem">Option parsing, manipulation and assembly</li><li class="listitem">Network interface detection</li><li class="listitem">Socket operations such as creation, data transmission and reception and socket closing.</li></ul></div><p>
    </p><p>
    While this library is currently used by Kea, it is designed to
    be a portable, universal library, useful for any kind of DHCP-related software.
    </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="iface-detect"></a>17.1. Interface detection and Socket handling</h2></div></div></div><p>Both the DHCPv4 and DHCPv6 components share network
      interface detection routines. Interface detection is
      currently supported on Linux, all BSD family (FreeBSD, NetBSD,
      OpenBSD), Mac OS X and Solaris 11 systems.</p><p>DHCPv4 requires special raw socket processing to send and receive
      packets from hosts that do not have IPv4 address assigned. Support
      for this operation is implemented on Linux, FreeBSD, NetBSD and OpenBSD.
      It is likely that DHCPv4 component will not work in certain cases on
      other systems.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="logging"></a>Chapter 18. Logging</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#idp59399776">18.1. Logging Configuration</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59402512">18.1.1. Loggers</a></span></dt><dt><span class="section"><a href="#logging-message-format">18.1.2. Logging Message Format</a></span></dt><dt><span class="section"><a href="#logging-during-startup">18.1.3. Logging During Kea Startup</a></span></dt></dl></dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp59399776"></a>18.1. Logging Configuration</h2></div></div></div><p>
      During its operation Kea may produce many messages. They differ in
      severity (some are more important than others) and source (some are
      produced by specific components, e.g. hooks). It is useful to understand
      which log messages are needed and which are not, and configure your
      logging appropriately. For example, debug level messages can be safely
      ignored in a typical deployment. They are, however, very useful when
      debugging a problem.
    </p><p>
      The logging system in Kea is configured through the
      Logging section in your configuration
      file. All daemons (e.g. DHCPv4 and DHCPv6 servers) will use the
      configuration in the Logging section to see
      what should be logged and to where. This allows for sharing identical
      logging configuration between daemons.
    </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp59402512"></a>18.1.1. Loggers</h3></div></div></div><p>
        Within Kea, a message is logged through an entity called a
        "logger". Different components log messages through different
        loggers, and each logger can be configured independently of
        one another. Some components, in particular the DHCP server
        processes, may use multiple loggers to log messages pertaining
        to different logical functions of the component. For example,
        the DHCPv4 server uses one logger for messages
        pertaining to packet reception and transmission, another
        logger for messages related to lease allocation and so on.
        Some of the libraries used by the Kea servers, e.g. libdhcpsrv,
        use their own loggers.
      </p><p>
        Users implementing hooks libraries (code attached to the server at
        runtime) are responsible for creating the loggers used by those
        libraries. Such loggers should have unique names, different
        from the logger names used by Kea. In this way the
        messages output by the hooks library can be distinguished from
        messages issued by the core Kea code. Unique names also allow
        the loggers to be configured independently of loggers used
        by Kea.  Whenever it makes sense, a hook library can use multiple
        loggers to log messages pertaining to different logical parts
        of the library.
      </p><p>
        In the Logging section of a configuration file you can specify the
        configuration for zero or more loggers (including loggers used by the
        proprietary hooks libraries). If there are no loggers specified, the
        code will use default values: these cause Kea to log messages of INFO
        severity or greater to standard output. There is also a small
        time window after Kea has been started, but has not yet read its
        configuration. Logging in this short period can be controlled
        using environment variables. For details, see <a class="xref" href="#logging-during-startup" title="18.1.3. Logging During Kea Startup">Section 18.1.3, “Logging During Kea Startup”</a>.
      </p><p>
        The three main elements of a logger configuration are:
        <span class="command"><strong>name</strong></span> (the component that is generating the messages),
        the <span class="command"><strong>severity</strong></span> (what to log), and the
        <span class="command"><strong>output_commands</strong></span> (where to log).  There is also a
        <span class="command"><strong>debuglevel</strong></span> element, which is only relevant if
        debug-level logging has been selected.
      </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59409824"></a>18.1.1.1. name (string)</h4></div></div></div><p>
          Each logger in the system has a name, the name being that of the
          component binary file using it to log messages. For instance, if you
          want to configure logging for the DHCPv4 server, you add an entry
          for a logger named <span class="quote">“<span class="quote">kea-dhcp4</span>”</span>. This configuration will
          then be used by the loggers in the DHCPv4 server, and all the
          libraries used by it (unless a library defines its own logger and
          there is specific logger configuration that applies to that logger).
        </p><p>
          When tracking down an issue with the server's operation, use of
          DEBUG logging is required to obtain the verbose output needed for
          problems diagnosis.  However, the high verbosity is likely to
          overwhelm the logging system in cases when the server
          is processing high volume traffic. To mitigate this problem, use
          can be made of the fact that Kea uses multiple loggers for different
          functional parts of the server and that each of these can be configured independently.
          If the user is reasonably confident that a problem originates
          in a specific function of the server, or that the problem is related
          to the specific type of operation, they may enable high verbosity
          only for the relevant logger, so limiting the debug messages
          to the required minimum.
        </p><p>
          The loggers are associated with a particular library or binary
          of Kea. However, each library or binary may (and usually does)
          include multiple loggers. For example, the DHCPv4 server binary
          contains separate loggers for: packet parsing, for dropped packets,
          for callouts etc.
        </p><p>
          The loggers form a hierarchy.  For each program in Kea, there is
          a "root" logger, named after the program (e.g. the root logger for
          kea-dhcp (the DHCPv4 server) is named kea-dhcp4.  All other loggers
          are children of this logger, and are named accordingly, e.g. the
          the allocation engine in the DHCPv4 server logs messages using
          a logger called kea-dhcp4.alloc-engine.
        </p><p>
          This relationship is important as each child logger derives its
          default configuration from its parent root logger.
          In the typical case, the root logger configuration
          is the only logging configuration specified in the configuration
          file and so applies to all loggers. If an entry is made for
          a given logger, any attributes specified override those of
          the root logger, whereas any not specified are inherited from it.
        </p><p>
          To illustrate this, suppose you are using the DHCPv4 server
          with the root logger <span class="quote">“<span class="quote">kea-dhcp4</span>”</span> logging at the
          INFO level. In order to enable DEBUG verbosity for the DHCPv4
          packet drops, you must create configuration entry for the
          logger called <span class="quote">“<span class="quote">kea-dhcp4.bad-packets</span>”</span> and specify
          severity DEBUG for this logger. All other configuration
          parameters may be omitted for this logger if the logger should
          use the default values specified in the root logger's
          configuration.
        </p><p>
          If there are multiple logger specifications in the configuration
          that might match a particular logger, the specification with the
          more specific logger name takes precedence. For example, if there
          are entries for both <span class="quote">“<span class="quote">kea-dhcp4</span>”</span> and
          <span class="quote">“<span class="quote">kea-dhcp4.dhcpsrv</span>”</span>, the DHCPv4 server — and all
          libraries it uses that are not dhcpsrv — will log messages
          according to the configuration in the first entry
          (<span class="quote">“<span class="quote">kea-dhcp4</span>”</span>).
        </p><p>
          Currently defined loggers are:
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              <span class="command"><strong>kea-ctrl-agent</strong></span> - the root logger for the
              Control Agent exposing RESTful control API. All components used
              by the Control Agent inherit the settings from this logger.
            </li><li class="listitem">
              <span class="command"><strong>kea-ctrl-agent.http</strong></span> - a logger which outputs
              log messages related to receiving, parsing and sending HTTP
              messages.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4</strong></span> - the root logger for the DHCPv4
              server. All components used by the DHCPv4 server inherit the
              settings from this logger.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.alloc-engine</strong></span> - used by the lease
              allocation engine, which is responsible for managing leases in the
              lease database, i.e. create, modify and remove DHCPv4 leases as a
              result of processing messages from the clients.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.bad-packets</strong></span> - used by the DHCPv4
              server daemon for logging inbound client packets that were dropped
              or to which the server responded with a DHCPNAK. It allows
              administrators to configure a separate log output that contains
              only packet drop and reject entries.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.callouts</strong></span> - used to log messages
              pertaining to the callouts registration and execution for the
              particular hook point.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.commands</strong></span> - used to log messages
              relating to the handling of commands received by the the DHCPv4
              server over the command channel.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.ddns</strong></span> - used by the DHCPv4 server to
              log messages related to the Client FQDN and Hostname option
              processing. It also includes log messages related to the relevant
              DNS updates.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.dhcp4</strong></span> - used by the DHCPv4 server
              daemon to log basic operations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.dhcpsrv</strong></span> - the base logger for the
              libdhcpsrv library.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.eval</strong></span> - used to log messages relating
              to the client classification expression evaluation code.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.hooks</strong></span> - used to log messages related
              to management of hooks libraries, e.g.  registration and
              deregistration of the libraries, and to the initialization of the
              callouts execution for various hook points within the DHCPv4
              server.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.hosts</strong></span> - used within the libdhcpsrv
              and it logs messages related to the management of the DHCPv4 host
              reservations, i.e. retrieval of the reservations and adding new
              reservations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.leases</strong></span> - used by the DHCPv4 server to
              log messages related to the lease allocation.  The messages
              include detailed information about the allocated or offered
              leases, errors during the lease allocation etc.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.options</strong></span> - used by the DHCPv4 server
              to log messages related to processing of the options in the DHCPv4
              messages, i.e. parsing options, encoding options into on-wire
              format and packet classification using options contained in the
              received packets.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.packets</strong></span> - this logger is mostly used
              to log messages related to transmission of the DHCPv4 packets,
              i.e. packet reception and sending a response. Such messages
              include information about the source and destination IP addresses
              and interfaces used to transmit packets. The logger is also used
              to log messages related to subnet selection, as this selection is
              usually based on the IP addresses and/or interface names, which
              can be retrieved from the received packet, even before the DHCPv4
              message carried in the packet is parsed.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp4.stat-cmds-hooks</strong></span> - this logger is
              used to log messages related to operation of the Stats Cmds hooks
              library. In general these will pertain to loading and unloading
              the library and the execution of commands by the library.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6</strong></span> - the root logger for the DHCPv6
              server. All components used by the DHCPv6 server inherit the
              settings from this logger if there is no specialized logger
              provided.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.alloc-engine</strong></span> - used used by the lease
              allocation engine, which is responsible for managing leases in the
              lease database, i.e. create, modify and remove DHCPv6 leases as a
              result of processing messages from the clients.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.bad-packets</strong></span> - used used by the DHCPv6
              server daemon for logging inbound client packets that were
              dropped.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.callouts</strong></span> - used to log messages
              pertaining to the callouts registration and execution for the
              particular hook point.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.commands</strong></span> - used to log messages
              relating to the handling of commands received by the the DHCPv6
              server over the command channel.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.ddns</strong></span> - this logger is used by the
              DHCPv6 server to log messages related to the Client FQDN option
              processing. It also includes log messages related to the relevant
              DNS updates.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.dhcp6</strong></span> - used DHCPv6 server daemon to
              log basic operations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.dhcpsrv</strong></span> - the base logger for the
              libdhcpsrv library.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.eval</strong></span> - used to log messages relating
              to the client classification expression evaluation code.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.hooks</strong></span> - this logger is used to log
              messages related to management of hooks libraries, e.g.
              registration and deregistration of the libraries, and to the
              initialization of the callouts execution for various hook points
              within the DHCPv6 server.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.hosts</strong></span> - used within the libdhcpsrv
              and it logs messages related to the management of the DHCPv6 host
              reservations, i.e. retrieval of the reservations and adding new
              reservations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.leases</strong></span> - used by the DHCPv6 server to
              log messages related to the lease allocation.  The messages
              include detailed information about the allocated or offered
              leases, errors during the lease allocation etc.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.options</strong></span> - used by the DHCPv6 server
              to log messages related to processing of the options in the DHCPv6
              messages, i.e. parsing options, encoding options into on-wire
              format and packet classification using options contained in the
              received packets.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.packets</strong></span> - this logger is mostly used
              to log messages related to transmission of the DHCPv6 packets,
              i.e. packet reception and sending a response. Such messages
              include the information about the source and destination IP
              addresses and interfaces used to transmit packets. This logger is
              also used to log messages related to subnet selection, as this
              selection is usually based on the IP addresses and/or interface
              names, which can be retrieved from the received packet, even
              before the DHCPv6 message carried in the packet is parsed.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp6.stat-cmds-hooks</strong></span> - this logger is
              used to log messages related to operation of the Stats Cmds hooks
              library. In general these will pertain to loading and unloading
              the library and the execution of commands by the library.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns</strong></span> - the root logger for the
              kea-dhcp-ddns daemon. All components used by this daemon inherit
              the settings from this logger if there is no specialized logger
              provided.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns.dctl</strong></span> - the logger used by the
              kea-dhcp-ddns daemon for logging basic information about the
              process, received signals and triggered reconfigurations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns.dhcpddns</strong></span> - the logger used by the
              kea-dhcp-ddns daemon for logging events related to DDNS operations.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns.dhcp-to-d2</strong></span> - used by the
              kea-dhcp-ddns daemon for logging information about events dealing
              with receiving messages from the DHCP servers and adding them to
              the queue for processing.
            </li><li class="listitem">
              <span class="command"><strong>kea-dhcp-ddns.d2-to-dns</strong></span> - used by the
              kea-dhcp-ddns daemon for logging information about events dealing
              with sending and receiving messages with the DNS servers.
            </li></ul></div><p>
          Note that user-defined hook libraries should not use any of those
          loggers but should define new loggers with names that correspond to
          the libraries using them. Suppose that the user created the library
          called <span class="quote">“<span class="quote">libpacket-capture</span>”</span> to dump packets received and
          transmitted by the server to the file. The appropriate name for the
          logger could be <span class="command"><strong>kea-dhcp4.packet-capture</strong></span>. (Note
          that the hook library implementor only specifies the second part of
          this name, i.e. <span class="quote">“<span class="quote">packet-capture</span>”</span>. The first part is a
          root logger name and is prepended by the Kea logging system.) It is
          also important to note that since this new logger is a child of a root
          logger, it inherits the configuration from the root logger, something
          that can be overridden by an entry in the configuration file.
        </p><p>
          The list of loggers above excludes any loggers implemented in hooks
          libraries. Please consult the documentation for the libraries for the
          names of the loggers they define.
        </p><p>
          Additional loggers may be defined in future versions of Kea. The
          easiest way to find out the logger name is to configure all logging to
          go to a single destination and look for specific logger names. See
          <a class="xref" href="#logging-message-format" title="18.1.2. Logging Message Format">Section 18.1.2, “Logging Message Format”</a> for details.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59483872"></a>18.1.1.2. severity (string)</h4></div></div></div><p>
          This specifies the category of messages logged.  Each message is
          logged with an associated severity which may be one of the following
          (in descending order of severity):
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
              FATAL - associated with messages generated by a condition that is
              so serious that the server cannot continue executing.
            </li><li class="listitem">
              ERROR- associated with messages generated by an error condition.
              The server will continue executing, but the results may not be as
              expected.
            </li><li class="listitem">
              WARN - indicates an out of the ordinary condition.  However, the
              server will continue executing normally.
            </li><li class="listitem">
              INFO - an informational message marking some event.
            </li><li class="listitem">
              DEBUG - messages produced for debugging purposes.
            </li></ul></div><p>
          When the severity of a logger is set to one of these values, it will
          only log messages of that severity and above (e.g. setting the logging
          severity to INFO will log INFO, WARN, ERROR and FATAL messages).  The
          severity may also be set to NONE, in which case all messages from that
          logger are inhibited.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            The keactrl tool, described in <a class="xref" href="#keactrl" title="Chapter 6. Managing Kea with keactrl">Chapter 6, <i>Managing Kea with keactrl</i></a>, can be
            configured to start the servers in the verbose mode. If this is the
            case, the settings of the logging severity in the configuration file
            will have no effect, i.e. the servers will use logging severity of
            DEBUG regardless of the logging settings specified in the
            configuration file. If you need to control severity via
            configuration file, please make sure that the
            <em class="parameter"><code>kea_verbose</code></em> value is set to "no" within the
            keactrl configuration.
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59494208"></a>18.1.1.3. debuglevel (integer)</h4></div></div></div><p>
          When a logger's severity is set to DEBUG, this value specifies what
          level of debug messages should be printed. It ranges from 0 (least
          verbose) to 99 (most verbose). If severity for the logger is not
          DEBUG, this value is ignored.
        </p></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59495600"></a>18.1.1.4. output_options (list)</h4></div></div></div><p>
          Each logger can have zero or more <code class="option">output_options</code>.
          These specify where log messages are sent. These are explained in
          detail below.
        </p><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp59497600"></a>18.1.1.4.1. output (string)</h5></div></div></div><p>
            This value determines the type of output. There are several special
            values allowed here: <span class="command"><strong>stdout</strong></span> (messages are printed
            on standard output), <span class="command"><strong>stderr</strong></span> (messages are printed
            on stderr), <span class="command"><strong>syslog</strong></span> (messages are logged to syslog
            using default name, <span class="command"><strong>syslog:name</strong></span> (messages are
            logged to syslog using specified name). Any other value is
            interpreted as a filename to which messages should be written.
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp59501216"></a>18.1.1.4.2. flush (true of false)</h5></div></div></div><p>
            Flush buffers after each log message. Doing this will reduce
            performance but will ensure that if the program terminates
            abnormally, all messages up to the point of termination are output.
            The default is "true".
          </p></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp59502784"></a>18.1.1.4.3. maxsize (integer)</h5></div></div></div><p>
            Only relevant when the destination is a file. This is maximum size
            in bytes that a log file may reach.  When the maximum size is
            reached, the file is renamed and a new file opened. For example,
            a ".1" is appended to the name — if a ".1" file exists, it
            is renamed ".2", etc. This is referred to as rotation.
          </p><p>
            The default value is 10240000 (10MB).  The smallest value that may
            be specified without disabling rotation is 204800. Any value less than
            this, including 0, disables rotation.
          </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
              Due to a limitation of the underlying logging library (log4cplus),
              rolling over the log files (from ".1" to ".2", etc) may show odd
              results: There can be multiple small files at the timing of roll
              over.  This can happen when multiple processes try to roll over
              the files simultaneously.  Version 1.1.0 of log4cplus solved this
              problem, so if this version or later of log4cplus is used to
              build Kea, it should not happen.  Even for older versions it is
              normally expected to happen rarely unless the log messages are
              produced very frequently by multiple different processes.
            </p></div></div><div class="section"><div class="titlepage"><div><div><h5 class="title"><a name="idp59506688"></a>18.1.1.4.4. maxver (integer)</h5></div></div></div><p>
            Only relevant when the destination is file and rotation is enabled
            (i.e. maxsize is large enough).  This is maximum number of rotated
            versions that will be kept. Once that number of files has been
            reached, the oldest file, "log-name.maxver", will be discarded
            each time the log rotates. In other words, at most there will be
            the active log file plus maxver rotated files.  The minimum and
            default value is 1.
          </p></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="idp59508592"></a>18.1.1.5. Example Logger Configurations</h4></div></div></div><p>
          In this example we want to set the global logging to write to the
          console using standard output.
        </p><pre class="screen"><strong class="userinput"><code>"Logging": {
    "loggers": [
        {
            "name": "kea-dhcp4",
            "output_options": [
                {
                    "output": "stdout"
                }
            ],
            "severity": "WARN"
        }
    ]
}</code></strong> </pre><p>
          In this second example, we want to store debug log messages in a file
          that is at most 2MB and keep up to 8 copies of old logfiles.  Once the
          logfile grows to 2MB, it will be renamed and a new file file be
          created.
        </p><pre class="screen"><strong class="userinput"><code>"Logging": {
    "loggers": [
        {
            "name": "kea-dhcp6",
            "output_options": [
                {
                    "output": "/var/log/kea-debug.log",
                    "maxver": 8,
                    "maxsize": 204800,
                    "flush": true
                }
            ],
            "severity": "DEBUG",
            "debuglevel": 99
        }
   ]
}</code></strong></pre></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="logging-message-format"></a>18.1.2. Logging Message Format</h3></div></div></div><p>
        Each message written  to the configured logging destinations comprises a
        number of components that identify the origin of the message and, if the
        message indicates a problem, information about the problem that may be
        useful in fixing it.
      </p><p>
        Consider the message below logged to a file:

</p><pre class="screen">2014-04-11 12:58:01.005 INFO  [kea-dhcp4.dhcpsrv/27456]
    DHCPSRV_MEMFILE_DB opening memory file lease database: type=memfile universe=4</pre><p>
      </p><p>
        Note: the layout of messages written to the system logging file (syslog)
        may be slightly different.  This message has been split across two lines
        here for display reasons; in the logging file, it will appear on one
        line.
      </p><p>
        The log message comprises a number of components:

       </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">2014-04-11 12:58:01.005</span></dt><dd><p>
               The date and time at which the message was generated.
              </p></dd><dt><span class="term">INFO</span></dt><dd><p>
                The severity of the message.
              </p></dd><dt><span class="term">[kea-dhcp4.dhcpsrv/27456]</span></dt><dd><p>
                The source of the message.  This comprises two elements: the Kea
                process generating the message (in this case,
                <span class="command"><strong>kea-dhcp4</strong></span>) and the component within the
                program from which the message originated
                (<span class="command"><strong>dhcpsrv</strong></span>, which is the name of the common
                library used by DHCP server implementations). The number after
                the slash is a process id (pid).
              </p></dd><dt><span class="term">DHCPSRV_MEMFILE_DB</span></dt><dd><p>
                The message identification.  Every message in Kea has a unique
                identification, which can be used as an index into the
                <a class="ulink" href="kea-messages.html" target="_top"><em class="citetitle">Kea Messages
                Manual</em></a>
                (<code class="uri"><a class="uri" href="http://kea.isc.org/docs/kea-messages.html" target="_top">http://kea.isc.org/docs/kea-messages.html</a></code>)
                from which more information can be obtained.
              </p></dd><dt><span class="term">opening memory file lease database: type=memfile universe=4</span></dt><dd><p>
                A brief description.  Within this text, information relating to
                the condition that caused the message to be logged will be
                included.  In this example, the information is logged that the
                in-memory lease database backend will be used to store DHCP
                leases.
              </p></dd></dl></div><p>
      </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="logging-during-startup"></a>18.1.3. Logging During Kea Startup</h3></div></div></div><p>
        The logging configuration is specified in the configuration file.
        However, when Kea starts, the file is not read until some way into the
        initialization process.  Prior to that, the logging settings are set to
        default values, although it is possible to modify some aspects of the
        settings by means of environment variables. Note that in the absence of
        any logging configuration in the configuration file, the settings of
        (possibly modified) default configuration will persist while the program
        is running.
      </p><p>
        The following environment variables can be used to control the behavior
        of logging during startup:
      </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">KEA_LOCKFILE_DIR</span></dt><dd><p>
              Specifies a directory where the logging system should create its
              lock file. If not specified, it is
              <em class="replaceable"><code>prefix</code></em>/var/run/kea, where
              <em class="replaceable"><code>prefix</code></em> defaults to /usr/local.  This
              variable must not end with a slash. There is one special value:
              "none", which instructs Kea to not create lock file at all. This
              may cause issues if several processes log to the same file.
            </p></dd><dt><span class="term">KEA_LOGGER_DESTINATION</span></dt><dd><p>
              Specifies logging output. There are several special values.
              </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">stdout</span></dt><dd><p>
                      Log to standard output.
                    </p></dd><dt><span class="term">stderr</span></dt><dd><p>
                      Log to standard error.
                    </p></dd><dt><span class="term">syslog[<span class="optional">:<em class="replaceable"><code>fac</code></em></span>]</span></dt><dd><p>
                      Log via syslog. The optional
                      <em class="replaceable"><code>fac</code></em> (which is separated from
                      the word "syslog" by a colon) specifies the facility to be
                      used for the log messages. Unless specified, messages will
                      be logged using the facility "local0".
                    </p></dd></dl></div><p>
              Any other value is treated as a name of the output file. If not
              specified otherwise, Kea will log to standard output.
            </p></dd></dl></div></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="kea-shell"></a>Chapter 19. The Kea Shell</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#shell-overview">19.1. Overview</a></span></dt><dt><span class="section"><a href="#shell-usage">19.2. Shell Usage</a></span></dt></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shell-overview"></a>19.1. Overview</h2></div></div></div><p>Kea 1.2.0 introduced the Control Agent (CA, see <a class="xref" href="#kea-ctrl-agent" title="Chapter 7. Kea Control Agent">Chapter 7, <i>Kea Control Agent</i></a>) that
    provides a RESTful control interface over HTTP. That API is typically expected to be used by
    various IPAMs and similar management systems. Nevertheless, there may be cases when you want
    to send a command to the CA directly.  The Kea Shell provides a way to do this.  It is a simple
    command-line, scripting-friendly text client that is able connect to the CA, send it commands
    with parameters, retrieve the responses and display them.</p><p>As the primary purpose of the Kea Shell is as a tool in scripting environment,
    it is not interactive. However, with simple tricks it can be run manually.
    </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="shell-usage"></a>19.2. Shell Usage</h2></div></div></div><p><span class="command"><strong>kea-shell</strong></span> is run as follows:
</p><pre class="screen">
kea-shell [--host hostname] [--port number] [--path path] [--timeout seconds] [--service service-name] [command]
</pre><p>
    where:
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="command"><strong>--host <em class="replaceable"><code>hostname</code></em></strong></span> specifies the hostname
          of the CA. If not specified, "localhost" is used.
        </li><li class="listitem">
          <span class="command"><strong>--port <em class="replaceable"><code>number</code></em></strong></span> specifies the TCP port
          on which the CA listens. If not specified, 8000 is used.
        </li><li class="listitem">
          <span class="command"><strong>--path <em class="replaceable"><code>path</code></em></strong></span> specifies
          the path in the URL to connect to. If not specified,
          empty path is used. As CA listens at the empty path
          this parameter is useful only with a reverse proxy.
        </li><li class="listitem">
          <span class="command"><strong>--timeout <em class="replaceable"><code>seconds</code></em></strong></span> specifies the
          timeout (in seconds) for the connection. If not given, 10 seconds is used.
        </li><li class="listitem">
          <span class="command"><strong>--service <em class="replaceable"><code>service-name</code></em></strong></span> specifies the
          target of a command. If not given, CA will be used as target.  May be used more
          than once to specify multiple targets.
        </li><li class="listitem">
          <span class="command"><strong>command</strong></span> specifies the command to be sent. If not specified,
          <span class="command"><strong>list-commands</strong></span> command is used.
        </li></ul></div><p>Other switches are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
          <span class="command"><strong>-h</strong></span> prints a help message.
        </li><li class="listitem">
          <span class="command"><strong>-v</strong></span> prints the software version.
        </li></ul></div><p>
      Once started, the shell reads parameters for the command from standard input, which are
      expected to be in JSON format. When all have been read, the shell establishes a connection
      with the CA using HTTP, sends the command and awaits a response. Once that is received,
      it is printed on standard output.
    </p><p>
      For a list of available commands, see <a class="xref" href="#ctrl-channel" title="Chapter 16. Management API">Chapter 16, <i>Management API</i></a>. Additional commands
      may be provided by hook libraries. If unsure which commands are supported, use the
      <span class="command"><strong>list-commands</strong></span> command. It will instruct the CA to return a list of
      all supported commands.
    </p><p>The following shows a simple example of usage:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-shell --host 192.0.2.1 --port 8001 --service dhcp4 list-commands</code></strong>
^D
</pre><p>
    After the command line is entered, the program waits for command parameters to be entered.
    Since <span class="command"><strong>list-commands</strong></span> does not take any
    arguments, CTRL-D (represented in the above example by "^D") is pressed to indicate end
    of file (and so terminate the parameter input). The Shell will then contact
    the CA and print out the list of available commands returned for the service named <span class="command"><strong>dhcp4</strong></span>.
    </p><p>It is envisaged that Kea Shell will be most frequently used in scripts. The next example
    shows a simple scripted execution. It sends the command "config-write" to the CA
    (<span class="command"><strong> --service </strong></span> parameter hasn't been used), along
    with the parameters specified in param.json. The result will be stored in result.json.
</p><pre class="screen">
$ cat param.json
"filename": "my-config-file.json"
$ <strong class="userinput"><code>cat param.json | kea-shell --host 192.0.2.1 config-write &gt; result.json</code></strong>
</pre><p>
    </p><p>When a reverse proxy is used to de-multiplex requests to different
    servers the default empty path in the URL is not enough so the
    <span class="command"><strong> --path </strong></span> parameter should be used. For instance
    if requests to the "/kea" path are forwarded to the CA this can be used:
</p><pre class="screen">
$ <strong class="userinput"><code>kea-shell --host 192.0.2.1 --port 8001 --path kea ...</code></strong>
</pre><p>
    </p><p>Kea Shell requires Python to to be installed on the system. It was tested with
    Python 2.7 and various versions
    of Python 3, up to 3.5. Since not every Kea deployment uses this feature and there are
    deployments that do not have Python, the Kea Shell is not enabled by default. To use it,
    you must specify <span class="command"><strong>--enable-shell</strong></span> to when running "configure" during the
    installation of Kea.</p><p>The Kea Shell is intended to serve more as a demonstration of the RESTful interface
    capabilities (and, perhaps, an illustration for people interested in integrating their
    management evironments with Kea) than as a serious management client. Do not expect it
    to be significantly expanded in the future. It is, and will remain, a simple tool.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="faq"></a>Chapter 20. Frequently Asked Questions</h1></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#faq-generic">20.1. General Frequently Asked Questions</a></span></dt><dd><dl><dt><span class="section"><a href="#q1-generic">20.1.1. Where did the Kea name came from?</a></span></dt><dt><span class="section"><a href="#q2-generic">20.1.2. Feature X is not supported yet. When/if will it be available?</a></span></dt></dl></dd><dt><span class="section"><a href="#faq-dhcp4">20.2. Frequently Asked Questions about DHCPv4</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59595232">20.2.1. I set up a firewall, but the Kea server still receives the traffic. Why?</a></span></dt></dl></dd><dt><span class="section"><a href="#faq-dhcp6">20.3. Frequently Asked Questions about DHCPv6</a></span></dt><dd><dl><dt><span class="section"><a href="#idp59600832">20.3.1. Kea DHCPv6 doesn't seem to get incoming traffic. I checked with tcpdump (or other traffic
      capture software) that the incoming traffic is reaching the box. What's wrong?</a></span></dt></dl></dd></dl></div><p>This chapter contains a number of frequently asked questions and
  troubleshooting tips. It currently lacks content, but it is expected to grow
  over time.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="faq-generic"></a>20.1. General Frequently Asked Questions</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="q1-generic"></a>20.1.1. Where did the Kea name came from?</h3></div></div></div><p>Kea is the name of a high mountain parrot living in New Zealand.
      See this <code class="uri"><a class="uri" href="https://lists.isc.org/pipermail/kea-users/2014-October/000032.html" target="_top">https://lists.isc.org/pipermail/kea-users/2014-October/000032.html</a></code>
      for an extended answer.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="q2-generic"></a>20.1.2. Feature X is not supported yet. When/if will it be available?</h3></div></div></div><p>Kea is developed by a small team of engineers. Our resources are
      limited, so we need to prioritize requests. The complexity of a new
      feature (how difficult it is to implement a feature and how likely it
      would break something that already works), amount of work required and
      expected popularity (i.e., how many users would actually benefit from it)
      are three leading factors. We sometimes also have contractual obligations.
      </p><p> Simply stating that you'd like feature X is useful. We try to
      implement features that are actively requested first, but the reality
      is that we have more requests than we can handle, so some of them must
      be postponed, at least in the near future. So is your request likely to
      be rejected? Not at all. You can do many things to greatly improve the
      chances of your request being fulfilled. First, it helps to explain why you
      need a feature. If your explanation is reasonable and there are likely
      other users that would benefit from it, the chances for Kea developers
      to put this task on a roadmap is better. Saying that you are willing
      to participate in tests (e.g., test engineering drops when they become
      available) is also helpful.</p><p>Another thing you can do to greatly improve the chances of a feature
      to appear is to actually develop it on your own and submit a patch.
      That's an avenue that people often forget about. Kea is open source
      software and we do accept patches. There are certain requirements, like
      code quality, comments, unit-tests, documentation, etc., but we have
      accepted a significant number of patches in the past, so it's doable.
      Accepted contributions range from minor documentation corrections to
      significant new features, like support for a new database type. Before
      considering writing and submitting a patch, make sure you read
      the Contributor's Guide in the
      <a class="ulink" href="http://git.kea.isc.org/~tester/kea/doxygen/" target="_top">Kea Developer's Guide</a>.
      </p><p>Kea is developed by ISC, which is a non-profit organization.
      You may consider signing a development contract with us. In the past
      we did implement certain features due to contractual obligations.
      With additional funds we are able to put extra engineering efforts
      into Kea development. We can reshuffle our schedule or add extra
      hands to the team if needed. Please keep in mind that Kea is
      open source software and its principle goal is to provide a good DHCP
      solution that can be used by everyone. In other words, we may
      refuse a contract that would tie the solution to specific proprietary
      technology or make it unusable for other users. Also, we strive to
      make Kea a reference implementation, so if your proposal significantly
      violates a RFC, we may have a problem with that. Nevertheless, please
      talk to us and we may be able to find a solution.</p><p>Finally, Kea has a <a class="ulink" href="http://kea.isc.org/roadmap" target="_top">public
      roadmap</a>, with releases happening several times each year. We tend
      to not modify plans for the current milestone, unless there are very good
      reasons to do so. Therefore "I'd like a feature X in 6 months" is much
      better received than "I'd like a feature X now".</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="faq-dhcp4"></a>20.2. Frequently Asked Questions about DHCPv4</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp59595232"></a>20.2.1. I set up a firewall, but the Kea server still receives the traffic. Why?</h3></div></div></div><p>Any DHCPv4 server must be able to receive from and send traffic to
      hosts that don't have an IPv4 address assigned yet. That is typically not
      possible with regular UDP sockets, therefore the Kea DHCPv4 server uses raw
      sockets by default. Raw sockets mean that the incoming packets are received
      as raw Ethernet frames, thus bypassing the whole kernel IP stack, including
      any firewalling rules your kernel may provide.</p><p>If you do not want the server to use raw sockets, it is possible to
      configure the Kea DHCPv4 server to use UDP sockets instead. See <span class="command"><strong>dhcp-socket-type</strong></span>
      described in <a class="xref" href="#dhcp4-interface-configuration" title="8.2.4. Interface Configuration">Section 8.2.4, “Interface Configuration”</a>. However,
      using UDP sockets has certain limitations. In particular, they may not allow
      for sending responses directly to clients without IPv4 addresses assigned.
      That's ok, if all your traffic is coming through relay agents.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="faq-dhcp6"></a>20.3. Frequently Asked Questions about DHCPv6</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="idp59600832"></a>20.3.1. Kea DHCPv6 doesn't seem to get incoming traffic. I checked with tcpdump (or other traffic
      capture software) that the incoming traffic is reaching the box. What's wrong?</h3></div></div></div><p>Please check whether your OS has any IPv6 filtering rules. Many
      operating systems are shipped with firewalls that discard incoming IPv6
      traffic by default. In particular, many Linux distributions do that. Please
      check the output of the following command:
  </p><pre class="screen">
# <strong class="userinput"><code>ip6tables -L -n</code></strong></pre><p>
      One common mistake in this area is to use <span class="command"><strong>iptables</strong></span> tool,
      which lists IPv4 firewall rules only.
      </p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a name="acknowledgments"></a>Chapter 21. Acknowledgments</h1></div></div></div><p>Kea is an open source project designed, developed, and maintained by Internet Systems
      Consortium, Inc, a 501(c)3 non-profit organization. ISC is primarily funded by revenues from
      support subscriptions for our open source and we encourage all professional users to consider
      this option. To learn more, see ​<a class="ulink" href="https://www.isc.org/support/" target="_top">https://www.isc.org/support/</a>.</p><p>If you would like to contribute to ISC to assist us in continuing to make quality open
      source software, please visit our donations page at ​<a class="ulink" href="http://www.isc.org/donate/" target="_top">http://www.isc.org/donate/</a>.</p><p>We thank all the organizations and individuals who have helped to make Kea
      possible. <a class="ulink" href="http://www.comcast.com/" target="_top">Comcast</a>
       and the Comcast Innovation Fund provided major support for the development
      of Kea's DHCPv4, DHCPv6 and DDNS modules. Mozilla funded initial work on the REST API via a
      MOSS award.</p><p>Kea was initially implemented as a collection of applications
      within the BIND 10 framework. We thank the founding sponsors of the BIND10 project:
      <a class="ulink" href="https://www.afilias.info/" target="_top">Afilias</a>,
      <a class="ulink" href="https://www.iis.se/" target="_top">IIS.SE</a>,
      <a class="ulink" href="http://www.nominet.org.uk/" target="_top">Nominet</a>, 
      <a class="ulink" href="https://www.sidn.nl/" target="_top">SIDN</a>,
      <a class="ulink" href="http://jprs.co.jp/" target="_top">JPRS</a>,
      <a class="ulink" href="http://cira.ca/" target="_top">CIRA</a>; and additional sponsors
      <a class="ulink" href="https://www.afnic.fr/" target="_top">AFNIC</a>,
      <a class="ulink" href="https://www.cnnic.net.cn/" target="_top">CNNIC</a>,
      <a class="ulink" href="https://www.nic.cz/" target="_top">CZ.NIC</a>,
      <a class="ulink" href="http://www.denic.de/" target="_top">DENIC eG</a>,
      <a class="ulink" href="https://www.google.com/" target="_top">Google</a>,
      <a class="ulink" href="https://www.ripe.net/" target="_top">RIPE NCC</a>,
      <a class="ulink" href="https://registro.br/" target="_top">Registro.br</a>,
      <a class="ulink" href="https://nzrs.net.nz/" target="_top">.nz Registry Services</a>, and
      <a class="ulink" href="https://www.tcinet.ru/" target="_top">Technical Center of Internet</a>
      .</p></div></div></body></html>
